// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

@file:Suppress("NAME_SHADOWING")

package org.matrix.rustcomponents.sdk

// Common helper code.
//
// Ideally this would live in a separate .kt file where it can be unittested etc
// in isolation, and perhaps even published as a re-useable package.
//
// However, it's important that the details of how this helper code works (e.g. the
// way that different builtin types are passed across the FFI) exactly match what's
// expected by the Rust code on the other side of the interface. In practice right
// now that means coming from the exact some version of `uniffi` that was used to
// compile the Rust component. The easiest way to ensure this is to bundle the Kotlin
// helpers directly inline like we're doing here.

import com.sun.jna.Library
import com.sun.jna.IntegerType
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.Structure
import com.sun.jna.Callback
import com.sun.jna.ptr.*
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.CharBuffer
import java.nio.charset.CodingErrorAction
import java.util.concurrent.atomic.AtomicLong
import java.util.concurrent.ConcurrentHashMap
import android.os.Build
import androidx.annotation.RequiresApi
import java.util.concurrent.atomic.AtomicBoolean
import kotlin.coroutines.resume
import kotlinx.coroutines.CancellableContinuation
import kotlinx.coroutines.DelicateCoroutinesApi
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.suspendCancellableCoroutine
import uniffi.matrix_sdk.BackupDownloadStrategy
import uniffi.matrix_sdk.FfiConverterTypeBackupDownloadStrategy
import uniffi.matrix_sdk.FfiConverterTypeOAuthAuthorizationData
import uniffi.matrix_sdk.FfiConverterTypeRoomMemberRole
import uniffi.matrix_sdk.FfiConverterTypeRoomPaginationStatus
import uniffi.matrix_sdk.FfiConverterTypeRoomPowerLevelChanges
import uniffi.matrix_sdk.FfiConverterTypeServerVendorInfo
import uniffi.matrix_sdk.FfiConverterTypeVirtualElementCallWidgetConfig
import uniffi.matrix_sdk.FfiConverterTypeVirtualElementCallWidgetProperties
import uniffi.matrix_sdk.OAuthAuthorizationData
import uniffi.matrix_sdk.RoomMemberRole
import uniffi.matrix_sdk.RoomPaginationStatus
import uniffi.matrix_sdk.RoomPowerLevelChanges
import uniffi.matrix_sdk.ServerVendorInfo
import uniffi.matrix_sdk.VirtualElementCallWidgetConfig
import uniffi.matrix_sdk.VirtualElementCallWidgetProperties
import uniffi.matrix_sdk_base.EncryptionState
import uniffi.matrix_sdk_base.FfiConverterTypeEncryptionState
import uniffi.matrix_sdk_base.FfiConverterTypeMediaRetentionPolicy
import uniffi.matrix_sdk_base.MediaRetentionPolicy
import uniffi.matrix_sdk_common.FfiConverterTypeShieldStateCode
import uniffi.matrix_sdk_common.ShieldStateCode
import uniffi.matrix_sdk_crypto.CollectStrategy
import uniffi.matrix_sdk_crypto.DecryptionSettings
import uniffi.matrix_sdk_crypto.FfiConverterTypeCollectStrategy
import uniffi.matrix_sdk_crypto.FfiConverterTypeDecryptionSettings
import uniffi.matrix_sdk_crypto.FfiConverterTypeIdentityState
import uniffi.matrix_sdk_crypto.FfiConverterTypeUtdCause
import uniffi.matrix_sdk_crypto.IdentityState
import uniffi.matrix_sdk_crypto.UtdCause
import uniffi.matrix_sdk_ui.EventItemOrigin
import uniffi.matrix_sdk_ui.FfiConverterTypeEventItemOrigin
import uniffi.matrix_sdk_ui.FfiConverterTypeRoomPinnedEventsChange
import uniffi.matrix_sdk_ui.FfiConverterTypeSpaceRoomListPaginationState
import uniffi.matrix_sdk_ui.RoomPinnedEventsChange
import uniffi.matrix_sdk_ui.SpaceRoomListPaginationState
import uniffi.matrix_sdk.RustBuffer as RustBufferBackupDownloadStrategy
import uniffi.matrix_sdk.RustBuffer as RustBufferOAuthAuthorizationData
import uniffi.matrix_sdk.RustBuffer as RustBufferRoomMemberRole
import uniffi.matrix_sdk.RustBuffer as RustBufferRoomPaginationStatus
import uniffi.matrix_sdk.RustBuffer as RustBufferRoomPowerLevelChanges
import uniffi.matrix_sdk.RustBuffer as RustBufferServerVendorInfo
import uniffi.matrix_sdk.RustBuffer as RustBufferVirtualElementCallWidgetConfig
import uniffi.matrix_sdk.RustBuffer as RustBufferVirtualElementCallWidgetProperties
import uniffi.matrix_sdk_base.RustBuffer as RustBufferEncryptionState
import uniffi.matrix_sdk_base.RustBuffer as RustBufferMediaRetentionPolicy
import uniffi.matrix_sdk_common.RustBuffer as RustBufferShieldStateCode
import uniffi.matrix_sdk_crypto.RustBuffer as RustBufferCollectStrategy
import uniffi.matrix_sdk_crypto.RustBuffer as RustBufferDecryptionSettings
import uniffi.matrix_sdk_crypto.RustBuffer as RustBufferIdentityState
import uniffi.matrix_sdk_crypto.RustBuffer as RustBufferUtdCause
import uniffi.matrix_sdk_ui.RustBuffer as RustBufferEventItemOrigin
import uniffi.matrix_sdk_ui.RustBuffer as RustBufferRoomPinnedEventsChange
import uniffi.matrix_sdk_ui.RustBuffer as RustBufferSpaceRoomListPaginationState

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

@Structure.FieldOrder("capacity", "len", "data")
open class RustBuffer : Structure() {
    // Note: `capacity` and `len` are actually `ULong` values, but JVM only supports signed values.
    // When dealing with these fields, make sure to call `toULong()`.
    @JvmField var capacity: Long = 0
    @JvmField var len: Long = 0
    @JvmField var data: Pointer? = null

    class ByValue: RustBuffer(), Structure.ByValue
    class ByReference: RustBuffer(), Structure.ByReference

   internal fun setValue(other: RustBuffer) {
        capacity = other.capacity
        len = other.len
        data = other.data
    }

    companion object {
        internal fun alloc(size: ULong = 0UL) = uniffiRustCall() { status ->
            // Note: need to convert the size to a `Long` value to make this work with JVM.
            UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rustbuffer_alloc(size.toLong(), status)
        }.also {
            if(it.data == null) {
               throw RuntimeException("RustBuffer.alloc() returned null data pointer (size=${size})")
           }
        }

        internal fun create(capacity: ULong, len: ULong, data: Pointer?): RustBuffer.ByValue {
            var buf = RustBuffer.ByValue()
            buf.capacity = capacity.toLong()
            buf.len = len.toLong()
            buf.data = data
            return buf
        }

        internal fun free(buf: RustBuffer.ByValue) = uniffiRustCall() { status ->
            UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rustbuffer_free(buf, status)
        }
    }

    @Suppress("TooGenericExceptionThrown")
    fun asByteBuffer() =
        this.data?.getByteBuffer(0, this.len.toLong())?.also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
}

/**
 * The equivalent of the `*mut RustBuffer` type.
 * Required for callbacks taking in an out pointer.
 *
 * Size is the sum of all values in the struct.
 */
class RustBufferByReference : ByReference(16) {
    /**
     * Set the pointed-to `RustBuffer` to the given value.
     */
    fun setValue(value: RustBuffer.ByValue) {
        // NOTE: The offsets are as they are in the C-like struct.
        val pointer = getPointer()
        pointer.setLong(0, value.capacity)
        pointer.setLong(8, value.len)
        pointer.setPointer(16, value.data)
    }

    /**
     * Get a `RustBuffer.ByValue` from this reference.
     */
    fun getValue(): RustBuffer.ByValue {
        val pointer = getPointer()
        val value = RustBuffer.ByValue()
        value.writeField("capacity", pointer.getLong(0))
        value.writeField("len", pointer.getLong(8))
        value.writeField("data", pointer.getLong(16))

        return value
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to in the JVM, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

@Structure.FieldOrder("len", "data")
open class ForeignBytes : Structure() {
    @JvmField var len: Int = 0
    @JvmField var data: Pointer? = null

    class ByValue : ForeignBytes(), Structure.ByValue
}
// The FfiConverter interface handles converter types to and from the FFI
//
// All implementing objects should be public to support external types.  When a
// type is external we need to import it's FfiConverter.
public interface FfiConverter<KotlinType, FfiType> {
    // Convert an FFI type to a Kotlin type
    fun lift(value: FfiType): KotlinType

    // Convert an Kotlin type to an FFI type
    fun lower(value: KotlinType): FfiType

    // Read a Kotlin type from a `ByteBuffer`
    fun read(buf: ByteBuffer): KotlinType

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    fun allocationSize(value: KotlinType): ULong

    // Write a Kotlin type to a `ByteBuffer`
    fun write(value: KotlinType, buf: ByteBuffer)

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    fun lowerIntoRustBuffer(value: KotlinType): RustBuffer.ByValue {
        val rbuf = RustBuffer.alloc(allocationSize(value))
        try {
            val bbuf = rbuf.data!!.getByteBuffer(0, rbuf.capacity).also {
                it.order(ByteOrder.BIG_ENDIAN)
            }
            write(value, bbuf)
            rbuf.writeField("len", bbuf.position().toLong())
            return rbuf
        } catch (e: Throwable) {
            RustBuffer.free(rbuf)
            throw e
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    fun liftFromRustBuffer(rbuf: RustBuffer.ByValue): KotlinType {
        val byteBuf = rbuf.asByteBuffer()!!
        try {
           val item = read(byteBuf)
           if (byteBuf.hasRemaining()) {
               throw RuntimeException("junk remaining in buffer after lifting, something is very wrong!!")
           }
           return item
        } finally {
            RustBuffer.free(rbuf)
        }
    }
}

// FfiConverter that uses `RustBuffer` as the FfiType
public interface FfiConverterRustBuffer<KotlinType>: FfiConverter<KotlinType, RustBuffer.ByValue> {
    override fun lift(value: RustBuffer.ByValue) = liftFromRustBuffer(value)
    override fun lower(value: KotlinType) = lowerIntoRustBuffer(value)
}
// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.

internal const val UNIFFI_CALL_SUCCESS = 0.toByte()
internal const val UNIFFI_CALL_ERROR = 1.toByte()
internal const val UNIFFI_CALL_UNEXPECTED_ERROR = 2.toByte()

@Structure.FieldOrder("code", "error_buf")
internal open class UniffiRustCallStatus : Structure() {
    @JvmField var code: Byte = 0
    @JvmField var error_buf: RustBuffer.ByValue = RustBuffer.ByValue()

    class ByValue: UniffiRustCallStatus(), Structure.ByValue

    fun isSuccess(): Boolean {
        return code == UNIFFI_CALL_SUCCESS
    }

    fun isError(): Boolean {
        return code == UNIFFI_CALL_ERROR
    }

    fun isPanic(): Boolean {
        return code == UNIFFI_CALL_UNEXPECTED_ERROR
    }

    companion object {
        fun create(code: Byte, errorBuf: RustBuffer.ByValue): UniffiRustCallStatus.ByValue {
            val callStatus = UniffiRustCallStatus.ByValue()
            callStatus.code = code
            callStatus.error_buf = errorBuf
            return callStatus
        }
    }
}

class InternalException(message: String) : kotlin.Exception(message)

// Each top-level error class has a companion object that can lift the error from the call status's rust buffer
interface UniffiRustCallStatusErrorHandler<E> {
    fun lift(error_buf: RustBuffer.ByValue): E;
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself

// Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
private inline fun <U, E: kotlin.Exception> uniffiRustCallWithError(errorHandler: UniffiRustCallStatusErrorHandler<E>, callback: (UniffiRustCallStatus) -> U): U {
    var status = UniffiRustCallStatus()
    val return_value = callback(status)
    uniffiCheckCallStatus(errorHandler, status)
    return return_value
}

// Check UniffiRustCallStatus and throw an error if the call wasn't successful
private fun<E: kotlin.Exception> uniffiCheckCallStatus(errorHandler: UniffiRustCallStatusErrorHandler<E>, status: UniffiRustCallStatus) {
    if (status.isSuccess()) {
        return
    } else if (status.isError()) {
        throw errorHandler.lift(status.error_buf)
    } else if (status.isPanic()) {
        // when the rust code sees a panic, it tries to construct a rustbuffer
        // with the message.  but if that code panics, then it just sends back
        // an empty buffer.
        if (status.error_buf.len > 0) {
            throw InternalException(FfiConverterString.lift(status.error_buf))
        } else {
            throw InternalException("Rust panic")
        }
    } else {
        throw InternalException("Unknown rust call status: $status.code")
    }
}

// UniffiRustCallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
object UniffiNullRustCallStatusErrorHandler: UniffiRustCallStatusErrorHandler<InternalException> {
    override fun lift(error_buf: RustBuffer.ByValue): InternalException {
        RustBuffer.free(error_buf)
        return InternalException("Unexpected CALL_ERROR")
    }
}

// Call a rust function that returns a plain value
private inline fun <U> uniffiRustCall(callback: (UniffiRustCallStatus) -> U): U {
    return uniffiRustCallWithError(UniffiNullRustCallStatusErrorHandler, callback)
}

internal inline fun<T> uniffiTraitInterfaceCall(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
) {
    try {
        writeReturn(makeCall())
    } catch(e: kotlin.Exception) {
        callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
        callStatus.error_buf = FfiConverterString.lower(e.toString())
    }
}

internal inline fun<T, reified E: Throwable> uniffiTraitInterfaceCallWithError(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
    lowerError: (E) -> RustBuffer.ByValue
) {
    try {
        writeReturn(makeCall())
    } catch(e: kotlin.Exception) {
        if (e is E) {
            callStatus.code = UNIFFI_CALL_ERROR
            callStatus.error_buf = lowerError(e)
        } else {
            callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
            callStatus.error_buf = FfiConverterString.lower(e.toString())
        }
    }
}
// Map handles to objects
//
// This is used pass an opaque 64-bit handle representing a foreign object to the Rust code.
internal class UniffiHandleMap<T: Any> {
    private val map = ConcurrentHashMap<Long, T>()
    private val counter = java.util.concurrent.atomic.AtomicLong(0)

    val size: Int
        get() = map.size

    // Insert a new object into the handle map and get a handle for it
    fun insert(obj: T): Long {
        val handle = counter.getAndAdd(1)
        map.put(handle, obj)
        return handle
    }

    // Get an object from the handle map
    fun get(handle: Long): T {
        return map.get(handle) ?: throw InternalException("UniffiHandleMap.get: Invalid handle")
    }

    // Remove an entry from the handlemap and get the Kotlin object back
    fun remove(handle: Long): T {
        return map.remove(handle) ?: throw InternalException("UniffiHandleMap: Invalid handle")
    }
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.
@Synchronized
private fun findLibraryName(componentName: String): String {
    val libOverride = System.getProperty("uniffi.component.$componentName.libraryOverride")
    if (libOverride != null) {
        return libOverride
    }
    return "matrix_sdk_ffi"
}

private inline fun <reified Lib : Library> loadIndirect(
    componentName: String
): Lib {
    return Native.load<Lib>(findLibraryName(componentName), Lib::class.java)
}

// Define FFI callback types
internal interface UniffiRustFutureContinuationCallback : com.sun.jna.Callback {
    fun callback(`data`: Long,`pollResult`: Byte,)
}
internal interface UniffiForeignFutureFree : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
}
internal interface UniffiCallbackInterfaceFree : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
}
@Structure.FieldOrder("handle", "free")
internal open class UniffiForeignFuture(
    @JvmField internal var `handle`: Long = 0.toLong(),
    @JvmField internal var `free`: UniffiForeignFutureFree? = null,
) : Structure() {
    class UniffiByValue(
        `handle`: Long = 0.toLong(),
        `free`: UniffiForeignFutureFree? = null,
    ): UniffiForeignFuture(`handle`,`free`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFuture) {
        `handle` = other.`handle`
        `free` = other.`free`
    }

}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU8(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU8 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU8.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI8(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI8 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI8.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU16(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU16 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU16.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI16(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI16 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI16.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructU64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructU64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructU64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructI64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructI64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructI64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructF32(
    @JvmField internal var `returnValue`: Float = 0.0f,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Float = 0.0f,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructF32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructF32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteF32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructF32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructF64(
    @JvmField internal var `returnValue`: Double = 0.0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Double = 0.0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructF64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructF64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteF64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructF64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructPointer(
    @JvmField internal var `returnValue`: Pointer = Pointer.NULL,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Pointer = Pointer.NULL,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructPointer(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructPointer) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompletePointer : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructPointer.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructRustBuffer(
    @JvmField internal var `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructRustBuffer(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructRustBuffer) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteRustBuffer : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructRustBuffer.UniffiByValue,)
}
@Structure.FieldOrder("callStatus")
internal open class UniffiForeignFutureStructVoid(
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureStructVoid(`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureStructVoid) {
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteVoid : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureStructVoid.UniffiByValue,)
}
internal interface UniffiCallbackInterfaceAccountDataListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`event`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceBackupStateListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`status`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceBackupSteadyStateListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`status`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceCallDeclineListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`declinerUserId`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceClientDelegateMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`isSoftLogout`: Byte,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceClientSessionDelegateMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`userId`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceClientSessionDelegateMethod1 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`session`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceEnableRecoveryProgressListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`status`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceGeneratedQrLoginProgressListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`state`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceIdentityStatusChangeListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`identityStatusChange`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceIgnoredUsersListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`ignoredUserIds`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceKnockRequestsListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`joinRequests`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceLiveLocationShareListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`liveLocationShares`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceMediaPreviewConfigListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`mediaPreviewConfig`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceNotificationSettingsDelegateMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfacePaginationStatusListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`status`: RustBufferRoomPaginationStatus.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceProgressWatcherMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`progress`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceQrLoginProgressListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`state`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceRecoveryStateListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`status`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceRoomAccountDataListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`event`: RustBuffer.ByValue,`roomId`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceRoomDirectorySearchEntriesListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`roomEntriesUpdate`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceRoomInfoListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`roomInfo`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceRoomListEntriesListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`roomEntriesUpdate`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceRoomListLoadingStateListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`state`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceRoomListServiceStateListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`state`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceRoomListServiceSyncIndicatorListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`syncIndicator`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSendQueueListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`update`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSendQueueRoomErrorListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`roomId`: RustBuffer.ByValue,`error`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSendQueueRoomUpdateListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`roomId`: RustBuffer.ByValue,`update`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`details`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod1 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod2 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod3 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`data`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod4 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod5 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod6 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSpaceRoomListEntriesListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`rooms`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSpaceRoomListPaginationStateListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`paginationState`: RustBufferSpaceRoomListPaginationState.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSpaceRoomListSpaceListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`space`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSpaceServiceJoinedSpacesListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`roomUpdates`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSyncServiceStateObserverMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`state`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceTimelineListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`diff`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceTypingNotificationsListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`typingUserIds`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceUnableToDecryptDelegateMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`info`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceVerificationStateListenerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`status`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceWidgetCapabilitiesProviderMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`capabilities`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
@Structure.FieldOrder("onChange", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceAccountDataListener(
    @JvmField internal var `onChange`: UniffiCallbackInterfaceAccountDataListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onChange`: UniffiCallbackInterfaceAccountDataListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceAccountDataListener(`onChange`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceAccountDataListener) {
        `onChange` = other.`onChange`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceBackupStateListener(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceBackupStateListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceBackupStateListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceBackupStateListener(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceBackupStateListener) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceBackupSteadyStateListener(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceBackupSteadyStateListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceBackupSteadyStateListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceBackupSteadyStateListener(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceBackupSteadyStateListener) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("call", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceCallDeclineListener(
    @JvmField internal var `call`: UniffiCallbackInterfaceCallDeclineListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `call`: UniffiCallbackInterfaceCallDeclineListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceCallDeclineListener(`call`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceCallDeclineListener) {
        `call` = other.`call`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("didReceiveAuthError", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceClientDelegate(
    @JvmField internal var `didReceiveAuthError`: UniffiCallbackInterfaceClientDelegateMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `didReceiveAuthError`: UniffiCallbackInterfaceClientDelegateMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceClientDelegate(`didReceiveAuthError`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceClientDelegate) {
        `didReceiveAuthError` = other.`didReceiveAuthError`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("retrieveSessionFromKeychain", "saveSessionInKeychain", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceClientSessionDelegate(
    @JvmField internal var `retrieveSessionFromKeychain`: UniffiCallbackInterfaceClientSessionDelegateMethod0? = null,
    @JvmField internal var `saveSessionInKeychain`: UniffiCallbackInterfaceClientSessionDelegateMethod1? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `retrieveSessionFromKeychain`: UniffiCallbackInterfaceClientSessionDelegateMethod0? = null,
        `saveSessionInKeychain`: UniffiCallbackInterfaceClientSessionDelegateMethod1? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceClientSessionDelegate(`retrieveSessionFromKeychain`,`saveSessionInKeychain`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceClientSessionDelegate) {
        `retrieveSessionFromKeychain` = other.`retrieveSessionFromKeychain`
        `saveSessionInKeychain` = other.`saveSessionInKeychain`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceEnableRecoveryProgressListener(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceEnableRecoveryProgressListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceEnableRecoveryProgressListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceEnableRecoveryProgressListener(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceEnableRecoveryProgressListener) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceGeneratedQrLoginProgressListener(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceGeneratedQrLoginProgressListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceGeneratedQrLoginProgressListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceGeneratedQrLoginProgressListener(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceGeneratedQrLoginProgressListener) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("call", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceIdentityStatusChangeListener(
    @JvmField internal var `call`: UniffiCallbackInterfaceIdentityStatusChangeListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `call`: UniffiCallbackInterfaceIdentityStatusChangeListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceIdentityStatusChangeListener(`call`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceIdentityStatusChangeListener) {
        `call` = other.`call`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("call", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceIgnoredUsersListener(
    @JvmField internal var `call`: UniffiCallbackInterfaceIgnoredUsersListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `call`: UniffiCallbackInterfaceIgnoredUsersListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceIgnoredUsersListener(`call`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceIgnoredUsersListener) {
        `call` = other.`call`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("call", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceKnockRequestsListener(
    @JvmField internal var `call`: UniffiCallbackInterfaceKnockRequestsListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `call`: UniffiCallbackInterfaceKnockRequestsListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceKnockRequestsListener(`call`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceKnockRequestsListener) {
        `call` = other.`call`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("call", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceLiveLocationShareListener(
    @JvmField internal var `call`: UniffiCallbackInterfaceLiveLocationShareListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `call`: UniffiCallbackInterfaceLiveLocationShareListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceLiveLocationShareListener(`call`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceLiveLocationShareListener) {
        `call` = other.`call`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onChange", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceMediaPreviewConfigListener(
    @JvmField internal var `onChange`: UniffiCallbackInterfaceMediaPreviewConfigListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onChange`: UniffiCallbackInterfaceMediaPreviewConfigListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceMediaPreviewConfigListener(`onChange`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceMediaPreviewConfigListener) {
        `onChange` = other.`onChange`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("settingsDidChange", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceNotificationSettingsDelegate(
    @JvmField internal var `settingsDidChange`: UniffiCallbackInterfaceNotificationSettingsDelegateMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `settingsDidChange`: UniffiCallbackInterfaceNotificationSettingsDelegateMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceNotificationSettingsDelegate(`settingsDidChange`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceNotificationSettingsDelegate) {
        `settingsDidChange` = other.`settingsDidChange`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfacePaginationStatusListener(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfacePaginationStatusListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfacePaginationStatusListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfacePaginationStatusListener(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfacePaginationStatusListener) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("transmissionProgress", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceProgressWatcher(
    @JvmField internal var `transmissionProgress`: UniffiCallbackInterfaceProgressWatcherMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `transmissionProgress`: UniffiCallbackInterfaceProgressWatcherMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceProgressWatcher(`transmissionProgress`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceProgressWatcher) {
        `transmissionProgress` = other.`transmissionProgress`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceQrLoginProgressListener(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceQrLoginProgressListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceQrLoginProgressListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceQrLoginProgressListener(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceQrLoginProgressListener) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceRecoveryStateListener(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceRecoveryStateListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceRecoveryStateListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceRecoveryStateListener(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceRecoveryStateListener) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onChange", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceRoomAccountDataListener(
    @JvmField internal var `onChange`: UniffiCallbackInterfaceRoomAccountDataListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onChange`: UniffiCallbackInterfaceRoomAccountDataListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceRoomAccountDataListener(`onChange`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceRoomAccountDataListener) {
        `onChange` = other.`onChange`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceRoomDirectorySearchEntriesListener(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceRoomDirectorySearchEntriesListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceRoomDirectorySearchEntriesListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceRoomDirectorySearchEntriesListener(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceRoomDirectorySearchEntriesListener) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("call", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceRoomInfoListener(
    @JvmField internal var `call`: UniffiCallbackInterfaceRoomInfoListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `call`: UniffiCallbackInterfaceRoomInfoListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceRoomInfoListener(`call`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceRoomInfoListener) {
        `call` = other.`call`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceRoomListEntriesListener(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceRoomListEntriesListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceRoomListEntriesListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceRoomListEntriesListener(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceRoomListEntriesListener) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceRoomListLoadingStateListener(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceRoomListLoadingStateListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceRoomListLoadingStateListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceRoomListLoadingStateListener(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceRoomListLoadingStateListener) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceRoomListServiceStateListener(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceRoomListServiceStateListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceRoomListServiceStateListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceRoomListServiceStateListener(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceRoomListServiceStateListener) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceRoomListServiceSyncIndicatorListener(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceRoomListServiceSyncIndicatorListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceRoomListServiceSyncIndicatorListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceRoomListServiceSyncIndicatorListener(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceRoomListServiceSyncIndicatorListener) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceSendQueueListener(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceSendQueueListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceSendQueueListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceSendQueueListener(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceSendQueueListener) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onError", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceSendQueueRoomErrorListener(
    @JvmField internal var `onError`: UniffiCallbackInterfaceSendQueueRoomErrorListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onError`: UniffiCallbackInterfaceSendQueueRoomErrorListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceSendQueueRoomErrorListener(`onError`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceSendQueueRoomErrorListener) {
        `onError` = other.`onError`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceSendQueueRoomUpdateListener(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceSendQueueRoomUpdateListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceSendQueueRoomUpdateListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceSendQueueRoomUpdateListener(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceSendQueueRoomUpdateListener) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("didReceiveVerificationRequest", "didAcceptVerificationRequest", "didStartSasVerification", "didReceiveVerificationData", "didFail", "didCancel", "didFinish", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceSessionVerificationControllerDelegate(
    @JvmField internal var `didReceiveVerificationRequest`: UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod0? = null,
    @JvmField internal var `didAcceptVerificationRequest`: UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod1? = null,
    @JvmField internal var `didStartSasVerification`: UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod2? = null,
    @JvmField internal var `didReceiveVerificationData`: UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod3? = null,
    @JvmField internal var `didFail`: UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod4? = null,
    @JvmField internal var `didCancel`: UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod5? = null,
    @JvmField internal var `didFinish`: UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod6? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `didReceiveVerificationRequest`: UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod0? = null,
        `didAcceptVerificationRequest`: UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod1? = null,
        `didStartSasVerification`: UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod2? = null,
        `didReceiveVerificationData`: UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod3? = null,
        `didFail`: UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod4? = null,
        `didCancel`: UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod5? = null,
        `didFinish`: UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod6? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceSessionVerificationControllerDelegate(`didReceiveVerificationRequest`,`didAcceptVerificationRequest`,`didStartSasVerification`,`didReceiveVerificationData`,`didFail`,`didCancel`,`didFinish`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceSessionVerificationControllerDelegate) {
        `didReceiveVerificationRequest` = other.`didReceiveVerificationRequest`
        `didAcceptVerificationRequest` = other.`didAcceptVerificationRequest`
        `didStartSasVerification` = other.`didStartSasVerification`
        `didReceiveVerificationData` = other.`didReceiveVerificationData`
        `didFail` = other.`didFail`
        `didCancel` = other.`didCancel`
        `didFinish` = other.`didFinish`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceSpaceRoomListEntriesListener(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceSpaceRoomListEntriesListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceSpaceRoomListEntriesListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceSpaceRoomListEntriesListener(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceSpaceRoomListEntriesListener) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceSpaceRoomListPaginationStateListener(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceSpaceRoomListPaginationStateListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceSpaceRoomListPaginationStateListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceSpaceRoomListPaginationStateListener(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceSpaceRoomListPaginationStateListener) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceSpaceRoomListSpaceListener(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceSpaceRoomListSpaceListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceSpaceRoomListSpaceListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceSpaceRoomListSpaceListener(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceSpaceRoomListSpaceListener) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceSpaceServiceJoinedSpacesListener(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceSpaceServiceJoinedSpacesListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceSpaceServiceJoinedSpacesListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceSpaceServiceJoinedSpacesListener(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceSpaceServiceJoinedSpacesListener) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceSyncServiceStateObserver(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceSyncServiceStateObserverMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceSyncServiceStateObserverMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceSyncServiceStateObserver(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceSyncServiceStateObserver) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceTimelineListener(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceTimelineListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceTimelineListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceTimelineListener(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceTimelineListener) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("call", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceTypingNotificationsListener(
    @JvmField internal var `call`: UniffiCallbackInterfaceTypingNotificationsListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `call`: UniffiCallbackInterfaceTypingNotificationsListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceTypingNotificationsListener(`call`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceTypingNotificationsListener) {
        `call` = other.`call`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUtd", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceUnableToDecryptDelegate(
    @JvmField internal var `onUtd`: UniffiCallbackInterfaceUnableToDecryptDelegateMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUtd`: UniffiCallbackInterfaceUnableToDecryptDelegateMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceUnableToDecryptDelegate(`onUtd`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceUnableToDecryptDelegate) {
        `onUtd` = other.`onUtd`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("onUpdate", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceVerificationStateListener(
    @JvmField internal var `onUpdate`: UniffiCallbackInterfaceVerificationStateListenerMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `onUpdate`: UniffiCallbackInterfaceVerificationStateListenerMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceVerificationStateListener(`onUpdate`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceVerificationStateListener) {
        `onUpdate` = other.`onUpdate`
        `uniffiFree` = other.`uniffiFree`
    }

}
@Structure.FieldOrder("acquireCapabilities", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceWidgetCapabilitiesProvider(
    @JvmField internal var `acquireCapabilities`: UniffiCallbackInterfaceWidgetCapabilitiesProviderMethod0? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `acquireCapabilities`: UniffiCallbackInterfaceWidgetCapabilitiesProviderMethod0? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ): UniffiVTableCallbackInterfaceWidgetCapabilitiesProvider(`acquireCapabilities`,`uniffiFree`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceWidgetCapabilitiesProvider) {
        `acquireCapabilities` = other.`acquireCapabilities`
        `uniffiFree` = other.`uniffiFree`
    }

}





















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































// A JNA Library to expose the extern-C FFI definitions.
// This is an implementation detail which will be called internally by the public API.

internal interface UniffiLib : Library {
    companion object {
        internal val INSTANCE: UniffiLib by lazy {
            loadIndirect<UniffiLib>(componentName = "matrix_sdk_ffi")
            .also { lib: UniffiLib ->
                uniffiCheckContractApiVersion(lib)
                uniffiCheckApiChecksums(lib)
                uniffiCallbackInterfaceAccountDataListener.register(lib)
                uniffiCallbackInterfaceBackupStateListener.register(lib)
                uniffiCallbackInterfaceBackupSteadyStateListener.register(lib)
                uniffiCallbackInterfaceCallDeclineListener.register(lib)
                uniffiCallbackInterfaceClientDelegate.register(lib)
                uniffiCallbackInterfaceClientSessionDelegate.register(lib)
                uniffiCallbackInterfaceEnableRecoveryProgressListener.register(lib)
                uniffiCallbackInterfaceGeneratedQrLoginProgressListener.register(lib)
                uniffiCallbackInterfaceIdentityStatusChangeListener.register(lib)
                uniffiCallbackInterfaceIgnoredUsersListener.register(lib)
                uniffiCallbackInterfaceKnockRequestsListener.register(lib)
                uniffiCallbackInterfaceLiveLocationShareListener.register(lib)
                uniffiCallbackInterfaceMediaPreviewConfigListener.register(lib)
                uniffiCallbackInterfaceNotificationSettingsDelegate.register(lib)
                uniffiCallbackInterfacePaginationStatusListener.register(lib)
                uniffiCallbackInterfaceProgressWatcher.register(lib)
                uniffiCallbackInterfaceQrLoginProgressListener.register(lib)
                uniffiCallbackInterfaceRecoveryStateListener.register(lib)
                uniffiCallbackInterfaceRoomAccountDataListener.register(lib)
                uniffiCallbackInterfaceRoomDirectorySearchEntriesListener.register(lib)
                uniffiCallbackInterfaceRoomInfoListener.register(lib)
                uniffiCallbackInterfaceRoomListEntriesListener.register(lib)
                uniffiCallbackInterfaceRoomListLoadingStateListener.register(lib)
                uniffiCallbackInterfaceRoomListServiceStateListener.register(lib)
                uniffiCallbackInterfaceRoomListServiceSyncIndicatorListener.register(lib)
                uniffiCallbackInterfaceSendQueueListener.register(lib)
                uniffiCallbackInterfaceSendQueueRoomErrorListener.register(lib)
                uniffiCallbackInterfaceSendQueueRoomUpdateListener.register(lib)
                uniffiCallbackInterfaceSessionVerificationControllerDelegate.register(lib)
                uniffiCallbackInterfaceSpaceRoomListEntriesListener.register(lib)
                uniffiCallbackInterfaceSpaceRoomListPaginationStateListener.register(lib)
                uniffiCallbackInterfaceSpaceRoomListSpaceListener.register(lib)
                uniffiCallbackInterfaceSpaceServiceJoinedSpacesListener.register(lib)
                uniffiCallbackInterfaceSyncServiceStateObserver.register(lib)
                uniffiCallbackInterfaceTimelineListener.register(lib)
                uniffiCallbackInterfaceTypingNotificationsListener.register(lib)
                uniffiCallbackInterfaceUnableToDecryptDelegate.register(lib)
                uniffiCallbackInterfaceVerificationStateListener.register(lib)
                uniffiCallbackInterfaceWidgetCapabilitiesProvider.register(lib)
                }
        }
        
        // The Cleaner for the whole library
        internal val CLEANER: UniffiCleaner by lazy {
            UniffiCleaner.create()
        }
    }

    fun uniffi_matrix_sdk_ffi_fn_clone_roommessageeventcontentwithoutrelation(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_roommessageeventcontentwithoutrelation(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_roommessageeventcontentwithoutrelation_with_mentions(`ptr`: Pointer,`mentions`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_clone_checkcodesender(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_checkcodesender(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_checkcodesender_send(`ptr`: Pointer,`code`: Byte,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_clone_client(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_client(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_client_abort_oidc_auth(`ptr`: Pointer,`authorizationData`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_account_data(`ptr`: Pointer,`eventType`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_account_url(`ptr`: Pointer,`action`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_add_recent_emoji(`ptr`: Pointer,`emoji`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_available_sliding_sync_versions(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_avatar_url(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_await_room_remote_echo(`ptr`: Pointer,`roomId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_cached_avatar_url(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_can_deactivate_account(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_client_clear_caches(`ptr`: Pointer,`syncService`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_create_room(`ptr`: Pointer,`request`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_custom_login_with_jwt(`ptr`: Pointer,`jwt`: RustBuffer.ByValue,`initialDeviceName`: RustBuffer.ByValue,`deviceId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_deactivate_account(`ptr`: Pointer,`authData`: RustBuffer.ByValue,`eraseData`: Byte,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_delete_pusher(`ptr`: Pointer,`identifiers`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_device_id(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_client_display_name(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_enable_all_send_queues(`ptr`: Pointer,`enable`: Byte,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_enable_send_queue_upload_progress(`ptr`: Pointer,`enable`: Byte,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_client_encryption(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_client_fetch_media_preview_config(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_get_dm_room(`ptr`: Pointer,`userId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_client_get_invite_avatars_display_policy(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_get_max_media_upload_size(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_get_media_content(`ptr`: Pointer,`mediaSource`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_get_media_file(`ptr`: Pointer,`mediaSource`: Pointer,`filename`: RustBuffer.ByValue,`mimeType`: RustBuffer.ByValue,`useCache`: Byte,`tempDir`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_get_media_preview_display_policy(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_get_media_thumbnail(`ptr`: Pointer,`mediaSource`: Pointer,`width`: Long,`height`: Long,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_get_notification_settings(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_get_profile(`ptr`: Pointer,`userId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_get_recent_emojis(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_get_recently_visited_rooms(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_get_room(`ptr`: Pointer,`roomId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_client_get_room_preview_from_room_alias(`ptr`: Pointer,`roomAlias`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_get_room_preview_from_room_id(`ptr`: Pointer,`roomId`: RustBuffer.ByValue,`viaServers`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_get_session_verification_controller(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_get_url(`ptr`: Pointer,`url`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_homeserver(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_client_homeserver_login_details(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_ignore_user(`ptr`: Pointer,`userId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_ignored_users(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_is_livekit_rtc_supported(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_is_report_room_api_supported(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_is_room_alias_available(`ptr`: Pointer,`alias`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_join_room_by_id(`ptr`: Pointer,`roomId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_join_room_by_id_or_alias(`ptr`: Pointer,`roomIdOrAlias`: RustBuffer.ByValue,`serverNames`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_knock(`ptr`: Pointer,`roomIdOrAlias`: RustBuffer.ByValue,`reason`: RustBuffer.ByValue,`serverNames`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_login(`ptr`: Pointer,`username`: RustBuffer.ByValue,`password`: RustBuffer.ByValue,`initialDeviceName`: RustBuffer.ByValue,`deviceId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_login_with_email(`ptr`: Pointer,`email`: RustBuffer.ByValue,`password`: RustBuffer.ByValue,`initialDeviceName`: RustBuffer.ByValue,`deviceId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_login_with_oidc_callback(`ptr`: Pointer,`callbackUrl`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_login_with_qr_code(`ptr`: Pointer,`oidcConfiguration`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_client_logout(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_notification_client(`ptr`: Pointer,`processSetup`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_observe_account_data_event(`ptr`: Pointer,`eventType`: RustBuffer.ByValue,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_client_observe_room_account_data_event(`ptr`: Pointer,`roomId`: RustBuffer.ByValue,`eventType`: RustBuffer.ByValue,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_client_remove_avatar(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_reset_server_info(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_resolve_room_alias(`ptr`: Pointer,`roomAlias`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_restore_session(`ptr`: Pointer,`session`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_restore_session_with(`ptr`: Pointer,`session`: RustBuffer.ByValue,`roomLoadSettings`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_room_alias_exists(`ptr`: Pointer,`roomAlias`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_room_directory_search(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_client_rooms(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_client_search_users(`ptr`: Pointer,`searchTerm`: RustBuffer.ByValue,`limit`: Long,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_server(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_client_server_vendor_info(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_session(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_client_set_account_data(`ptr`: Pointer,`eventType`: RustBuffer.ByValue,`content`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_set_delegate(`ptr`: Pointer,`delegate`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_client_set_display_name(`ptr`: Pointer,`name`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_set_invite_avatars_display_policy(`ptr`: Pointer,`policy`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_set_media_preview_display_policy(`ptr`: Pointer,`policy`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_set_media_retention_policy(`ptr`: Pointer,`policy`: RustBufferMediaRetentionPolicy.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_set_pusher(`ptr`: Pointer,`identifiers`: RustBuffer.ByValue,`kind`: RustBuffer.ByValue,`appDisplayName`: RustBuffer.ByValue,`deviceDisplayName`: RustBuffer.ByValue,`profileTag`: RustBuffer.ByValue,`lang`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_set_utd_delegate(`ptr`: Pointer,`utdDelegate`: Long,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_sliding_sync_version(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_client_space_service(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_client_start_sso_login(`ptr`: Pointer,`redirectUrl`: RustBuffer.ByValue,`idpId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_ignored_users(`ptr`: Pointer,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_media_preview_config(`ptr`: Pointer,`listener`: Long,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_room_info(`ptr`: Pointer,`roomId`: RustBuffer.ByValue,`listener`: Long,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_send_queue_status(`ptr`: Pointer,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_send_queue_updates(`ptr`: Pointer,`listener`: Long,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_sync_service(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_client_track_recently_visited_room(`ptr`: Pointer,`room`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_unignore_user(`ptr`: Pointer,`userId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_upload_avatar(`ptr`: Pointer,`mimeType`: RustBuffer.ByValue,`data`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_upload_media(`ptr`: Pointer,`mimeType`: RustBuffer.ByValue,`data`: RustBuffer.ByValue,`progressWatcher`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_url_for_oidc(`ptr`: Pointer,`oidcConfiguration`: RustBuffer.ByValue,`prompt`: RustBuffer.ByValue,`loginHint`: RustBuffer.ByValue,`deviceId`: RustBuffer.ByValue,`additionalScopes`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_client_user_id(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_client_user_id_server_name(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_clone_clientbuilder(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_clientbuilder(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_constructor_clientbuilder_new(uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_add_root_certificates(`ptr`: Pointer,`certificates`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_auto_enable_backups(`ptr`: Pointer,`autoEnableBackups`: Byte,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_auto_enable_cross_signing(`ptr`: Pointer,`autoEnableCrossSigning`: Byte,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_backup_download_strategy(`ptr`: Pointer,`backupDownloadStrategy`: RustBufferBackupDownloadStrategy.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_build(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_cross_process_store_locks_holder_name(`ptr`: Pointer,`holderName`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_decryption_settings(`ptr`: Pointer,`decryptionSettings`: RustBufferDecryptionSettings.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_automatic_token_refresh(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_built_in_root_certificates(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_ssl_verification(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_enable_oidc_refresh_lock(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_enable_share_history_on_invite(`ptr`: Pointer,`enableShareHistoryOnInvite`: Byte,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_homeserver_url(`ptr`: Pointer,`url`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_proxy(`ptr`: Pointer,`url`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_request_config(`ptr`: Pointer,`config`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_room_key_recipient_strategy(`ptr`: Pointer,`strategy`: RustBufferCollectStrategy.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_name(`ptr`: Pointer,`serverName`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_name_or_homeserver_url(`ptr`: Pointer,`serverNameOrUrl`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_cache_size(`ptr`: Pointer,`cacheSize`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_journal_size_limit(`ptr`: Pointer,`limit`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_passphrase(`ptr`: Pointer,`passphrase`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_paths(`ptr`: Pointer,`dataPath`: RustBuffer.ByValue,`cachePath`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_pool_max_size(`ptr`: Pointer,`poolMaxSize`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_set_session_delegate(`ptr`: Pointer,`sessionDelegate`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_sliding_sync_version_builder(`ptr`: Pointer,`versionBuilder`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_system_is_memory_constrained(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_threads_enabled(`ptr`: Pointer,`enabled`: Byte,`threadSubscriptions`: Byte,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_user_agent(`ptr`: Pointer,`userAgent`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_clientbuilder_username(`ptr`: Pointer,`username`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_clone_encryption(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_encryption(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_encryption_backup_exists_on_server(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_encryption_backup_state(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_encryption_backup_state_listener(`ptr`: Pointer,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_encryption_curve25519_key(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_encryption_disable_recovery(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_encryption_ed25519_key(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_encryption_enable_backups(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_encryption_enable_recovery(`ptr`: Pointer,`waitForBackupsToUpload`: Byte,`passphrase`: RustBuffer.ByValue,`progressListener`: Long,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_encryption_has_devices_to_verify_against(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_encryption_is_last_device(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_encryption_recover(`ptr`: Pointer,`recoveryKey`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_encryption_recover_and_reset(`ptr`: Pointer,`oldRecoveryKey`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_encryption_recovery_state(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_encryption_recovery_state_listener(`ptr`: Pointer,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_encryption_reset_identity(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_encryption_reset_recovery_key(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_encryption_user_identity(`ptr`: Pointer,`userId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_encryption_verification_state(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_encryption_verification_state_listener(`ptr`: Pointer,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_encryption_wait_for_backup_upload_steady_state(`ptr`: Pointer,`progressListener`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_encryption_wait_for_e2ee_initialization_tasks(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_clone_homeserverlogindetails(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_homeserverlogindetails(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_sliding_sync_version(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supported_oidc_prompts(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_oidc_login(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_password_login(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_sso_login(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_url(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_clone_identityresethandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_identityresethandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_identityresethandle_auth_type(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_identityresethandle_cancel(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_identityresethandle_reset(`ptr`: Pointer,`auth`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_clone_inreplytodetails(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_inreplytodetails(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_inreplytodetails_event(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_inreplytodetails_event_id(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_clone_knockrequestactions(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_knockrequestactions(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_accept(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_decline(`ptr`: Pointer,`reason`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_decline_and_ban(`ptr`: Pointer,`reason`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_mark_as_seen(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_clone_lazytimelineitemprovider(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_lazytimelineitemprovider(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_contains_only_emojis(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_debug_info(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_get_send_handle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_get_shields(`ptr`: Pointer,`strict`: Byte,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_clone_leavespacehandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_leavespacehandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_leavespacehandle_leave(`ptr`: Pointer,`roomIds`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_leavespacehandle_rooms(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_clone_loginwithqrcodehandler(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_loginwithqrcodehandler(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_loginwithqrcodehandler_generate(`ptr`: Pointer,`progressListener`: Long,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_loginwithqrcodehandler_scan(`ptr`: Pointer,`qrCodeData`: Pointer,`progressListener`: Long,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_clone_mediafilehandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_mediafilehandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_mediafilehandle_path(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_mediafilehandle_persist(`ptr`: Pointer,`path`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_clone_mediasource(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_mediasource(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_constructor_mediasource_from_json(`json`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_constructor_mediasource_from_url(`url`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_mediasource_to_json(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_mediasource_url(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_clone_notificationclient(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_notificationclient(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_notificationclient_get_notification(`ptr`: Pointer,`roomId`: RustBuffer.ByValue,`eventId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_notificationclient_get_notifications(`ptr`: Pointer,`requests`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_notificationclient_get_room(`ptr`: Pointer,`roomId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_clone_notificationsettings(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_notificationsettings(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_notificationsettings_can_homeserver_push_encrypted_event_to_device(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_notificationsettings_can_push_encrypted_event_to_device(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_notificationsettings_contains_keywords_rules(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_default_room_notification_mode(`ptr`: Pointer,`isEncrypted`: Byte,`isOneToOne`: Byte,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_raw_push_rules(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_room_notification_settings(`ptr`: Pointer,`roomId`: RustBuffer.ByValue,`isEncrypted`: Byte,`isOneToOne`: Byte,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_rooms_with_user_defined_rules(`ptr`: Pointer,`enabled`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_user_defined_room_notification_mode(`ptr`: Pointer,`roomId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_call_enabled(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_invite_for_me_enabled(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_room_mention_enabled(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_user_mention_enabled(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_notificationsettings_restore_default_room_notification_mode(`ptr`: Pointer,`roomId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_call_enabled(`ptr`: Pointer,`enabled`: Byte,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_custom_push_rule(`ptr`: Pointer,`ruleId`: RustBuffer.ByValue,`ruleKind`: RustBuffer.ByValue,`actions`: RustBuffer.ByValue,`conditions`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_default_room_notification_mode(`ptr`: Pointer,`isEncrypted`: Byte,`isOneToOne`: Byte,`mode`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_delegate(`ptr`: Pointer,`delegate`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_invite_for_me_enabled(`ptr`: Pointer,`enabled`: Byte,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_room_mention_enabled(`ptr`: Pointer,`enabled`: Byte,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_room_notification_mode(`ptr`: Pointer,`roomId`: RustBuffer.ByValue,`mode`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_user_mention_enabled(`ptr`: Pointer,`enabled`: Byte,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_notificationsettings_unmute_room(`ptr`: Pointer,`roomId`: RustBuffer.ByValue,`isEncrypted`: Byte,`isOneToOne`: Byte,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_clone_qrcodedata(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_qrcodedata(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_constructor_qrcodedata_from_bytes(`bytes`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_qrcodedata_server_name(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_clone_room(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_room(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_room_active_members_count(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_active_room_call_participants(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_room_alternative_aliases(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_room_apply_power_level_changes(`ptr`: Pointer,`changes`: RustBufferRoomPowerLevelChanges.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_avatar_url(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_room_ban_user(`ptr`: Pointer,`userId`: RustBuffer.ByValue,`reason`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_canonical_alias(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_room_clear_composer_draft(`ptr`: Pointer,`threadRoot`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_clear_event_cache_storage(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_decline_call(`ptr`: Pointer,`rtcNotificationEventId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_discard_room_key(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_display_name(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_room_edit(`ptr`: Pointer,`eventId`: RustBuffer.ByValue,`newContent`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_enable_encryption(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_enable_send_queue(`ptr`: Pointer,`enable`: Byte,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_room_encryption_state(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBufferEncryptionState.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_room_fetch_thread_subscription(`ptr`: Pointer,`threadRootEventId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_forget(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_get_power_levels(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_get_room_visibility(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_has_active_room_call(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_room_heroes(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_room_id(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_room_ignore_device_trust_and_resend(`ptr`: Pointer,`devices`: RustBuffer.ByValue,`sendHandle`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_ignore_user(`ptr`: Pointer,`userId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_invite_user_by_id(`ptr`: Pointer,`userId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_invited_members_count(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_inviter(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_is_direct(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_is_encrypted(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_is_public(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_room_is_send_queue_enabled(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_room_is_space(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_room_join(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_joined_members_count(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_kick_user(`ptr`: Pointer,`userId`: RustBuffer.ByValue,`reason`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_latest_encryption_state(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_latest_event(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_leave(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_load_composer_draft(`ptr`: Pointer,`threadRoot`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_load_or_fetch_event(`ptr`: Pointer,`eventId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_mark_as_fully_read_unchecked(`ptr`: Pointer,`eventId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_mark_as_read(`ptr`: Pointer,`receiptType`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_matrix_to_event_permalink(`ptr`: Pointer,`eventId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_matrix_to_permalink(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_member(`ptr`: Pointer,`userId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_member_avatar_url(`ptr`: Pointer,`userId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_member_display_name(`ptr`: Pointer,`userId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_member_with_sender_info(`ptr`: Pointer,`userId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_members(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_members_no_sync(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_membership(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_room_new_latest_event(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_own_user_id(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_room_predecessor_room(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_room_preview_room(`ptr`: Pointer,`via`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_publish_room_alias_in_room_directory(`ptr`: Pointer,`alias`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_raw_name(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_room_redact(`ptr`: Pointer,`eventId`: RustBuffer.ByValue,`reason`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_remove_avatar(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_remove_room_alias_from_room_directory(`ptr`: Pointer,`alias`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_report_content(`ptr`: Pointer,`eventId`: RustBuffer.ByValue,`score`: RustBuffer.ByValue,`reason`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_report_room(`ptr`: Pointer,`reason`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_reset_power_levels(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_room_events_debug_string(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_room_info(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_save_composer_draft(`ptr`: Pointer,`draft`: RustBuffer.ByValue,`threadRoot`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_send_live_location(`ptr`: Pointer,`geoUri`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_send_raw(`ptr`: Pointer,`eventType`: RustBuffer.ByValue,`content`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_set_is_favourite(`ptr`: Pointer,`isFavourite`: Byte,`tagOrder`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_set_is_low_priority(`ptr`: Pointer,`isLowPriority`: Byte,`tagOrder`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_set_name(`ptr`: Pointer,`name`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_set_thread_subscription(`ptr`: Pointer,`threadRootEventId`: RustBuffer.ByValue,`subscribed`: Byte,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_set_topic(`ptr`: Pointer,`topic`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_set_unread_flag(`ptr`: Pointer,`newValue`: Byte,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_start_live_location_share(`ptr`: Pointer,`durationMillis`: Long,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_stop_live_location_share(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_call_decline_events(`ptr`: Pointer,`rtcNotificationEventId`: RustBuffer.ByValue,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_identity_status_changes(`ptr`: Pointer,`listener`: Long,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_knock_requests(`ptr`: Pointer,`listener`: Long,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_live_location_shares(`ptr`: Pointer,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_room_info_updates(`ptr`: Pointer,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_send_queue_updates(`ptr`: Pointer,`listener`: Long,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_typing_notifications(`ptr`: Pointer,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_room_successor_room(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_room_suggested_role_for_user(`ptr`: Pointer,`userId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_timeline(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_timeline_with_configuration(`ptr`: Pointer,`configuration`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_topic(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_room_typing_notice(`ptr`: Pointer,`isTyping`: Byte,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_unban_user(`ptr`: Pointer,`userId`: RustBuffer.ByValue,`reason`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_update_canonical_alias(`ptr`: Pointer,`alias`: RustBuffer.ByValue,`altAliases`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_update_history_visibility(`ptr`: Pointer,`visibility`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_update_join_rules(`ptr`: Pointer,`newRule`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_update_power_levels_for_users(`ptr`: Pointer,`updates`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_update_room_visibility(`ptr`: Pointer,`visibility`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_upload_avatar(`ptr`: Pointer,`mimeType`: RustBuffer.ByValue,`data`: RustBuffer.ByValue,`mediaInfo`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_room_withdraw_verification_and_resend(`ptr`: Pointer,`userIds`: RustBuffer.ByValue,`sendHandle`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_clone_roomdirectorysearch(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_roomdirectorysearch(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_is_at_last_page(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_loaded_pages(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_next_page(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_results(`ptr`: Pointer,`listener`: Long,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_search(`ptr`: Pointer,`filter`: RustBuffer.ByValue,`batchSize`: Int,`viaServerName`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_clone_roomlist(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_roomlist(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_roomlist_entries_with_dynamic_adapters(`ptr`: Pointer,`pageSize`: Int,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_roomlist_entries_with_dynamic_adapters_with(`ptr`: Pointer,`pageSize`: Int,`enableLatestEventSorter`: Byte,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_roomlist_loading_state(`ptr`: Pointer,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_roomlist_room(`ptr`: Pointer,`roomId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_clone_roomlistdynamicentriescontroller(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_roomlistdynamicentriescontroller(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_add_one_page(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_reset_to_one_page(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_set_filter(`ptr`: Pointer,`kind`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_clone_roomlistentrieswithdynamicadaptersresult(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_roomlistentrieswithdynamicadaptersresult(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_roomlistentrieswithdynamicadaptersresult_controller(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_roomlistentrieswithdynamicadaptersresult_entries_stream(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_clone_roomlistservice(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_roomlistservice(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_roomlistservice_all_rooms(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_roomlistservice_room(`ptr`: Pointer,`roomId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_roomlistservice_state(`ptr`: Pointer,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_roomlistservice_subscribe_to_rooms(`ptr`: Pointer,`roomIds`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_roomlistservice_sync_indicator(`ptr`: Pointer,`delayBeforeShowingInMs`: Int,`delayBeforeHidingInMs`: Int,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_clone_roommembersiterator(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_roommembersiterator(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_roommembersiterator_len(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Int
    fun uniffi_matrix_sdk_ffi_fn_method_roommembersiterator_next_chunk(`ptr`: Pointer,`chunkSize`: Int,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_clone_roompowerlevels(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_roompowerlevels(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_ban(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_invite(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_kick(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_pin_unpin(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_redact_other(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_redact_own(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_send_message(`ptr`: Pointer,`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_send_state(`ptr`: Pointer,`stateEvent`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_trigger_room_notification(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_ban(`ptr`: Pointer,`userId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_invite(`ptr`: Pointer,`userId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_kick(`ptr`: Pointer,`userId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_pin_unpin(`ptr`: Pointer,`userId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_redact_other(`ptr`: Pointer,`userId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_redact_own(`ptr`: Pointer,`userId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_send_message(`ptr`: Pointer,`userId`: RustBuffer.ByValue,`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_send_state(`ptr`: Pointer,`userId`: RustBuffer.ByValue,`stateEvent`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_trigger_room_notification(`ptr`: Pointer,`userId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_user_power_levels(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_values(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_clone_roompreview(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_roompreview(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_roompreview_forget(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_roompreview_info(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_roompreview_inviter(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_roompreview_leave(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_roompreview_own_membership_details(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_clone_sendattachmentjoinhandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_sendattachmentjoinhandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_sendattachmentjoinhandle_cancel(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_sendattachmentjoinhandle_join(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_clone_sendgalleryjoinhandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_sendgalleryjoinhandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_sendgalleryjoinhandle_cancel(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_sendgalleryjoinhandle_join(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_clone_sendhandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_sendhandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_sendhandle_abort(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_sendhandle_try_resend(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_clone_sessionverificationcontroller(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_sessionverificationcontroller(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_accept_verification_request(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_acknowledge_verification_request(`ptr`: Pointer,`senderId`: RustBuffer.ByValue,`flowId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_approve_verification(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_cancel_verification(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_decline_verification(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_request_device_verification(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_request_user_verification(`ptr`: Pointer,`userId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_set_delegate(`ptr`: Pointer,`delegate`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_start_sas_verification(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_clone_sessionverificationemoji(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_sessionverificationemoji(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_description(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_symbol(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_clone_spaceroomlist(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_spaceroomlist(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_paginate(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_pagination_state(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBufferSpaceRoomListPaginationState.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_rooms(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_space(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_subscribe_to_pagination_state_updates(`ptr`: Pointer,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_subscribe_to_room_update(`ptr`: Pointer,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_subscribe_to_space_updates(`ptr`: Pointer,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_clone_spaceservice(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_spaceservice(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_spaceservice_joined_spaces(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_spaceservice_leave_space(`ptr`: Pointer,`spaceId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_spaceservice_space_room_list(`ptr`: Pointer,`spaceId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_spaceservice_subscribe_to_joined_spaces(`ptr`: Pointer,`listener`: Long,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_clone_span(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_span(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_constructor_span_current(uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_constructor_span_new(`file`: RustBuffer.ByValue,`line`: RustBuffer.ByValue,`level`: RustBuffer.ByValue,`target`: RustBuffer.ByValue,`name`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_span_enter(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_span_exit(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_span_is_none(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_clone_ssohandler(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_ssohandler(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_ssohandler_finish(`ptr`: Pointer,`callbackUrl`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_ssohandler_url(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_clone_syncservice(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_syncservice(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_syncservice_expire_sessions(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_syncservice_room_list_service(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_syncservice_start(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_syncservice_state(`ptr`: Pointer,`listener`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_syncservice_stop(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_clone_syncservicebuilder(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_syncservicebuilder(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_finish(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_cross_process_lock(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_offline_mode(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_share_pos(`ptr`: Pointer,`enable`: Byte,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_clone_taskhandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_taskhandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_taskhandle_cancel(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_taskhandle_is_finished(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_clone_threadsummary(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_threadsummary(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_threadsummary_latest_event(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_threadsummary_num_replies(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_clone_timeline(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_timeline(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_add_listener(`ptr`: Pointer,`listener`: Long,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_create_message_content(`ptr`: Pointer,`msgType`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_create_poll(`ptr`: Pointer,`question`: RustBuffer.ByValue,`answers`: RustBuffer.ByValue,`maxSelections`: Byte,`pollKind`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_edit(`ptr`: Pointer,`eventOrTransactionId`: RustBuffer.ByValue,`newContent`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_end_poll(`ptr`: Pointer,`pollStartEventId`: RustBuffer.ByValue,`text`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_fetch_details_for_event(`ptr`: Pointer,`eventId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_fetch_members(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_get_event_timeline_item_by_event_id(`ptr`: Pointer,`eventId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_latest_event_id(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_load_reply_details(`ptr`: Pointer,`eventIdStr`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_mark_as_read(`ptr`: Pointer,`receiptType`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_paginate_backwards(`ptr`: Pointer,`numEvents`: Short,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_paginate_forwards(`ptr`: Pointer,`numEvents`: Short,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_pin_event(`ptr`: Pointer,`eventId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_redact_event(`ptr`: Pointer,`eventOrTransactionId`: RustBuffer.ByValue,`reason`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_retry_decryption(`ptr`: Pointer,`sessionIds`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_send(`ptr`: Pointer,`msg`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_send_audio(`ptr`: Pointer,`params`: RustBuffer.ByValue,`audioInfo`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_send_file(`ptr`: Pointer,`params`: RustBuffer.ByValue,`fileInfo`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_send_gallery(`ptr`: Pointer,`params`: RustBuffer.ByValue,`itemInfos`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_send_image(`ptr`: Pointer,`params`: RustBuffer.ByValue,`thumbnailSource`: RustBuffer.ByValue,`imageInfo`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_send_location(`ptr`: Pointer,`body`: RustBuffer.ByValue,`geoUri`: RustBuffer.ByValue,`description`: RustBuffer.ByValue,`zoomLevel`: RustBuffer.ByValue,`assetType`: RustBuffer.ByValue,`repliedToEventId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_send_poll_response(`ptr`: Pointer,`pollStartEventId`: RustBuffer.ByValue,`answers`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_send_read_receipt(`ptr`: Pointer,`receiptType`: RustBuffer.ByValue,`eventId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_send_reply(`ptr`: Pointer,`msg`: Pointer,`eventId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_send_video(`ptr`: Pointer,`params`: RustBuffer.ByValue,`thumbnailSource`: RustBuffer.ByValue,`videoInfo`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_send_voice_message(`ptr`: Pointer,`params`: RustBuffer.ByValue,`audioInfo`: RustBuffer.ByValue,`waveform`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_subscribe_to_back_pagination_status(`ptr`: Pointer,`listener`: Long,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_toggle_reaction(`ptr`: Pointer,`itemId`: RustBuffer.ByValue,`key`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_timeline_unpin_event(`ptr`: Pointer,`eventId`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_clone_timelineevent(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_timelineevent(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_timelineevent_event_id(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_timelineevent_event_type(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_timelineevent_sender_id(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_timelineevent_thread_root_event_id(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_timelineevent_timestamp(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_clone_timelineeventtypefilter(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_timelineeventtypefilter(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_constructor_timelineeventtypefilter_exclude(`eventTypes`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_constructor_timelineeventtypefilter_include(`eventTypes`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_clone_timelineitem(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_timelineitem(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_event(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_virtual(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_timelineitem_fmt_debug(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_timelineitem_unique_id(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_clone_unreadnotificationscount(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_unreadnotificationscount(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_has_notifications(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_highlight_count(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Int
    fun uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_notification_count(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Int
    fun uniffi_matrix_sdk_ffi_fn_clone_useridentity(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_useridentity(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_useridentity_has_verification_violation(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_useridentity_is_verified(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_useridentity_master_key(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_method_useridentity_pin(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_useridentity_was_previously_verified(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_method_useridentity_withdraw_verification(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_clone_widgetdriver(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_widgetdriver(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_widgetdriver_run(`ptr`: Pointer,`room`: Pointer,`capabilitiesProvider`: Long,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_clone_widgetdriverhandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_free_widgetdriverhandle(`ptr`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_method_widgetdriverhandle_recv(`ptr`: Pointer,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_method_widgetdriverhandle_send(`ptr`: Pointer,`msg`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_accountdatalistener(`vtable`: UniffiVTableCallbackInterfaceAccountDataListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_backupstatelistener(`vtable`: UniffiVTableCallbackInterfaceBackupStateListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_backupsteadystatelistener(`vtable`: UniffiVTableCallbackInterfaceBackupSteadyStateListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_calldeclinelistener(`vtable`: UniffiVTableCallbackInterfaceCallDeclineListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_clientdelegate(`vtable`: UniffiVTableCallbackInterfaceClientDelegate,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_clientsessiondelegate(`vtable`: UniffiVTableCallbackInterfaceClientSessionDelegate,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_enablerecoveryprogresslistener(`vtable`: UniffiVTableCallbackInterfaceEnableRecoveryProgressListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_generatedqrloginprogresslistener(`vtable`: UniffiVTableCallbackInterfaceGeneratedQrLoginProgressListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_identitystatuschangelistener(`vtable`: UniffiVTableCallbackInterfaceIdentityStatusChangeListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_ignoreduserslistener(`vtable`: UniffiVTableCallbackInterfaceIgnoredUsersListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_knockrequestslistener(`vtable`: UniffiVTableCallbackInterfaceKnockRequestsListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_livelocationsharelistener(`vtable`: UniffiVTableCallbackInterfaceLiveLocationShareListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_mediapreviewconfiglistener(`vtable`: UniffiVTableCallbackInterfaceMediaPreviewConfigListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_notificationsettingsdelegate(`vtable`: UniffiVTableCallbackInterfaceNotificationSettingsDelegate,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_paginationstatuslistener(`vtable`: UniffiVTableCallbackInterfacePaginationStatusListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_progresswatcher(`vtable`: UniffiVTableCallbackInterfaceProgressWatcher,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_qrloginprogresslistener(`vtable`: UniffiVTableCallbackInterfaceQrLoginProgressListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_recoverystatelistener(`vtable`: UniffiVTableCallbackInterfaceRecoveryStateListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomaccountdatalistener(`vtable`: UniffiVTableCallbackInterfaceRoomAccountDataListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomdirectorysearchentrieslistener(`vtable`: UniffiVTableCallbackInterfaceRoomDirectorySearchEntriesListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roominfolistener(`vtable`: UniffiVTableCallbackInterfaceRoomInfoListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistentrieslistener(`vtable`: UniffiVTableCallbackInterfaceRoomListEntriesListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistloadingstatelistener(`vtable`: UniffiVTableCallbackInterfaceRoomListLoadingStateListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistservicestatelistener(`vtable`: UniffiVTableCallbackInterfaceRoomListServiceStateListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistservicesyncindicatorlistener(`vtable`: UniffiVTableCallbackInterfaceRoomListServiceSyncIndicatorListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sendqueuelistener(`vtable`: UniffiVTableCallbackInterfaceSendQueueListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sendqueueroomerrorlistener(`vtable`: UniffiVTableCallbackInterfaceSendQueueRoomErrorListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sendqueueroomupdatelistener(`vtable`: UniffiVTableCallbackInterfaceSendQueueRoomUpdateListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sessionverificationcontrollerdelegate(`vtable`: UniffiVTableCallbackInterfaceSessionVerificationControllerDelegate,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_spaceroomlistentrieslistener(`vtable`: UniffiVTableCallbackInterfaceSpaceRoomListEntriesListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_spaceroomlistpaginationstatelistener(`vtable`: UniffiVTableCallbackInterfaceSpaceRoomListPaginationStateListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_spaceroomlistspacelistener(`vtable`: UniffiVTableCallbackInterfaceSpaceRoomListSpaceListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_spaceservicejoinedspaceslistener(`vtable`: UniffiVTableCallbackInterfaceSpaceServiceJoinedSpacesListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_syncservicestateobserver(`vtable`: UniffiVTableCallbackInterfaceSyncServiceStateObserver,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_timelinelistener(`vtable`: UniffiVTableCallbackInterfaceTimelineListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_typingnotificationslistener(`vtable`: UniffiVTableCallbackInterfaceTypingNotificationsListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_unabletodecryptdelegate(`vtable`: UniffiVTableCallbackInterfaceUnableToDecryptDelegate,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_verificationstatelistener(`vtable`: UniffiVTableCallbackInterfaceVerificationStateListener,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_init_callback_vtable_widgetcapabilitiesprovider(`vtable`: UniffiVTableCallbackInterfaceWidgetCapabilitiesProvider,
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_func_content_without_relation_from_message(`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_func_create_caption_edit(`caption`: RustBuffer.ByValue,`formattedCaption`: RustBuffer.ByValue,`mentions`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_func_enable_sentry_logging(`enabled`: Byte,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_func_gen_transaction_id(uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_func_generate_webview_url(`widgetSettings`: RustBuffer.ByValue,`room`: Pointer,`props`: RustBuffer.ByValue,
    ): Long
    fun uniffi_matrix_sdk_ffi_fn_func_get_element_call_required_permissions(`ownUserId`: RustBuffer.ByValue,`ownDeviceId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_func_init_platform(`config`: RustBuffer.ByValue,`useLightweightTokioRuntime`: Byte,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_func_is_room_alias_format_valid(`alias`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_matrix_sdk_ffi_fn_func_log_event(`file`: RustBuffer.ByValue,`line`: RustBuffer.ByValue,`level`: RustBuffer.ByValue,`target`: RustBuffer.ByValue,`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_func_make_widget_driver(`settings`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_func_matrix_to_room_alias_permalink(`roomAlias`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_func_matrix_to_user_permalink(`userId`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_html(`body`: RustBuffer.ByValue,`htmlBody`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_html_as_emote(`body`: RustBuffer.ByValue,`htmlBody`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_markdown(`md`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_markdown_as_emote(`md`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_func_message_event_content_new(`msgtype`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun uniffi_matrix_sdk_ffi_fn_func_new_virtual_element_call_widget(`props`: RustBufferVirtualElementCallWidgetProperties.ByValue,`config`: RustBufferVirtualElementCallWidgetConfig.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_func_parse_matrix_entity_from(`uri`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_func_reload_tracing_file_writer(`configuration`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_fn_func_room_alias_name_from_room_display_name(`roomName`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_func_sdk_git_sha(uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_func_suggested_power_level_for_role(`role`: RustBufferRoomMemberRole.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_matrix_sdk_ffi_fn_func_suggested_role_for_power_level(`powerLevel`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBufferRoomMemberRole.ByValue
    fun ffi_matrix_sdk_ffi_rustbuffer_alloc(`size`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun ffi_matrix_sdk_ffi_rustbuffer_from_bytes(`bytes`: ForeignBytes.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun ffi_matrix_sdk_ffi_rustbuffer_free(`buf`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun ffi_matrix_sdk_ffi_rustbuffer_reserve(`buf`: RustBuffer.ByValue,`additional`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun ffi_matrix_sdk_ffi_rust_future_poll_u8(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_cancel_u8(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_free_u8(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_complete_u8(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun ffi_matrix_sdk_ffi_rust_future_poll_i8(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_cancel_i8(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_free_i8(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_complete_i8(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun ffi_matrix_sdk_ffi_rust_future_poll_u16(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_cancel_u16(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_free_u16(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_complete_u16(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Short
    fun ffi_matrix_sdk_ffi_rust_future_poll_i16(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_cancel_i16(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_free_i16(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_complete_i16(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Short
    fun ffi_matrix_sdk_ffi_rust_future_poll_u32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_cancel_u32(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_free_u32(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_complete_u32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Int
    fun ffi_matrix_sdk_ffi_rust_future_poll_i32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_cancel_i32(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_free_i32(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_complete_i32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Int
    fun ffi_matrix_sdk_ffi_rust_future_poll_u64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_cancel_u64(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_free_u64(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_complete_u64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Long
    fun ffi_matrix_sdk_ffi_rust_future_poll_i64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_cancel_i64(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_free_i64(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_complete_i64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Long
    fun ffi_matrix_sdk_ffi_rust_future_poll_f32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_cancel_f32(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_free_f32(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_complete_f32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Float
    fun ffi_matrix_sdk_ffi_rust_future_poll_f64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_cancel_f64(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_free_f64(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_complete_f64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Double
    fun ffi_matrix_sdk_ffi_rust_future_poll_pointer(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_cancel_pointer(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_free_pointer(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_complete_pointer(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun ffi_matrix_sdk_ffi_rust_future_poll_void(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_cancel_void(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_free_void(`handle`: Long,
    ): Unit
    fun ffi_matrix_sdk_ffi_rust_future_complete_void(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_matrix_sdk_ffi_checksum_func_content_without_relation_from_message(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_func_create_caption_edit(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_func_enable_sentry_logging(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_func_gen_transaction_id(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_func_generate_webview_url(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_func_get_element_call_required_permissions(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_func_init_platform(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_func_is_room_alias_format_valid(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_func_log_event(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_func_make_widget_driver(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_func_matrix_to_room_alias_permalink(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_func_matrix_to_user_permalink(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html_as_emote(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown_as_emote(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_func_message_event_content_new(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_func_new_virtual_element_call_widget(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_func_parse_matrix_entity_from(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_func_reload_tracing_file_writer(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_func_room_alias_name_from_room_display_name(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_func_sdk_git_sha(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_func_suggested_power_level_for_role(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_func_suggested_role_for_power_level(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roommessageeventcontentwithoutrelation_with_mentions(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_checkcodesender_send(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_abort_oidc_auth(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_account_data(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_account_url(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_add_recent_emoji(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_available_sliding_sync_versions(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_avatar_url(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_await_room_remote_echo(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_cached_avatar_url(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_can_deactivate_account(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_clear_caches(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_create_room(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_custom_login_with_jwt(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_deactivate_account(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_delete_pusher(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_device_id(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_display_name(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_enable_all_send_queues(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_enable_send_queue_upload_progress(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_encryption(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_fetch_media_preview_config(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_get_dm_room(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_get_invite_avatars_display_policy(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_get_max_media_upload_size(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_get_media_content(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_get_media_file(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_get_media_preview_display_policy(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_get_media_thumbnail(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_get_notification_settings(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_get_profile(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_get_recent_emojis(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_get_recently_visited_rooms(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_get_room(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_alias(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_id(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_get_session_verification_controller(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_get_url(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_homeserver(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_homeserver_login_details(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_ignore_user(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_ignored_users(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_is_livekit_rtc_supported(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_is_report_room_api_supported(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_is_room_alias_available(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id_or_alias(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_knock(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_login(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_login_with_email(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_login_with_oidc_callback(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_login_with_qr_code(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_logout(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_notification_client(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_observe_account_data_event(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_observe_room_account_data_event(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_remove_avatar(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_reset_server_info(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_resolve_room_alias(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_restore_session(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_restore_session_with(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_room_alias_exists(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_room_directory_search(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_rooms(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_search_users(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_server(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_server_vendor_info(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_session(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_set_account_data(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_set_delegate(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_set_display_name(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_set_invite_avatars_display_policy(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_set_media_preview_display_policy(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_set_media_retention_policy(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_set_pusher(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_set_utd_delegate(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_sliding_sync_version(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_space_service(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_start_sso_login(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_ignored_users(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_media_preview_config(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_room_info(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_send_queue_status(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_send_queue_updates(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_sync_service(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_track_recently_visited_room(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_unignore_user(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_upload_avatar(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_upload_media(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_url_for_oidc(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_user_id(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_client_user_id_server_name(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_add_root_certificates(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_backups(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_cross_signing(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_backup_download_strategy(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_cross_process_store_locks_holder_name(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_decryption_settings(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_automatic_token_refresh(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_built_in_root_certificates(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_ssl_verification(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_enable_oidc_refresh_lock(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_enable_share_history_on_invite(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_homeserver_url(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_proxy(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_request_config(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_room_key_recipient_strategy(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name_or_homeserver_url(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_cache_size(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_journal_size_limit(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_passphrase(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_paths(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_pool_max_size(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_set_session_delegate(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_sliding_sync_version_builder(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_system_is_memory_constrained(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_threads_enabled(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_user_agent(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_username(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_exists_on_server(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state_listener(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_encryption_curve25519_key(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_encryption_disable_recovery(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_encryption_ed25519_key(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_backups(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_recovery(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_encryption_has_devices_to_verify_against(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_encryption_is_last_device(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_encryption_recover(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_encryption_recover_and_reset(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state_listener(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_identity(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_recovery_key(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_encryption_user_identity(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state_listener(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_backup_upload_steady_state(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_e2ee_initialization_tasks(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_sliding_sync_version(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supported_oidc_prompts(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_oidc_login(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_password_login(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_sso_login(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_url(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_auth_type(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_cancel(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_reset(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event_id(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_accept(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline_and_ban(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_mark_as_seen(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_contains_only_emojis(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_debug_info(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_send_handle(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_shields(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_leavespacehandle_leave(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_leavespacehandle_rooms(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_loginwithqrcodehandler_generate(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_loginwithqrcodehandler_scan(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_path(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_persist(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_mediasource_to_json(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_mediasource_url(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_notification(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_notifications(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_room(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_homeserver_push_encrypted_event_to_device(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_push_encrypted_event_to_device(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_contains_keywords_rules(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_default_room_notification_mode(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_raw_push_rules(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_room_notification_settings(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_rooms_with_user_defined_rules(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_user_defined_room_notification_mode(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_call_enabled(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_invite_for_me_enabled(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_room_mention_enabled(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_user_mention_enabled(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_restore_default_room_notification_mode(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_call_enabled(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_custom_push_rule(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_default_room_notification_mode(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_delegate(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_invite_for_me_enabled(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_mention_enabled(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_notification_mode(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_user_mention_enabled(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_unmute_room(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_qrcodedata_server_name(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_active_members_count(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_active_room_call_participants(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_alternative_aliases(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_apply_power_level_changes(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_avatar_url(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_ban_user(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_canonical_alias(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_clear_composer_draft(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_clear_event_cache_storage(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_decline_call(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_discard_room_key(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_display_name(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_edit(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_enable_encryption(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_enable_send_queue(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_encryption_state(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_fetch_thread_subscription(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_forget(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_get_power_levels(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_get_room_visibility(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_has_active_room_call(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_heroes(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_id(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_ignore_device_trust_and_resend(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_ignore_user(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_invite_user_by_id(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_invited_members_count(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_inviter(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_is_direct(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_is_encrypted(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_is_public(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_is_send_queue_enabled(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_is_space(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_join(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_joined_members_count(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_kick_user(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_latest_encryption_state(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_latest_event(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_leave(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_load_composer_draft(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_load_or_fetch_event(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_mark_as_fully_read_unchecked(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_mark_as_read(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_event_permalink(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_permalink(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_member(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_member_avatar_url(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_member_display_name(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_member_with_sender_info(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_members(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_members_no_sync(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_membership(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_new_latest_event(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_own_user_id(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_predecessor_room(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_preview_room(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_publish_room_alias_in_room_directory(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_raw_name(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_redact(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_remove_avatar(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_remove_room_alias_from_room_directory(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_report_content(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_report_room(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_reset_power_levels(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_room_events_debug_string(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_room_info(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_save_composer_draft(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_send_live_location(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_send_raw(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_set_is_favourite(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_set_is_low_priority(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_set_name(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_set_thread_subscription(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_set_topic(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_set_unread_flag(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_start_live_location_share(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_stop_live_location_share(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_call_decline_events(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_identity_status_changes(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_knock_requests(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_live_location_shares(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_room_info_updates(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_send_queue_updates(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_typing_notifications(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_successor_room(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_suggested_role_for_user(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_timeline(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_timeline_with_configuration(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_topic(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_typing_notice(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_unban_user(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_update_canonical_alias(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_update_history_visibility(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_update_join_rules(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_update_power_levels_for_users(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_update_room_visibility(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_upload_avatar(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_room_withdraw_verification_and_resend(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_is_at_last_page(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_loaded_pages(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_next_page(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_results(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_search(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roomlist_entries_with_dynamic_adapters(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roomlist_entries_with_dynamic_adapters_with(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roomlist_loading_state(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roomlist_room(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_add_one_page(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_reset_to_one_page(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_set_filter(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_controller(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_entries_stream(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_all_rooms(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_room(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_state(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_subscribe_to_rooms(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_sync_indicator(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_len(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_next_chunk(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_ban(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_invite(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_kick(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_pin_unpin(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_redact_other(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_redact_own(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_send_message(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_send_state(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_trigger_room_notification(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_ban(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_invite(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_kick(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_pin_unpin(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_redact_other(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_redact_own(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_send_message(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_send_state(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_trigger_room_notification(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_user_power_levels(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_values(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roompreview_forget(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roompreview_info(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roompreview_inviter(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roompreview_leave(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roompreview_own_membership_details(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_cancel(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_join(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sendgalleryjoinhandle_cancel(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sendgalleryjoinhandle_join(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sendhandle_abort(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sendhandle_try_resend(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_accept_verification_request(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_acknowledge_verification_request(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_approve_verification(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_cancel_verification(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_decline_verification(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_device_verification(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_user_verification(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_set_delegate(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_start_sas_verification(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_description(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_symbol(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_paginate(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_pagination_state(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_rooms(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_space(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_subscribe_to_pagination_state_updates(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_subscribe_to_room_update(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_subscribe_to_space_updates(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_spaceservice_joined_spaces(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_spaceservice_leave_space(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_spaceservice_space_room_list(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_spaceservice_subscribe_to_joined_spaces(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_span_enter(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_span_exit(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_span_is_none(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_ssohandler_finish(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_ssohandler_url(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_syncservice_expire_sessions(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_syncservice_room_list_service(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_syncservice_start(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_syncservice_state(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_syncservice_stop(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_finish(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_cross_process_lock(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_offline_mode(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_share_pos(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_taskhandle_cancel(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_taskhandle_is_finished(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_threadsummary_latest_event(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_threadsummary_num_replies(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_add_listener(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_create_message_content(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_create_poll(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_edit(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_end_poll(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_details_for_event(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_members(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_get_event_timeline_item_by_event_id(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_latest_event_id(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_load_reply_details(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_mark_as_read(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_backwards(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_forwards(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_pin_event(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_redact_event(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_retry_decryption(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_send(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_send_audio(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_send_file(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_send_gallery(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_send_image(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_send_location(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_send_poll_response(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_send_read_receipt(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_send_reply(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_send_video(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_send_voice_message(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_subscribe_to_back_pagination_status(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_toggle_reaction(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timeline_unpin_event(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_id(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_type(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timelineevent_sender_id(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timelineevent_thread_root_event_id(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timelineevent_timestamp(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_event(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_virtual(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timelineitem_fmt_debug(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timelineitem_unique_id(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_has_notifications(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_highlight_count(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_notification_count(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_useridentity_has_verification_violation(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_useridentity_is_verified(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_useridentity_master_key(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_useridentity_pin(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_useridentity_was_previously_verified(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_useridentity_withdraw_verification(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_widgetdriver_run(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_recv(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_send(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_constructor_clientbuilder_new(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_json(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_url(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_constructor_qrcodedata_from_bytes(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_constructor_span_current(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_constructor_span_new(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_exclude(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_include(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_accountdatalistener_on_change(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_backupstatelistener_on_update(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_backupsteadystatelistener_on_update(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_calldeclinelistener_call(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientdelegate_did_receive_auth_error(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_retrieve_session_from_keychain(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_save_session_in_keychain(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_enablerecoveryprogresslistener_on_update(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_generatedqrloginprogresslistener_on_update(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_identitystatuschangelistener_call(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_ignoreduserslistener_call(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_knockrequestslistener_call(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_livelocationsharelistener_call(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_mediapreviewconfiglistener_on_change(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_notificationsettingsdelegate_settings_did_change(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_paginationstatuslistener_on_update(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_progresswatcher_transmission_progress(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_qrloginprogresslistener_on_update(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_recoverystatelistener_on_update(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roomaccountdatalistener_on_change(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearchentrieslistener_on_update(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roominfolistener_call(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieslistener_on_update(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roomlistloadingstatelistener_on_update(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roomlistservicestatelistener_on_update(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_roomlistservicesyncindicatorlistener_on_update(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sendqueuelistener_on_update(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sendqueueroomerrorlistener_on_error(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sendqueueroomupdatelistener_on_update(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_request(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_accept_verification_request(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_start_sas_verification(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_data(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_fail(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_cancel(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_finish(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_spaceroomlistentrieslistener_on_update(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_spaceroomlistpaginationstatelistener_on_update(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_spaceroomlistspacelistener_on_update(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_spaceservicejoinedspaceslistener_on_update(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_syncservicestateobserver_on_update(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_timelinelistener_on_update(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_typingnotificationslistener_call(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_unabletodecryptdelegate_on_utd(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_verificationstatelistener_on_update(
    ): Short
    fun uniffi_matrix_sdk_ffi_checksum_method_widgetcapabilitiesprovider_acquire_capabilities(
    ): Short
    fun ffi_matrix_sdk_ffi_uniffi_contract_version(
    ): Int
    
}

private fun uniffiCheckContractApiVersion(lib: UniffiLib) {
    // Get the bindings contract version from our ComponentInterface
    val bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    val scaffolding_contract_version = lib.ffi_matrix_sdk_ffi_uniffi_contract_version()
    if (bindings_contract_version != scaffolding_contract_version) {
        throw RuntimeException("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    }
}

@Suppress("UNUSED_PARAMETER")
private fun uniffiCheckApiChecksums(lib: UniffiLib) {
    if (lib.uniffi_matrix_sdk_ffi_checksum_func_content_without_relation_from_message() != 1366.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_func_create_caption_edit() != 33992.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_func_enable_sentry_logging() != 53125.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_func_gen_transaction_id() != 15808.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_func_generate_webview_url() != 48529.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_func_get_element_call_required_permissions() != 30181.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_func_init_platform() != 11113.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_func_is_room_alias_format_valid() != 54845.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_func_log_event() != 55646.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_func_make_widget_driver() != 34206.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_func_matrix_to_room_alias_permalink() != 13776.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_func_matrix_to_user_permalink() != 46473.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html() != 37203.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html_as_emote() != 8938.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown() != 58385.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown_as_emote() != 20152.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_func_message_event_content_new() != 57839.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_func_new_virtual_element_call_widget() != 7233.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_func_parse_matrix_entity_from() != 49710.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_func_reload_tracing_file_writer() != 1447.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_func_room_alias_name_from_room_display_name() != 65010.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_func_sdk_git_sha() != 4038.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_func_suggested_power_level_for_role() != 29703.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_func_suggested_role_for_power_level() != 13856.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roommessageeventcontentwithoutrelation_with_mentions() != 8867.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_checkcodesender_send() != 50179.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_abort_oidc_auth() != 53440.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_account_data() != 50433.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_account_url() != 42373.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_add_recent_emoji() != 29688.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_available_sliding_sync_versions() != 35296.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_avatar_url() != 27867.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_await_room_remote_echo() != 18126.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_cached_avatar_url() != 50226.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_can_deactivate_account() != 39890.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_clear_caches() != 55711.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_create_room() != 52700.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_custom_login_with_jwt() != 19710.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_deactivate_account() != 20658.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_delete_pusher() != 45990.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_device_id() != 44340.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_display_name() != 56259.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_enable_all_send_queues() != 30834.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_enable_send_queue_upload_progress() != 10688.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_encryption() != 9657.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_fetch_media_preview_config() != 15595.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_get_dm_room() != 5137.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_get_invite_avatars_display_policy() != 46953.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_get_max_media_upload_size() != 12661.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_get_media_content() != 40308.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_get_media_file() != 20094.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_get_media_preview_display_policy() != 19264.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_get_media_thumbnail() != 52601.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_get_notification_settings() != 49769.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_get_profile() != 60062.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_get_recent_emojis() != 43545.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_get_recently_visited_rooms() != 22399.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_get_room() != 30376.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_alias() != 7674.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_id() != 36348.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_get_session_verification_controller() != 55934.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_get_url() != 32541.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_homeserver() != 26427.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_homeserver_login_details() != 63487.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_ignore_user() != 14588.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_ignored_users() != 49620.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_is_livekit_rtc_supported() != 34863.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_is_report_room_api_supported() != 17934.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_is_room_alias_available() != 23322.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id() != 64032.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id_or_alias() != 18521.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_knock() != 48652.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_login() != 33276.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_login_with_email() != 11789.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_login_with_oidc_callback() != 32591.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_login_with_qr_code() != 2487.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_logout() != 42911.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_notification_client() != 37308.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_observe_account_data_event() != 13906.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_observe_room_account_data_event() != 15699.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_remove_avatar() != 29033.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_reset_server_info() != 16333.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_resolve_room_alias() != 3551.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_restore_session() != 56125.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_restore_session_with() != 20927.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_room_alias_exists() != 20359.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_room_directory_search() != 39855.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_rooms() != 29558.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_search_users() != 42927.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_server() != 63276.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_server_vendor_info() != 51933.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_session() != 8085.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_set_account_data() != 18256.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_set_delegate() != 46437.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_set_display_name() != 15292.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_set_invite_avatars_display_policy() != 48457.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_set_media_preview_display_policy() != 24080.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_set_media_retention_policy() != 2414.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_set_pusher() != 41975.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_set_utd_delegate() != 37720.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_sliding_sync_version() != 4957.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_space_service() != 31959.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_start_sso_login() != 34571.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_ignored_users() != 23285.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_media_preview_config() != 47047.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_room_info() != 41103.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_send_queue_status() != 57403.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_send_queue_updates() != 33603.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_sync_service() != 52812.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_track_recently_visited_room() != 56986.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_unignore_user() != 8489.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_upload_avatar() != 64486.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_upload_media() != 51195.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_url_for_oidc() != 19369.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_user_id() != 40531.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_client_user_id_server_name() != 57725.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_add_root_certificates() != 14763.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_backups() != 44502.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_cross_signing() != 37167.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_backup_download_strategy() != 11959.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build() != 56018.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_cross_process_store_locks_holder_name() != 46627.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_decryption_settings() != 34715.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_automatic_token_refresh() != 43839.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_built_in_root_certificates() != 47525.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_ssl_verification() != 2334.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_enable_oidc_refresh_lock() != 42214.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_enable_share_history_on_invite() != 3856.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_homeserver_url() != 28347.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_proxy() != 5659.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_request_config() != 58783.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_room_key_recipient_strategy() != 41183.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name() != 29096.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name_or_homeserver_url() != 30022.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_cache_size() != 32604.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_journal_size_limit() != 21378.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_passphrase() != 55403.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_paths() != 54230.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_pool_max_size() != 6011.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_set_session_delegate() != 8576.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_sliding_sync_version_builder() != 39381.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_system_is_memory_constrained() != 6898.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_threads_enabled() != 23935.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_user_agent() != 13719.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_username() != 45302.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_exists_on_server() != 45490.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state() != 51049.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state_listener() != 14246.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_encryption_curve25519_key() != 58425.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_encryption_disable_recovery() != 18699.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_encryption_ed25519_key() != 11864.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_backups() != 55446.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_recovery() != 64351.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_encryption_has_devices_to_verify_against() != 7561.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_encryption_is_last_device() != 27955.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_encryption_recover() != 33712.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_encryption_recover_and_reset() != 12902.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state() != 54051.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state_listener() != 36612.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_identity() != 13780.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_recovery_key() != 20380.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_encryption_user_identity() != 20644.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state() != 29114.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state_listener() != 59806.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_backup_upload_steady_state() != 37503.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_e2ee_initialization_tasks() != 41585.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_sliding_sync_version() != 36573.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supported_oidc_prompts() != 63396.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_oidc_login() != 46090.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_password_login() != 33501.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_sso_login() != 37773.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_url() != 61326.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_auth_type() != 43501.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_cancel() != 57622.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_reset() != 11997.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event() != 36106.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event_id() != 5876.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_accept() != 25656.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline() != 65054.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline_and_ban() != 26242.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_mark_as_seen() != 36036.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_contains_only_emojis() != 5211.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_debug_info() != 55450.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_send_handle() != 46057.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_shields() != 12518.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_leavespacehandle_leave() != 54036.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_leavespacehandle_rooms() != 50920.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_loginwithqrcodehandler_generate() != 7203.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_loginwithqrcodehandler_scan() != 26140.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_path() != 16357.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_persist() != 12883.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_mediasource_to_json() != 23306.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_mediasource_url() != 62692.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_notification() != 52873.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_notifications() != 64372.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_room() != 26581.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_homeserver_push_encrypted_event_to_device() != 37323.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_push_encrypted_event_to_device() != 21251.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_contains_keywords_rules() != 60025.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_default_room_notification_mode() != 36211.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_raw_push_rules() != 17884.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_room_notification_settings() != 55295.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_rooms_with_user_defined_rules() != 19849.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_user_defined_room_notification_mode() != 18228.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_call_enabled() != 12210.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_invite_for_me_enabled() != 533.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_room_mention_enabled() != 13304.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_user_mention_enabled() != 49857.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_restore_default_room_notification_mode() != 35399.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_call_enabled() != 16823.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_custom_push_rule() != 465.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_default_room_notification_mode() != 9426.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_delegate() != 57636.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_invite_for_me_enabled() != 11988.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_mention_enabled() != 31650.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_notification_mode() != 4135.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_user_mention_enabled() != 56594.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_unmute_room() != 47580.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_qrcodedata_server_name() != 30173.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_active_members_count() != 61905.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_active_room_call_participants() != 41533.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_alternative_aliases() != 28555.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_apply_power_level_changes() != 44206.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_avatar_url() != 34637.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_ban_user() != 35046.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_canonical_alias() != 19786.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_clear_composer_draft() != 59182.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_clear_event_cache_storage() != 13838.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_decline_call() != 36115.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_discard_room_key() != 18081.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_display_name() != 64194.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_edit() != 61956.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_enable_encryption() != 14669.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_enable_send_queue() != 23914.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_encryption_state() != 9101.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_fetch_thread_subscription() != 51696.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_forget() != 37840.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_get_power_levels() != 47640.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_get_room_visibility() != 412.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_has_active_room_call() != 33588.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_heroes() != 22313.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_id() != 61990.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_ignore_device_trust_and_resend() != 39984.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_ignore_user() != 62239.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_invite_user_by_id() != 41133.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_invited_members_count() != 1023.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_inviter() != 18103.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_is_direct() != 10462.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_is_encrypted() != 63995.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_is_public() != 57746.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_is_send_queue_enabled() != 36591.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_is_space() != 16919.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_join() != 9240.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_joined_members_count() != 55835.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_kick_user() != 28600.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_latest_encryption_state() != 16843.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_latest_event() != 39083.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_leave() != 63688.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_load_composer_draft() != 62856.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_load_or_fetch_event() != 12703.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_mark_as_fully_read_unchecked() != 24981.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_mark_as_read() != 57806.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_event_permalink() != 36705.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_permalink() != 47781.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_member() != 48980.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_member_avatar_url() != 29492.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_member_display_name() != 33206.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_member_with_sender_info() != 64964.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_members() != 42691.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_members_no_sync() != 3255.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_membership() != 45951.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_new_latest_event() != 11947.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_own_user_id() != 39510.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_predecessor_room() != 22093.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_preview_room() != 60431.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_publish_room_alias_in_room_directory() != 13924.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_raw_name() != 15453.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_redact() != 45810.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_remove_avatar() != 7230.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_remove_room_alias_from_room_directory() != 16926.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_report_content() != 16529.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_report_room() != 6449.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_reset_power_levels() != 5060.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_room_events_debug_string() != 37832.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_room_info() != 41146.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_save_composer_draft() != 27585.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_send_live_location() != 34248.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_send_raw() != 20486.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_set_is_favourite() != 64403.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_set_is_low_priority() != 48070.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_set_name() != 52127.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_set_thread_subscription() != 48337.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_set_topic() != 5576.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_set_unread_flag() != 2381.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_start_live_location_share() != 11488.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_stop_live_location_share() != 19983.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_call_decline_events() != 62256.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_identity_status_changes() != 8526.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_knock_requests() != 30649.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_live_location_shares() != 57037.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_room_info_updates() != 48209.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_send_queue_updates() != 17661.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_typing_notifications() != 38524.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_successor_room() != 27360.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_suggested_role_for_user() != 47787.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_timeline() != 51477.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_timeline_with_configuration() != 35159.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_topic() != 59745.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_typing_notice() != 28642.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_unban_user() != 1803.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_update_canonical_alias() != 25065.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_update_history_visibility() != 26248.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_update_join_rules() != 49303.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_update_power_levels_for_users() != 52057.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_update_room_visibility() != 64724.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_upload_avatar() != 19069.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_room_withdraw_verification_and_resend() != 33485.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_is_at_last_page() != 34221.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_loaded_pages() != 2923.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_next_page() != 29305.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_results() != 30207.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_search() != 24438.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roomlist_entries_with_dynamic_adapters() != 36097.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roomlist_entries_with_dynamic_adapters_with() != 21746.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roomlist_loading_state() != 21585.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roomlist_room() != 62491.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_add_one_page() != 47748.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_reset_to_one_page() != 61352.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_set_filter() != 61202.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_controller() != 36258.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_entries_stream() != 56632.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_all_rooms() != 49704.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_room() != 60695.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_state() != 64650.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_subscribe_to_rooms() != 5528.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_sync_indicator() != 16821.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_len() != 39835.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_next_chunk() != 23186.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_ban() != 7183.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_invite() != 57708.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_kick() != 461.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_pin_unpin() != 52852.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_redact_other() != 60699.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_redact_own() != 32905.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_send_message() != 2424.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_send_state() != 33539.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_trigger_room_notification() != 64150.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_ban() != 57457.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_invite() != 41275.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_kick() != 51066.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_pin_unpin() != 4609.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_redact_other() != 52543.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_redact_own() != 2983.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_send_message() != 48291.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_send_state() != 14792.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_trigger_room_notification() != 26319.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_user_power_levels() != 16221.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_values() != 38774.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roompreview_forget() != 18179.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roompreview_info() != 50237.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roompreview_inviter() != 1297.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roompreview_leave() != 21886.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roompreview_own_membership_details() != 46321.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_cancel() != 62384.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_join() != 1903.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sendgalleryjoinhandle_cancel() != 7014.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sendgalleryjoinhandle_join() != 57901.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sendhandle_abort() != 11570.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sendhandle_try_resend() != 28691.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_accept_verification_request() != 53466.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_acknowledge_verification_request() != 37982.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_approve_verification() != 27140.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_cancel_verification() != 32994.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_decline_verification() != 64345.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_device_verification() != 4777.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_user_verification() != 26149.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_set_delegate() != 42324.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_start_sas_verification() != 16328.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_description() != 21346.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_symbol() != 46075.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_paginate() != 57707.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_pagination_state() != 33381.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_rooms() != 24664.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_space() != 25368.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_subscribe_to_pagination_state_updates() != 16775.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_subscribe_to_room_update() != 55793.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_subscribe_to_space_updates() != 26327.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_spaceservice_joined_spaces() != 54285.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_spaceservice_leave_space() != 7949.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_spaceservice_space_room_list() != 6768.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_spaceservice_subscribe_to_joined_spaces() != 10090.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_span_enter() != 8900.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_span_exit() != 47924.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_span_is_none() != 33327.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_ssohandler_finish() != 64706.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_ssohandler_url() != 10889.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_syncservice_expire_sessions() != 45579.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_syncservice_room_list_service() != 26426.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_syncservice_start() != 16010.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_syncservice_state() != 61806.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_syncservice_stop() != 42435.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_finish() != 22814.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_cross_process_lock() != 56326.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_offline_mode() != 16958.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_share_pos() != 18892.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_taskhandle_cancel() != 9124.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_taskhandle_is_finished() != 29008.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_threadsummary_latest_event() != 52917.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_threadsummary_num_replies() != 10634.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_add_listener() != 18746.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_create_message_content() != 21811.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_create_poll() != 37925.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_edit() != 42189.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_end_poll() != 32659.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_details_for_event() != 54068.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_members() != 37994.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_get_event_timeline_item_by_event_id() != 33999.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_latest_event_id() != 20608.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_load_reply_details() != 54225.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_mark_as_read() != 16621.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_backwards() != 36829.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_forwards() != 30268.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_pin_event() != 41687.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_redact_event() != 48707.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_retry_decryption() != 21112.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_send() != 9553.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_audio() != 36723.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_file() != 4740.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_gallery() != 61071.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_image() != 29043.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_location() != 39080.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_poll_response() != 7453.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_read_receipt() != 37532.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_reply() != 11149.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_video() != 52974.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_voice_message() != 41701.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_subscribe_to_back_pagination_status() != 46161.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_toggle_reaction() != 13555.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timeline_unpin_event() != 52414.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_id() != 11088.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_type() != 12922.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timelineevent_sender_id() != 18142.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timelineevent_thread_root_event_id() != 56465.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timelineevent_timestamp() != 50929.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_event() != 6106.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_virtual() != 50960.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timelineitem_fmt_debug() != 38094.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timelineitem_unique_id() != 39945.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_has_notifications() != 33024.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_highlight_count() != 35997.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_notification_count() != 35655.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_useridentity_has_verification_violation() != 2948.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_useridentity_is_verified() != 61954.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_useridentity_master_key() != 4041.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_useridentity_pin() != 62925.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_useridentity_was_previously_verified() != 41686.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_useridentity_withdraw_verification() != 3578.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_widgetdriver_run() != 7519.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_recv() != 2662.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_send() != 18689.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_constructor_clientbuilder_new() != 27991.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_json() != 10564.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_url() != 11983.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_constructor_qrcodedata_from_bytes() != 32675.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_constructor_span_current() != 53698.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_constructor_span_new() != 14105.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_exclude() != 53805.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_include() != 25498.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_accountdatalistener_on_change() != 16189.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_backupstatelistener_on_update() != 12849.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_backupsteadystatelistener_on_update() != 41052.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_calldeclinelistener_call() != 13016.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientdelegate_did_receive_auth_error() != 26350.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_retrieve_session_from_keychain() != 43954.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_save_session_in_keychain() != 53223.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_enablerecoveryprogresslistener_on_update() != 13538.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_generatedqrloginprogresslistener_on_update() != 28731.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_identitystatuschangelistener_call() != 57311.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_ignoreduserslistener_call() != 47519.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_knockrequestslistener_call() != 10077.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_livelocationsharelistener_call() != 34519.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_mediapreviewconfiglistener_on_change() != 14770.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_notificationsettingsdelegate_settings_did_change() != 51708.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_paginationstatuslistener_on_update() != 65318.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_progresswatcher_transmission_progress() != 41133.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_qrloginprogresslistener_on_update() != 9758.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_recoverystatelistener_on_update() != 64575.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roomaccountdatalistener_on_change() != 58105.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearchentrieslistener_on_update() != 41968.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roominfolistener_call() != 44934.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieslistener_on_update() != 12576.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roomlistloadingstatelistener_on_update() != 23169.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roomlistservicestatelistener_on_update() != 24823.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_roomlistservicesyncindicatorlistener_on_update() != 36937.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sendqueuelistener_on_update() != 24843.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sendqueueroomerrorlistener_on_error() != 38224.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sendqueueroomupdatelistener_on_update() != 11544.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_request() != 3417.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_accept_verification_request() != 3733.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_start_sas_verification() != 56833.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_data() != 30840.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_fail() != 32164.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_cancel() != 3367.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_finish() != 37905.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_spaceroomlistentrieslistener_on_update() != 31502.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_spaceroomlistpaginationstatelistener_on_update() != 11960.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_spaceroomlistspacelistener_on_update() != 39714.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_spaceservicejoinedspaceslistener_on_update() != 19262.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_syncservicestateobserver_on_update() != 62231.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_timelinelistener_on_update() != 53990.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_typingnotificationslistener_call() != 64299.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_unabletodecryptdelegate_on_utd() != 61791.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_verificationstatelistener_on_update() != 38998.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_matrix_sdk_ffi_checksum_method_widgetcapabilitiesprovider_acquire_capabilities() != 12846.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// Async support
// Async return type handlers

internal const val UNIFFI_RUST_FUTURE_POLL_READY = 0.toByte()
internal const val UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1.toByte()

internal val uniffiContinuationHandleMap = UniffiHandleMap<CancellableContinuation<Byte>>()

// FFI type for Rust future continuations
internal object uniffiRustFutureContinuationCallbackImpl: UniffiRustFutureContinuationCallback {
    override fun callback(data: Long, pollResult: Byte) {
        uniffiContinuationHandleMap.remove(data).resume(pollResult)
    }
}

internal suspend fun<T, F, E: kotlin.Exception> uniffiRustCallAsync(
    rustFuture: Long,
    pollFunc: (Long, UniffiRustFutureContinuationCallback, Long) -> Unit,
    completeFunc: (Long, UniffiRustCallStatus) -> F,
    freeFunc: (Long) -> Unit,
    liftFunc: (F) -> T,
    errorHandler: UniffiRustCallStatusErrorHandler<E>
): T {
    try {
        do {
            val pollResult = suspendCancellableCoroutine<Byte> { continuation ->
                pollFunc(
                    rustFuture,
                    uniffiRustFutureContinuationCallbackImpl,
                    uniffiContinuationHandleMap.insert(continuation)
                )
            }
        } while (pollResult != UNIFFI_RUST_FUTURE_POLL_READY);

        return liftFunc(
            uniffiRustCallWithError(errorHandler, { status -> completeFunc(rustFuture, status) })
        )
    } finally {
        freeFunc(rustFuture)
    }
}

// Public interface members begin here.


// Interface implemented by anything that can contain an object reference.
//
// Such types expose a `destroy()` method that must be called to cleanly
// dispose of the contained objects. Failure to call this method may result
// in memory leaks.
//
// The easiest way to ensure this method is called is to use the `.use`
// helper method to execute a block and destroy the object at the end.
interface Disposable {
    fun destroy()
    companion object {
        fun destroy(vararg args: Any?) {
            args.filterIsInstance<Disposable>()
                .forEach(Disposable::destroy)
        }
    }
}

inline fun <T : Disposable?, R> T.use(block: (T) -> R) =
    try {
        block(this)
    } finally {
        try {
            // N.B. our implementation is on the nullable type `Disposable?`.
            this?.destroy()
        } catch (e: Throwable) {
            // swallow
        }
    }

/** Used to instantiate an interface without an actual pointer, for fakes in tests, mostly. */
object NoPointer

public object FfiConverterUByte: FfiConverter<UByte, Byte> {
    override fun lift(value: Byte): UByte {
        return value.toUByte()
    }

    override fun read(buf: ByteBuffer): UByte {
        return lift(buf.get())
    }

    override fun lower(value: UByte): Byte {
        return value.toByte()
    }

    override fun allocationSize(value: UByte) = 1UL

    override fun write(value: UByte, buf: ByteBuffer) {
        buf.put(value.toByte())
    }
}

public object FfiConverterUShort: FfiConverter<UShort, Short> {
    override fun lift(value: Short): UShort {
        return value.toUShort()
    }

    override fun read(buf: ByteBuffer): UShort {
        return lift(buf.getShort())
    }

    override fun lower(value: UShort): Short {
        return value.toShort()
    }

    override fun allocationSize(value: UShort) = 2UL

    override fun write(value: UShort, buf: ByteBuffer) {
        buf.putShort(value.toShort())
    }
}

public object FfiConverterUInt: FfiConverter<UInt, Int> {
    override fun lift(value: Int): UInt {
        return value.toUInt()
    }

    override fun read(buf: ByteBuffer): UInt {
        return lift(buf.getInt())
    }

    override fun lower(value: UInt): Int {
        return value.toInt()
    }

    override fun allocationSize(value: UInt) = 4UL

    override fun write(value: UInt, buf: ByteBuffer) {
        buf.putInt(value.toInt())
    }
}

public object FfiConverterInt: FfiConverter<Int, Int> {
    override fun lift(value: Int): Int {
        return value
    }

    override fun read(buf: ByteBuffer): Int {
        return buf.getInt()
    }

    override fun lower(value: Int): Int {
        return value
    }

    override fun allocationSize(value: Int) = 4UL

    override fun write(value: Int, buf: ByteBuffer) {
        buf.putInt(value)
    }
}

public object FfiConverterULong: FfiConverter<ULong, Long> {
    override fun lift(value: Long): ULong {
        return value.toULong()
    }

    override fun read(buf: ByteBuffer): ULong {
        return lift(buf.getLong())
    }

    override fun lower(value: ULong): Long {
        return value.toLong()
    }

    override fun allocationSize(value: ULong) = 8UL

    override fun write(value: ULong, buf: ByteBuffer) {
        buf.putLong(value.toLong())
    }
}

public object FfiConverterLong: FfiConverter<Long, Long> {
    override fun lift(value: Long): Long {
        return value
    }

    override fun read(buf: ByteBuffer): Long {
        return buf.getLong()
    }

    override fun lower(value: Long): Long {
        return value
    }

    override fun allocationSize(value: Long) = 8UL

    override fun write(value: Long, buf: ByteBuffer) {
        buf.putLong(value)
    }
}

public object FfiConverterFloat: FfiConverter<Float, Float> {
    override fun lift(value: Float): Float {
        return value
    }

    override fun read(buf: ByteBuffer): Float {
        return buf.getFloat()
    }

    override fun lower(value: Float): Float {
        return value
    }

    override fun allocationSize(value: Float) = 4UL

    override fun write(value: Float, buf: ByteBuffer) {
        buf.putFloat(value)
    }
}

public object FfiConverterDouble: FfiConverter<Double, Double> {
    override fun lift(value: Double): Double {
        return value
    }

    override fun read(buf: ByteBuffer): Double {
        return buf.getDouble()
    }

    override fun lower(value: Double): Double {
        return value
    }

    override fun allocationSize(value: Double) = 8UL

    override fun write(value: Double, buf: ByteBuffer) {
        buf.putDouble(value)
    }
}

public object FfiConverterBoolean: FfiConverter<Boolean, Byte> {
    override fun lift(value: Byte): Boolean {
        return value.toInt() != 0
    }

    override fun read(buf: ByteBuffer): Boolean {
        return lift(buf.get())
    }

    override fun lower(value: Boolean): Byte {
        return if (value) 1.toByte() else 0.toByte()
    }

    override fun allocationSize(value: Boolean) = 1UL

    override fun write(value: Boolean, buf: ByteBuffer) {
        buf.put(lower(value))
    }
}

public object FfiConverterString: FfiConverter<String, RustBuffer.ByValue> {
    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    override fun lift(value: RustBuffer.ByValue): String {
        try {
            val byteArr = ByteArray(value.len.toInt())
            value.asByteBuffer()!!.get(byteArr)
            return byteArr.toString(Charsets.UTF_8)
        } finally {
            RustBuffer.free(value)
        }
    }

    override fun read(buf: ByteBuffer): String {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr.toString(Charsets.UTF_8)
    }

    fun toUtf8(value: String): ByteBuffer {
        // Make sure we don't have invalid UTF-16, check for lone surrogates.
        return Charsets.UTF_8.newEncoder().run {
            onMalformedInput(CodingErrorAction.REPORT)
            encode(CharBuffer.wrap(value))
        }
    }

    override fun lower(value: String): RustBuffer.ByValue {
        val byteBuf = toUtf8(value)
        // Ideally we'd pass these bytes to `ffi_bytebuffer_from_bytes`, but doing so would require us
        // to copy them into a JNA `Memory`. So we might as well directly copy them into a `RustBuffer`.
        val rbuf = RustBuffer.alloc(byteBuf.limit().toULong())
        rbuf.asByteBuffer()!!.put(byteBuf)
        return rbuf
    }

    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per UTF-16 code unit which will always be
    // enough.
    override fun allocationSize(value: String): ULong {
        val sizeForLength = 4UL
        val sizeForString = value.length.toULong() * 3UL
        return sizeForLength + sizeForString
    }

    override fun write(value: String, buf: ByteBuffer) {
        val byteBuf = toUtf8(value)
        buf.putInt(byteBuf.limit())
        buf.put(byteBuf)
    }
}

public object FfiConverterByteArray: FfiConverterRustBuffer<ByteArray> {
    override fun read(buf: ByteBuffer): ByteArray {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr
    }
    override fun allocationSize(value: ByteArray): ULong {
        return 4UL + value.size.toULong()
    }
    override fun write(value: ByteArray, buf: ByteBuffer) {
        buf.putInt(value.size)
        buf.put(value)
    }
}


public object FfiConverterDuration: FfiConverterRustBuffer<java.time.Duration> {
    override fun read(buf: ByteBuffer): java.time.Duration {
        // Type mismatch (should be u64) but we check for overflow/underflow below
        val seconds = buf.getLong()
        // Type mismatch (should be u32) but we check for overflow/underflow below
        val nanoseconds = buf.getInt().toLong()
        if (seconds < 0) {
            throw java.time.DateTimeException("Duration exceeds minimum or maximum value supported by uniffi")
        }
        if (nanoseconds < 0) {
            throw java.time.DateTimeException("Duration nanoseconds exceed minimum or maximum supported by uniffi")
        }
        return java.time.Duration.ofSeconds(seconds, nanoseconds)
    }

    // 8 bytes for seconds, 4 bytes for nanoseconds
    override fun allocationSize(value: java.time.Duration) = 12UL

    override fun write(value: java.time.Duration, buf: ByteBuffer) {
        if (value.seconds < 0) {
            // Rust does not support negative Durations
            throw IllegalArgumentException("Invalid duration, must be non-negative")
        }

        if (value.nano < 0) {
            // Java docs provide guarantee that nano will always be positive, so this should be impossible
            // See: https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html
            throw IllegalArgumentException("Invalid duration, nano value must be non-negative")
        }

        // Type mismatch (should be u64) but since Rust doesn't support negative durations we should be OK
        buf.putLong(value.seconds)
        // Type mismatch (should be u32) but since values will always be between 0 and 999,999,999 it should be OK
        buf.putInt(value.nano)
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


// The cleaner interface for Object finalization code to run.
// This is the entry point to any implementation that we're using.
//
// The cleaner registers objects and returns cleanables, so now we are
// defining a `UniffiCleaner` with a `UniffiClenaer.Cleanable` to abstract the
// different implmentations available at compile time.
interface UniffiCleaner {
    interface Cleanable {
        fun clean()
    }

    fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable

    companion object
}

// The fallback Jna cleaner, which is available for both Android, and the JVM.
private class UniffiJnaCleaner : UniffiCleaner {
    private val cleaner = com.sun.jna.internal.Cleaner.getCleaner()

    override fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable =
        UniffiJnaCleanable(cleaner.register(value, cleanUpTask))
}

private class UniffiJnaCleanable(
    private val cleanable: com.sun.jna.internal.Cleaner.Cleanable,
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}

// We decide at uniffi binding generation time whether we were
// using Android or not.
// There are further runtime checks to chose the correct implementation
// of the cleaner.


private fun UniffiCleaner.Companion.create(): UniffiCleaner =
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
        AndroidSystemCleaner()
    } else {
        UniffiJnaCleaner()
    }

// The SystemCleaner, available from API Level 33.
// Some API Level 33 OSes do not support using it, so we require API Level 34.
@RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
private class AndroidSystemCleaner : UniffiCleaner {
    val cleaner = android.system.SystemCleaner.cleaner()

    override fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable =
        AndroidSystemCleanable(cleaner.register(value, cleanUpTask))
}

@RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
private class AndroidSystemCleanable(
    private val cleanable: java.lang.ref.Cleaner.Cleanable,
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}
/**
 * Used to pass back the [`CheckCode`] entered by the user to verify that the
 * secure channel is indeed secure.
 */
public interface CheckCodeSenderInterface {
    
    /**
     * Send the [`CheckCode`].
     *
     * Calling this method more than once will result in an error.
     *
     * # Arguments
     *
     * * `check_code` - The check code in digits representation.
     */
    suspend fun `send`(`code`: kotlin.UByte)
    
    companion object
}

/**
 * Used to pass back the [`CheckCode`] entered by the user to verify that the
 * secure channel is indeed secure.
 */
open class CheckCodeSender: Disposable, AutoCloseable, CheckCodeSenderInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_checkcodesender(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_checkcodesender(pointer!!, status)
        }
    }

    
    /**
     * Send the [`CheckCode`].
     *
     * Calling this method more than once will result in an error.
     *
     * # Arguments
     *
     * * `check_code` - The check code in digits representation.
     */
    @Throws(HumanQrLoginException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `send`(`code`: kotlin.UByte) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_checkcodesender_send(
                thisPtr,
                FfiConverterUByte.lower(`code`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        HumanQrLoginException.ErrorHandler,
    )
    }

    

    
    
    companion object
    
}

public object FfiConverterTypeCheckCodeSender: FfiConverter<CheckCodeSender, Pointer> {

    override fun lower(value: CheckCodeSender): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): CheckCodeSender {
        return CheckCodeSender(value)
    }

    override fun read(buf: ByteBuffer): CheckCodeSender {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: CheckCodeSender) = 8UL

    override fun write(value: CheckCodeSender, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface ClientInterface {
    
    /**
     * Aborts an existing OIDC login operation that might have been cancelled,
     * failed etc.
     */
    suspend fun `abortOidcAuth`(`authorizationData`: OAuthAuthorizationData)
    
    /**
     * Get the content of the event of the given type out of the account data
     * store.
     *
     * It will be returned as a JSON string.
     */
    suspend fun `accountData`(`eventType`: kotlin.String): kotlin.String?
    
    suspend fun `accountUrl`(`action`: AccountManagementAction?): kotlin.String?
    
    /**
     * Adds a recently used emoji to the list and uploads the updated
     * `io.element.recent_emoji` content to the global account data.
     */
    suspend fun `addRecentEmoji`(`emoji`: kotlin.String)
    
    /**
     * Find all sliding sync versions that are available.
     *
     * Be careful: This method may hit the store and will send new requests for
     * each call. It can be costly to call it repeatedly.
     *
     * If `.well-known` or `/versions` is unreachable, it will simply move
     * potential sliding sync versions aside. No error will be reported.
     */
    suspend fun `availableSlidingSyncVersions`(): List<SlidingSyncVersion>
    
    /**
     * Sends a request to retrieve the avatar URL. Will fill the cache used by
     * [`Self::cached_avatar_url`] on success.
     */
    suspend fun `avatarUrl`(): kotlin.String?
    
    /**
     * Waits until an at least partially synced room is received, and returns
     * it.
     *
     * **Note: this function will loop endlessly until either it finds the room
     * or an externally set timeout happens.**
     */
    suspend fun `awaitRoomRemoteEcho`(`roomId`: kotlin.String): Room
    
    /**
     * Retrieves an avatar cached from a previous call to [`Self::avatar_url`].
     */
    suspend fun `cachedAvatarUrl`(): kotlin.String?
    
    /**
     * Lets the user know whether this is an `m.login.password` based
     * auth and if the account can actually be deactivated
     */
    fun `canDeactivateAccount`(): kotlin.Boolean
    
    /**
     * Clear all the non-critical caches for this Client instance.
     *
     * WARNING: This will clear all the caches, including the base store (state
     * store), so callers must make sure that the Client is at rest before
     * calling it.
     *
     * In particular, if a [`SyncService`] is running, it must be passed here
     * as a parameter, or stopped before calling this method. Ideally, the
     * send queues should have been disabled and must all be inactive (i.e.
     * not sending events); this method will disable them, but it might not
     * be enough if the queues are still processing events.
     *
     * After the method returns, the Client will be in an unstable
     * state, and it is required that the caller reinstantiates a new
     * Client instance, be it via dropping the previous and re-creating it,
     * restarting their application, or any other similar means.
     *
     * - This will get rid of the backing state store file, if provided.
     * - This will empty all the room's persisted event caches, so all rooms
     * will start as if they were empty.
     * - This will empty the media cache according to the current media
     * retention policy.
     */
    suspend fun `clearCaches`(`syncService`: SyncService?)
    
    suspend fun `createRoom`(`request`: CreateRoomParameters): kotlin.String
    
    /**
     * Login using JWT
     * This is an implementation of the custom_login https://docs.rs/matrix-sdk/latest/matrix_sdk/matrix_auth/struct.MatrixAuth.html#method.login_custom
     * For more information on logging in with JWT: https://element-hq.github.io/synapse/latest/jwt.html
     */
    suspend fun `customLoginWithJwt`(`jwt`: kotlin.String, `initialDeviceName`: kotlin.String?, `deviceId`: kotlin.String?)
    
    /**
     * Deactivate this account definitively.
     * Similarly to `encryption::reset_identity` this
     * will only work with password-based authentication (`m.login.password`)
     *
     * # Arguments
     *
     * * `auth_data` - This request uses the [User-Interactive Authentication
     * API][uiaa]. The first request needs to set this to `None` and will
     * always fail and the same request needs to be made but this time with
     * some `auth_data` provided.
     */
    suspend fun `deactivateAccount`(`authData`: AuthData?, `eraseData`: kotlin.Boolean)
    
    /**
     * Deletes a pusher of given pusher ids
     */
    suspend fun `deletePusher`(`identifiers`: PusherIdentifiers)
    
    fun `deviceId`(): kotlin.String
    
    suspend fun `displayName`(): kotlin.String
    
    /**
     * Enables or disables all the room send queues at once.
     *
     * When connectivity is lost on a device, it is recommended to disable the
     * room sending queues.
     *
     * This can be controlled for individual rooms, using
     * [`Room::enable_send_queue`].
     */
    suspend fun `enableAllSendQueues`(`enable`: kotlin.Boolean)
    
    /**
     * Enables or disables progress reporting for media uploads in the send
     * queue.
     */
    fun `enableSendQueueUploadProgress`(`enable`: kotlin.Boolean)
    
    fun `encryption`(): Encryption
    
    /**
     * Fetch the media preview configuration from the server.
     */
    suspend fun `fetchMediaPreviewConfig`(): MediaPreviewConfig?
    
    fun `getDmRoom`(`userId`: kotlin.String): Room?
    
    /**
     * Get the invite request avatars display policy
     * currently stored in the cache.
     */
    suspend fun `getInviteAvatarsDisplayPolicy`(): InviteAvatars?
    
    /**
     * Gets the `max_upload_size` value from the homeserver, which controls the
     * max size a media upload request can have.
     */
    suspend fun `getMaxMediaUploadSize`(): kotlin.ULong
    
    suspend fun `getMediaContent`(`mediaSource`: MediaSource): kotlin.ByteArray
    
    /**
     * Retrieves a media file from the media source
     *
     * Not available on Wasm platforms, due to lack of accessible file system.
     */
    suspend fun `getMediaFile`(`mediaSource`: MediaSource, `filename`: kotlin.String?, `mimeType`: kotlin.String, `useCache`: kotlin.Boolean, `tempDir`: kotlin.String?): MediaFileHandle
    
    /**
     * Get the media previews timeline display policy
     * currently stored in the cache.
     */
    suspend fun `getMediaPreviewDisplayPolicy`(): MediaPreviews?
    
    suspend fun `getMediaThumbnail`(`mediaSource`: MediaSource, `width`: kotlin.ULong, `height`: kotlin.ULong): kotlin.ByteArray
    
    suspend fun `getNotificationSettings`(): NotificationSettings
    
    suspend fun `getProfile`(`userId`: kotlin.String): UserProfile
    
    /**
     * Gets the list of recently used emojis from the
     * `io.element.recent_emoji` global account data.
     */
    suspend fun `getRecentEmojis`(): List<RecentEmoji>
    
    suspend fun `getRecentlyVisitedRooms`(): List<kotlin.String>
    
    /**
     * Get a room by its ID.
     *
     * # Arguments
     *
     * * `room_id` - The ID of the room to get.
     *
     * # Returns
     *
     * A `Result` containing an optional room, or a `ClientError`.
     * This method will not initialize the room's timeline or populate it with
     * events.
     */
    fun `getRoom`(`roomId`: kotlin.String): Room?
    
    /**
     * Given a room alias, get the preview of a room, to interact with it.
     */
    suspend fun `getRoomPreviewFromRoomAlias`(`roomAlias`: kotlin.String): RoomPreview
    
    /**
     * Given a room id, get the preview of a room, to interact with it.
     *
     * The list of `via_servers` must be a list of servers that know
     * about the room and can resolve it, and that may appear as a `via`
     * parameter in e.g. a permalink URL. This list can be empty.
     */
    suspend fun `getRoomPreviewFromRoomId`(`roomId`: kotlin.String, `viaServers`: List<kotlin.String>): RoomPreview
    
    suspend fun `getSessionVerificationController`(): SessionVerificationController
    
    /**
     * Allows generic GET requests to be made through the SDK's internal HTTP
     * client. This is useful when the caller's native HTTP client wouldn't
     * have the same configuration (such as certificates, proxies, etc.) This
     * method returns the raw bytes of the response, so that any kind of
     * resource can be fetched including images, files, etc.
     *
     * Note: When an HTTP error occurs, the error response can be found in the
     * `ClientError::Generic`'s `details` field.
     */
    suspend fun `getUrl`(`url`: kotlin.String): kotlin.ByteArray
    
    /**
     * The homeserver this client is configured to use.
     */
    fun `homeserver`(): kotlin.String
    
    /**
     * Information about login options for the client's homeserver.
     */
    suspend fun `homeserverLoginDetails`(): HomeserverLoginDetails
    
    suspend fun `ignoreUser`(`userId`: kotlin.String)
    
    suspend fun `ignoredUsers`(): List<kotlin.String>
    
    /**
     * Checks if the server supports the LiveKit RTC focus for placing calls.
     */
    suspend fun `isLivekitRtcSupported`(): kotlin.Boolean
    
    /**
     * Checks if the server supports the report room API.
     */
    suspend fun `isReportRoomApiSupported`(): kotlin.Boolean
    
    /**
     * Checks if a room alias is not in use yet.
     *
     * Returns:
     * - `Ok(true)` if the room alias is available.
     * - `Ok(false)` if it's not (the resolve alias request returned a `404`
     * status code).
     * - An `Err` otherwise.
     */
    suspend fun `isRoomAliasAvailable`(`alias`: kotlin.String): kotlin.Boolean
    
    /**
     * Join a room by its ID.
     *
     * Use this method when the homeserver already knows of the given room ID.
     * Otherwise use `join_room_by_id_or_alias` so you can pass a list of
     * server names for the homeserver to find the room.
     */
    suspend fun `joinRoomById`(`roomId`: kotlin.String): Room
    
    /**
     * Join a room by its ID or alias.
     *
     * When supplying the room's ID, you can also supply a list of server names
     * for the homeserver to find the room. Typically these server names
     * come from a permalink's `via` parameters, or from resolving a room's
     * alias into an ID.
     */
    suspend fun `joinRoomByIdOrAlias`(`roomIdOrAlias`: kotlin.String, `serverNames`: List<kotlin.String>): Room
    
    /**
     * Knock on a room to join it using its ID or alias.
     */
    suspend fun `knock`(`roomIdOrAlias`: kotlin.String, `reason`: kotlin.String?, `serverNames`: List<kotlin.String>): Room
    
    /**
     * Login using a username and password.
     */
    suspend fun `login`(`username`: kotlin.String, `password`: kotlin.String, `initialDeviceName`: kotlin.String?, `deviceId`: kotlin.String?)
    
    /**
     * Login using an email and password.
     */
    suspend fun `loginWithEmail`(`email`: kotlin.String, `password`: kotlin.String, `initialDeviceName`: kotlin.String?, `deviceId`: kotlin.String?)
    
    /**
     * Completes the OIDC login process.
     */
    suspend fun `loginWithOidcCallback`(`callbackUrl`: kotlin.String)
    
    /**
     * Log in using a QR code.
     *
     * # Arguments
     *
     * * `oidc_configuration` - The data to restore or register the client with
     * the server.
     */
    fun `loginWithQrCode`(`oidcConfiguration`: OidcConfiguration): LoginWithQrCodeHandler
    
    /**
     * Log the current user out.
     */
    suspend fun `logout`()
    
    suspend fun `notificationClient`(`processSetup`: NotificationProcessSetup): NotificationClient
    
    /**
     * Subscribe to updates of global account data events.
     *
     * Be careful that only the most recent value can be observed. Subscribers
     * are notified when a new value is sent, but there is no guarantee that
     * they will see all values.
     */
    fun `observeAccountDataEvent`(`eventType`: AccountDataEventType, `listener`: AccountDataListener): TaskHandle
    
    /**
     * Subscribe to updates of room account data events.
     *
     * Be careful that only the most recent value can be observed. Subscribers
     * are notified when a new value is sent, but there is no guarantee that
     * they will see all values.
     */
    fun `observeRoomAccountDataEvent`(`roomId`: kotlin.String, `eventType`: RoomAccountDataEventType, `listener`: RoomAccountDataListener): TaskHandle
    
    suspend fun `removeAvatar`()
    
    /**
     * Empty the server version and unstable features cache.
     *
     * Since the SDK caches server info (versions, unstable features,
     * well-known etc), it's possible to have a stale entry in the cache.
     * This functions makes it possible to force reset it.
     */
    suspend fun `resetServerInfo`()
    
    /**
     * Resolves the given room alias to a room ID (and a list of servers), if
     * possible.
     */
    suspend fun `resolveRoomAlias`(`roomAlias`: kotlin.String): ResolvedRoomAlias?
    
    /**
     * Restores the client from a `Session`.
     *
     * It reloads the entire set of rooms from the previous session.
     *
     * If you want to control the amount of rooms to reloads, check
     * [`Client::restore_session_with`].
     */
    suspend fun `restoreSession`(`session`: Session)
    
    /**
     * Restores the client from a `Session`.
     *
     * It reloads a set of rooms controlled by [`RoomLoadSettings`].
     */
    suspend fun `restoreSessionWith`(`session`: Session, `roomLoadSettings`: RoomLoadSettings)
    
    /**
     * Checks if a room alias exists in the current homeserver.
     */
    suspend fun `roomAliasExists`(`roomAlias`: kotlin.String): kotlin.Boolean
    
    fun `roomDirectorySearch`(): RoomDirectorySearch
    
    fun `rooms`(): List<Room>
    
    suspend fun `searchUsers`(`searchTerm`: kotlin.String, `limit`: kotlin.ULong): SearchUsersResults
    
    /**
     * The URL of the server.
     *
     * Not to be confused with the `Self::homeserver`. `server` is usually
     * the server part in a user ID, e.g. with `@mnt_io:matrix.org`, here
     * `matrix.org` is the server, whilst `matrix-client.matrix.org` is the
     * homeserver (at the time of writing  2024-08-28).
     *
     * This value is optional depending on how the `Client` has been built.
     * If it's been built from a homeserver URL directly, we don't know the
     * server. However, if the `Client` has been built from a server URL or
     * name, then the homeserver has been discovered, and we know both.
     */
    fun `server`(): kotlin.String?
    
    /**
     * Get server vendor information from the federation API.
     *
     * This method retrieves information about the server's name and version
     * by calling the `/_matrix/federation/v1/version` endpoint.
     */
    suspend fun `serverVendorInfo`(): ServerVendorInfo
    
    fun `session`(): Session
    
    /**
     * Set the given account data content for the given event type.
     *
     * It should be supplied as a JSON string.
     */
    suspend fun `setAccountData`(`eventType`: kotlin.String, `content`: kotlin.String)
    
    /**
     * Sets the [ClientDelegate] which will inform about authentication errors.
     * Returns an error if the delegate was already set.
     */
    fun `setDelegate`(`delegate`: ClientDelegate?): TaskHandle?
    
    suspend fun `setDisplayName`(`name`: kotlin.String)
    
    /**
     * Set the invite request avatars display policy
     */
    suspend fun `setInviteAvatarsDisplayPolicy`(`policy`: InviteAvatars)
    
    /**
     * Set the media previews timeline display policy
     */
    suspend fun `setMediaPreviewDisplayPolicy`(`policy`: MediaPreviews)
    
    /**
     * Set the media retention policy.
     */
    suspend fun `setMediaRetentionPolicy`(`policy`: MediaRetentionPolicy)
    
    /**
     * Registers a pusher with given parameters
     */
    suspend fun `setPusher`(`identifiers`: PusherIdentifiers, `kind`: PusherKind, `appDisplayName`: kotlin.String, `deviceDisplayName`: kotlin.String, `profileTag`: kotlin.String?, `lang`: kotlin.String)
    
    /**
     * Sets the [UnableToDecryptDelegate] which will inform about UTDs.
     * Returns an error if the delegate was already set.
     */
    suspend fun `setUtdDelegate`(`utdDelegate`: UnableToDecryptDelegate)
    
    /**
     * The sliding sync version.
     */
    fun `slidingSyncVersion`(): SlidingSyncVersion
    
    fun `spaceService`(): SpaceService
    
    /**
     * Returns a handler to start the SSO login process.
     */
    suspend fun `startSsoLogin`(`redirectUrl`: kotlin.String, `idpId`: kotlin.String?): SsoHandler
    
    fun `subscribeToIgnoredUsers`(`listener`: IgnoredUsersListener): TaskHandle
    
    /**
     * Subscribe to changes in the media preview configuration.
     */
    suspend fun `subscribeToMediaPreviewConfig`(`listener`: MediaPreviewConfigListener): TaskHandle
    
    /**
     * Subscribe to [`RoomInfo`] updates given a provided [`RoomId`].
     *
     * This works even for rooms we haven't received yet, so we can subscribe
     * to this and wait until we receive updates from them when sync responses
     * are processed.
     *
     * Note this method should be used sparingly since using callback
     * interfaces is expensive, as well as keeping them alive for a long
     * time. Usages of this method should be short-lived and dropped as
     * soon as possible.
     */
    suspend fun `subscribeToRoomInfo`(`roomId`: kotlin.String, `listener`: RoomInfoListener): TaskHandle
    
    /**
     * Subscribe to the global enablement status of the send queue, at the
     * client-wide level.
     *
     * The given listener will be immediately called with the initial value of
     * the enablement status.
     */
    fun `subscribeToSendQueueStatus`(`listener`: SendQueueRoomErrorListener): TaskHandle
    
    /**
     * Subscribe to the global send queue update reporter, at the
     * client-wide level.
     *
     * The given listener will be immediately called with
     * `RoomSendQueueUpdate::NewLocalEvent` for each local echo existing in
     * the queue.
     */
    suspend fun `subscribeToSendQueueUpdates`(`listener`: SendQueueRoomUpdateListener): TaskHandle
    
    fun `syncService`(): SyncServiceBuilder
    
    suspend fun `trackRecentlyVisitedRoom`(`room`: kotlin.String)
    
    suspend fun `unignoreUser`(`userId`: kotlin.String)
    
    suspend fun `uploadAvatar`(`mimeType`: kotlin.String, `data`: kotlin.ByteArray)
    
    suspend fun `uploadMedia`(`mimeType`: kotlin.String, `data`: kotlin.ByteArray, `progressWatcher`: ProgressWatcher?): kotlin.String
    
    /**
     * Requests the URL needed for opening a web view using OIDC. Once the web
     * view has succeeded, call `login_with_oidc_callback` with the callback it
     * returns. If a failure occurs and a callback isn't available, make sure
     * to call `abort_oidc_auth` to inform the client of this.
     *
     * # Arguments
     *
     * * `oidc_configuration` - The configuration used to load the credentials
     * of the client if it is already registered with the authorization
     * server, or register the client and store its credentials if it isn't.
     *
     * * `prompt` - The desired user experience in the web UI. No value means
     * that the user wishes to login into an existing account, and a value of
     * `Create` means that the user wishes to register a new account.
     *
     * * `login_hint` - A generic login hint that an identity provider can use
     * to pre-fill the login form. The format of this hint is not restricted
     * by the spec as external providers all have their own way to handle the hint.
     * However, it should be noted that when providing a user ID as a hint
     * for MAS (with no upstream provider), then the format to use is defined
     * by [MSC4198]: https://github.com/matrix-org/matrix-spec-proposals/pull/4198
     *
     * * `device_id` - The unique ID that will be associated with the session.
     * If not set, a random one will be generated. It can be an existing
     * device ID from a previous login call. Note that this should be done
     * only if the client also holds the corresponding encryption keys.
     *
     * * `additional_scopes` - Additional scopes to request from the
     * authorization server, e.g. "urn:matrix:client:com.example.msc9999.foo".
     * The scopes for API access and the device ID according to the
     * [specification](https://spec.matrix.org/v1.15/client-server-api/#allocated-scope-tokens)
     * are always requested.
     */
    suspend fun `urlForOidc`(`oidcConfiguration`: OidcConfiguration, `prompt`: OidcPrompt?, `loginHint`: kotlin.String?, `deviceId`: kotlin.String?, `additionalScopes`: List<kotlin.String>?): OAuthAuthorizationData
    
    fun `userId`(): kotlin.String
    
    /**
     * The server name part of the current user ID
     */
    fun `userIdServerName`(): kotlin.String
    
    companion object
}

open class Client: Disposable, AutoCloseable, ClientInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_client(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_client(pointer!!, status)
        }
    }

    
    /**
     * Aborts an existing OIDC login operation that might have been cancelled,
     * failed etc.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `abortOidcAuth`(`authorizationData`: OAuthAuthorizationData) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_abort_oidc_auth(
                thisPtr,
                FfiConverterTypeOAuthAuthorizationData.lower(`authorizationData`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Get the content of the event of the given type out of the account data
     * store.
     *
     * It will be returned as a JSON string.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `accountData`(`eventType`: kotlin.String) : kotlin.String? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_account_data(
                thisPtr,
                FfiConverterString.lower(`eventType`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalString.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `accountUrl`(`action`: AccountManagementAction?) : kotlin.String? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_account_url(
                thisPtr,
                FfiConverterOptionalTypeAccountManagementAction.lower(`action`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalString.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Adds a recently used emoji to the list and uploads the updated
     * `io.element.recent_emoji` content to the global account data.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `addRecentEmoji`(`emoji`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_add_recent_emoji(
                thisPtr,
                FfiConverterString.lower(`emoji`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Find all sliding sync versions that are available.
     *
     * Be careful: This method may hit the store and will send new requests for
     * each call. It can be costly to call it repeatedly.
     *
     * If `.well-known` or `/versions` is unreachable, it will simply move
     * potential sliding sync versions aside. No error will be reported.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `availableSlidingSyncVersions`() : List<SlidingSyncVersion> {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_available_sliding_sync_versions(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterSequenceTypeSlidingSyncVersion.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Sends a request to retrieve the avatar URL. Will fill the cache used by
     * [`Self::cached_avatar_url`] on success.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `avatarUrl`() : kotlin.String? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_avatar_url(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalString.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Waits until an at least partially synced room is received, and returns
     * it.
     *
     * **Note: this function will loop endlessly until either it finds the room
     * or an externally set timeout happens.**
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `awaitRoomRemoteEcho`(`roomId`: kotlin.String) : Room {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_await_room_remote_echo(
                thisPtr,
                FfiConverterString.lower(`roomId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeRoom.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Retrieves an avatar cached from a previous call to [`Self::avatar_url`].
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `cachedAvatarUrl`() : kotlin.String? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_cached_avatar_url(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalString.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Lets the user know whether this is an `m.login.password` based
     * auth and if the account can actually be deactivated
     */override fun `canDeactivateAccount`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_can_deactivate_account(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Clear all the non-critical caches for this Client instance.
     *
     * WARNING: This will clear all the caches, including the base store (state
     * store), so callers must make sure that the Client is at rest before
     * calling it.
     *
     * In particular, if a [`SyncService`] is running, it must be passed here
     * as a parameter, or stopped before calling this method. Ideally, the
     * send queues should have been disabled and must all be inactive (i.e.
     * not sending events); this method will disable them, but it might not
     * be enough if the queues are still processing events.
     *
     * After the method returns, the Client will be in an unstable
     * state, and it is required that the caller reinstantiates a new
     * Client instance, be it via dropping the previous and re-creating it,
     * restarting their application, or any other similar means.
     *
     * - This will get rid of the backing state store file, if provided.
     * - This will empty all the room's persisted event caches, so all rooms
     * will start as if they were empty.
     * - This will empty the media cache according to the current media
     * retention policy.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `clearCaches`(`syncService`: SyncService?) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_clear_caches(
                thisPtr,
                FfiConverterOptionalTypeSyncService.lower(`syncService`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `createRoom`(`request`: CreateRoomParameters) : kotlin.String {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_create_room(
                thisPtr,
                FfiConverterTypeCreateRoomParameters.lower(`request`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterString.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Login using JWT
     * This is an implementation of the custom_login https://docs.rs/matrix-sdk/latest/matrix_sdk/matrix_auth/struct.MatrixAuth.html#method.login_custom
     * For more information on logging in with JWT: https://element-hq.github.io/synapse/latest/jwt.html
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `customLoginWithJwt`(`jwt`: kotlin.String, `initialDeviceName`: kotlin.String?, `deviceId`: kotlin.String?) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_custom_login_with_jwt(
                thisPtr,
                FfiConverterString.lower(`jwt`),FfiConverterOptionalString.lower(`initialDeviceName`),FfiConverterOptionalString.lower(`deviceId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Deactivate this account definitively.
     * Similarly to `encryption::reset_identity` this
     * will only work with password-based authentication (`m.login.password`)
     *
     * # Arguments
     *
     * * `auth_data` - This request uses the [User-Interactive Authentication
     * API][uiaa]. The first request needs to set this to `None` and will
     * always fail and the same request needs to be made but this time with
     * some `auth_data` provided.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `deactivateAccount`(`authData`: AuthData?, `eraseData`: kotlin.Boolean) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_deactivate_account(
                thisPtr,
                FfiConverterOptionalTypeAuthData.lower(`authData`),FfiConverterBoolean.lower(`eraseData`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Deletes a pusher of given pusher ids
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `deletePusher`(`identifiers`: PusherIdentifiers) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_delete_pusher(
                thisPtr,
                FfiConverterTypePusherIdentifiers.lower(`identifiers`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)override fun `deviceId`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_device_id(
        it, _status)
}
    }
    )
    }
    

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `displayName`() : kotlin.String {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_display_name(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterString.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Enables or disables all the room send queues at once.
     *
     * When connectivity is lost on a device, it is recommended to disable the
     * room sending queues.
     *
     * This can be controlled for individual rooms, using
     * [`Room::enable_send_queue`].
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `enableAllSendQueues`(`enable`: kotlin.Boolean) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_enable_all_send_queues(
                thisPtr,
                FfiConverterBoolean.lower(`enable`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Enables or disables progress reporting for media uploads in the send
     * queue.
     */override fun `enableSendQueueUploadProgress`(`enable`: kotlin.Boolean)
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_enable_send_queue_upload_progress(
        it, FfiConverterBoolean.lower(`enable`),_status)
}
    }
    
    

    override fun `encryption`(): Encryption {
            return FfiConverterTypeEncryption.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_encryption(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Fetch the media preview configuration from the server.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `fetchMediaPreviewConfig`() : MediaPreviewConfig? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_fetch_media_preview_config(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeMediaPreviewConfig.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)override fun `getDmRoom`(`userId`: kotlin.String): Room? {
            return FfiConverterOptionalTypeRoom.lift(
    callWithPointer {
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_get_dm_room(
        it, FfiConverterString.lower(`userId`),_status)
}
    }
    )
    }
    

    
    /**
     * Get the invite request avatars display policy
     * currently stored in the cache.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getInviteAvatarsDisplayPolicy`() : InviteAvatars? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_get_invite_avatars_display_policy(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeInviteAvatars.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Gets the `max_upload_size` value from the homeserver, which controls the
     * max size a media upload request can have.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getMaxMediaUploadSize`() : kotlin.ULong {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_get_max_media_upload_size(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_u64(future) },
        // lift function
        { FfiConverterULong.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getMediaContent`(`mediaSource`: MediaSource) : kotlin.ByteArray {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_get_media_content(
                thisPtr,
                FfiConverterTypeMediaSource.lower(`mediaSource`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterByteArray.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Retrieves a media file from the media source
     *
     * Not available on Wasm platforms, due to lack of accessible file system.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getMediaFile`(`mediaSource`: MediaSource, `filename`: kotlin.String?, `mimeType`: kotlin.String, `useCache`: kotlin.Boolean, `tempDir`: kotlin.String?) : MediaFileHandle {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_get_media_file(
                thisPtr,
                FfiConverterTypeMediaSource.lower(`mediaSource`),FfiConverterOptionalString.lower(`filename`),FfiConverterString.lower(`mimeType`),FfiConverterBoolean.lower(`useCache`),FfiConverterOptionalString.lower(`tempDir`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeMediaFileHandle.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Get the media previews timeline display policy
     * currently stored in the cache.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getMediaPreviewDisplayPolicy`() : MediaPreviews? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_get_media_preview_display_policy(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeMediaPreviews.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getMediaThumbnail`(`mediaSource`: MediaSource, `width`: kotlin.ULong, `height`: kotlin.ULong) : kotlin.ByteArray {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_get_media_thumbnail(
                thisPtr,
                FfiConverterTypeMediaSource.lower(`mediaSource`),FfiConverterULong.lower(`width`),FfiConverterULong.lower(`height`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterByteArray.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getNotificationSettings`() : NotificationSettings {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_get_notification_settings(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeNotificationSettings.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getProfile`(`userId`: kotlin.String) : UserProfile {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_get_profile(
                thisPtr,
                FfiConverterString.lower(`userId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeUserProfile.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Gets the list of recently used emojis from the
     * `io.element.recent_emoji` global account data.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getRecentEmojis`() : List<RecentEmoji> {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_get_recent_emojis(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterSequenceTypeRecentEmoji.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getRecentlyVisitedRooms`() : List<kotlin.String> {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_get_recently_visited_rooms(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterSequenceString.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Get a room by its ID.
     *
     * # Arguments
     *
     * * `room_id` - The ID of the room to get.
     *
     * # Returns
     *
     * A `Result` containing an optional room, or a `ClientError`.
     * This method will not initialize the room's timeline or populate it with
     * events.
     */
    @Throws(ClientException::class)override fun `getRoom`(`roomId`: kotlin.String): Room? {
            return FfiConverterOptionalTypeRoom.lift(
    callWithPointer {
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_get_room(
        it, FfiConverterString.lower(`roomId`),_status)
}
    }
    )
    }
    

    
    /**
     * Given a room alias, get the preview of a room, to interact with it.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getRoomPreviewFromRoomAlias`(`roomAlias`: kotlin.String) : RoomPreview {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_get_room_preview_from_room_alias(
                thisPtr,
                FfiConverterString.lower(`roomAlias`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeRoomPreview.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Given a room id, get the preview of a room, to interact with it.
     *
     * The list of `via_servers` must be a list of servers that know
     * about the room and can resolve it, and that may appear as a `via`
     * parameter in e.g. a permalink URL. This list can be empty.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getRoomPreviewFromRoomId`(`roomId`: kotlin.String, `viaServers`: List<kotlin.String>) : RoomPreview {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_get_room_preview_from_room_id(
                thisPtr,
                FfiConverterString.lower(`roomId`),FfiConverterSequenceString.lower(`viaServers`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeRoomPreview.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getSessionVerificationController`() : SessionVerificationController {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_get_session_verification_controller(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeSessionVerificationController.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Allows generic GET requests to be made through the SDK's internal HTTP
     * client. This is useful when the caller's native HTTP client wouldn't
     * have the same configuration (such as certificates, proxies, etc.) This
     * method returns the raw bytes of the response, so that any kind of
     * resource can be fetched including images, files, etc.
     *
     * Note: When an HTTP error occurs, the error response can be found in the
     * `ClientError::Generic`'s `details` field.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getUrl`(`url`: kotlin.String) : kotlin.ByteArray {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_get_url(
                thisPtr,
                FfiConverterString.lower(`url`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterByteArray.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * The homeserver this client is configured to use.
     */override fun `homeserver`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_homeserver(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Information about login options for the client's homeserver.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `homeserverLoginDetails`() : HomeserverLoginDetails {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_homeserver_login_details(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeHomeserverLoginDetails.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `ignoreUser`(`userId`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_ignore_user(
                thisPtr,
                FfiConverterString.lower(`userId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `ignoredUsers`() : List<kotlin.String> {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_ignored_users(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterSequenceString.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Checks if the server supports the LiveKit RTC focus for placing calls.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `isLivekitRtcSupported`() : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_is_livekit_rtc_supported(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Checks if the server supports the report room API.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `isReportRoomApiSupported`() : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_is_report_room_api_supported(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Checks if a room alias is not in use yet.
     *
     * Returns:
     * - `Ok(true)` if the room alias is available.
     * - `Ok(false)` if it's not (the resolve alias request returned a `404`
     * status code).
     * - An `Err` otherwise.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `isRoomAliasAvailable`(`alias`: kotlin.String) : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_is_room_alias_available(
                thisPtr,
                FfiConverterString.lower(`alias`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Join a room by its ID.
     *
     * Use this method when the homeserver already knows of the given room ID.
     * Otherwise use `join_room_by_id_or_alias` so you can pass a list of
     * server names for the homeserver to find the room.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `joinRoomById`(`roomId`: kotlin.String) : Room {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_join_room_by_id(
                thisPtr,
                FfiConverterString.lower(`roomId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeRoom.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Join a room by its ID or alias.
     *
     * When supplying the room's ID, you can also supply a list of server names
     * for the homeserver to find the room. Typically these server names
     * come from a permalink's `via` parameters, or from resolving a room's
     * alias into an ID.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `joinRoomByIdOrAlias`(`roomIdOrAlias`: kotlin.String, `serverNames`: List<kotlin.String>) : Room {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_join_room_by_id_or_alias(
                thisPtr,
                FfiConverterString.lower(`roomIdOrAlias`),FfiConverterSequenceString.lower(`serverNames`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeRoom.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Knock on a room to join it using its ID or alias.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `knock`(`roomIdOrAlias`: kotlin.String, `reason`: kotlin.String?, `serverNames`: List<kotlin.String>) : Room {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_knock(
                thisPtr,
                FfiConverterString.lower(`roomIdOrAlias`),FfiConverterOptionalString.lower(`reason`),FfiConverterSequenceString.lower(`serverNames`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeRoom.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Login using a username and password.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `login`(`username`: kotlin.String, `password`: kotlin.String, `initialDeviceName`: kotlin.String?, `deviceId`: kotlin.String?) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_login(
                thisPtr,
                FfiConverterString.lower(`username`),FfiConverterString.lower(`password`),FfiConverterOptionalString.lower(`initialDeviceName`),FfiConverterOptionalString.lower(`deviceId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Login using an email and password.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `loginWithEmail`(`email`: kotlin.String, `password`: kotlin.String, `initialDeviceName`: kotlin.String?, `deviceId`: kotlin.String?) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_login_with_email(
                thisPtr,
                FfiConverterString.lower(`email`),FfiConverterString.lower(`password`),FfiConverterOptionalString.lower(`initialDeviceName`),FfiConverterOptionalString.lower(`deviceId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Completes the OIDC login process.
     */
    @Throws(OidcException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `loginWithOidcCallback`(`callbackUrl`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_login_with_oidc_callback(
                thisPtr,
                FfiConverterString.lower(`callbackUrl`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        OidcException.ErrorHandler,
    )
    }

    
    /**
     * Log in using a QR code.
     *
     * # Arguments
     *
     * * `oidc_configuration` - The data to restore or register the client with
     * the server.
     */override fun `loginWithQrCode`(`oidcConfiguration`: OidcConfiguration): LoginWithQrCodeHandler {
            return FfiConverterTypeLoginWithQrCodeHandler.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_login_with_qr_code(
        it, FfiConverterTypeOidcConfiguration.lower(`oidcConfiguration`),_status)
}
    }
    )
    }
    

    
    /**
     * Log the current user out.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `logout`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_logout(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `notificationClient`(`processSetup`: NotificationProcessSetup) : NotificationClient {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_notification_client(
                thisPtr,
                FfiConverterTypeNotificationProcessSetup.lower(`processSetup`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeNotificationClient.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Subscribe to updates of global account data events.
     *
     * Be careful that only the most recent value can be observed. Subscribers
     * are notified when a new value is sent, but there is no guarantee that
     * they will see all values.
     */override fun `observeAccountDataEvent`(`eventType`: AccountDataEventType, `listener`: AccountDataListener): TaskHandle {
            return FfiConverterTypeTaskHandle.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_observe_account_data_event(
        it, FfiConverterTypeAccountDataEventType.lower(`eventType`),FfiConverterTypeAccountDataListener.lower(`listener`),_status)
}
    }
    )
    }
    

    
    /**
     * Subscribe to updates of room account data events.
     *
     * Be careful that only the most recent value can be observed. Subscribers
     * are notified when a new value is sent, but there is no guarantee that
     * they will see all values.
     */
    @Throws(ClientException::class)override fun `observeRoomAccountDataEvent`(`roomId`: kotlin.String, `eventType`: RoomAccountDataEventType, `listener`: RoomAccountDataListener): TaskHandle {
            return FfiConverterTypeTaskHandle.lift(
    callWithPointer {
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_observe_room_account_data_event(
        it, FfiConverterString.lower(`roomId`),FfiConverterTypeRoomAccountDataEventType.lower(`eventType`),FfiConverterTypeRoomAccountDataListener.lower(`listener`),_status)
}
    }
    )
    }
    

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `removeAvatar`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_remove_avatar(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Empty the server version and unstable features cache.
     *
     * Since the SDK caches server info (versions, unstable features,
     * well-known etc), it's possible to have a stale entry in the cache.
     * This functions makes it possible to force reset it.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `resetServerInfo`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_reset_server_info(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Resolves the given room alias to a room ID (and a list of servers), if
     * possible.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `resolveRoomAlias`(`roomAlias`: kotlin.String) : ResolvedRoomAlias? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_resolve_room_alias(
                thisPtr,
                FfiConverterString.lower(`roomAlias`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeResolvedRoomAlias.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Restores the client from a `Session`.
     *
     * It reloads the entire set of rooms from the previous session.
     *
     * If you want to control the amount of rooms to reloads, check
     * [`Client::restore_session_with`].
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `restoreSession`(`session`: Session) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_restore_session(
                thisPtr,
                FfiConverterTypeSession.lower(`session`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Restores the client from a `Session`.
     *
     * It reloads a set of rooms controlled by [`RoomLoadSettings`].
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `restoreSessionWith`(`session`: Session, `roomLoadSettings`: RoomLoadSettings) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_restore_session_with(
                thisPtr,
                FfiConverterTypeSession.lower(`session`),FfiConverterTypeRoomLoadSettings.lower(`roomLoadSettings`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Checks if a room alias exists in the current homeserver.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `roomAliasExists`(`roomAlias`: kotlin.String) : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_room_alias_exists(
                thisPtr,
                FfiConverterString.lower(`roomAlias`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    override fun `roomDirectorySearch`(): RoomDirectorySearch {
            return FfiConverterTypeRoomDirectorySearch.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_room_directory_search(
        it, _status)
}
    }
    )
    }
    

    override fun `rooms`(): List<Room> {
            return FfiConverterSequenceTypeRoom.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_rooms(
        it, _status)
}
    }
    )
    }
    

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `searchUsers`(`searchTerm`: kotlin.String, `limit`: kotlin.ULong) : SearchUsersResults {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_search_users(
                thisPtr,
                FfiConverterString.lower(`searchTerm`),FfiConverterULong.lower(`limit`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSearchUsersResults.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * The URL of the server.
     *
     * Not to be confused with the `Self::homeserver`. `server` is usually
     * the server part in a user ID, e.g. with `@mnt_io:matrix.org`, here
     * `matrix.org` is the server, whilst `matrix-client.matrix.org` is the
     * homeserver (at the time of writing  2024-08-28).
     *
     * This value is optional depending on how the `Client` has been built.
     * If it's been built from a homeserver URL directly, we don't know the
     * server. However, if the `Client` has been built from a server URL or
     * name, then the homeserver has been discovered, and we know both.
     */override fun `server`(): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_server(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get server vendor information from the federation API.
     *
     * This method retrieves information about the server's name and version
     * by calling the `/_matrix/federation/v1/version` endpoint.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `serverVendorInfo`() : ServerVendorInfo {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_server_vendor_info(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation).let { RustBufferServerVendorInfo.create(it.capacity.toULong(), it.len.toULong(), it.data) } },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeServerVendorInfo.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)override fun `session`(): Session {
            return FfiConverterTypeSession.lift(
    callWithPointer {
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_session(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Set the given account data content for the given event type.
     *
     * It should be supplied as a JSON string.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setAccountData`(`eventType`: kotlin.String, `content`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_set_account_data(
                thisPtr,
                FfiConverterString.lower(`eventType`),FfiConverterString.lower(`content`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Sets the [ClientDelegate] which will inform about authentication errors.
     * Returns an error if the delegate was already set.
     */
    @Throws(ClientException::class)override fun `setDelegate`(`delegate`: ClientDelegate?): TaskHandle? {
            return FfiConverterOptionalTypeTaskHandle.lift(
    callWithPointer {
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_set_delegate(
        it, FfiConverterOptionalTypeClientDelegate.lower(`delegate`),_status)
}
    }
    )
    }
    

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setDisplayName`(`name`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_set_display_name(
                thisPtr,
                FfiConverterString.lower(`name`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Set the invite request avatars display policy
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setInviteAvatarsDisplayPolicy`(`policy`: InviteAvatars) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_set_invite_avatars_display_policy(
                thisPtr,
                FfiConverterTypeInviteAvatars.lower(`policy`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Set the media previews timeline display policy
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setMediaPreviewDisplayPolicy`(`policy`: MediaPreviews) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_set_media_preview_display_policy(
                thisPtr,
                FfiConverterTypeMediaPreviews.lower(`policy`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Set the media retention policy.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setMediaRetentionPolicy`(`policy`: MediaRetentionPolicy) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_set_media_retention_policy(
                thisPtr,
                FfiConverterTypeMediaRetentionPolicy.lower(`policy`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Registers a pusher with given parameters
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setPusher`(`identifiers`: PusherIdentifiers, `kind`: PusherKind, `appDisplayName`: kotlin.String, `deviceDisplayName`: kotlin.String, `profileTag`: kotlin.String?, `lang`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_set_pusher(
                thisPtr,
                FfiConverterTypePusherIdentifiers.lower(`identifiers`),FfiConverterTypePusherKind.lower(`kind`),FfiConverterString.lower(`appDisplayName`),FfiConverterString.lower(`deviceDisplayName`),FfiConverterOptionalString.lower(`profileTag`),FfiConverterString.lower(`lang`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Sets the [UnableToDecryptDelegate] which will inform about UTDs.
     * Returns an error if the delegate was already set.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setUtdDelegate`(`utdDelegate`: UnableToDecryptDelegate) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_set_utd_delegate(
                thisPtr,
                FfiConverterTypeUnableToDecryptDelegate.lower(`utdDelegate`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * The sliding sync version.
     */override fun `slidingSyncVersion`(): SlidingSyncVersion {
            return FfiConverterTypeSlidingSyncVersion.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_sliding_sync_version(
        it, _status)
}
    }
    )
    }
    

    override fun `spaceService`(): SpaceService {
            return FfiConverterTypeSpaceService.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_space_service(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Returns a handler to start the SSO login process.
     */
    @Throws(SsoException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `startSsoLogin`(`redirectUrl`: kotlin.String, `idpId`: kotlin.String?) : SsoHandler {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_start_sso_login(
                thisPtr,
                FfiConverterString.lower(`redirectUrl`),FfiConverterOptionalString.lower(`idpId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeSsoHandler.lift(it) },
        // Error FFI converter
        SsoException.ErrorHandler,
    )
    }

    override fun `subscribeToIgnoredUsers`(`listener`: IgnoredUsersListener): TaskHandle {
            return FfiConverterTypeTaskHandle.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_ignored_users(
        it, FfiConverterTypeIgnoredUsersListener.lower(`listener`),_status)
}
    }
    )
    }
    

    
    /**
     * Subscribe to changes in the media preview configuration.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `subscribeToMediaPreviewConfig`(`listener`: MediaPreviewConfigListener) : TaskHandle {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_media_preview_config(
                thisPtr,
                FfiConverterTypeMediaPreviewConfigListener.lower(`listener`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeTaskHandle.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Subscribe to [`RoomInfo`] updates given a provided [`RoomId`].
     *
     * This works even for rooms we haven't received yet, so we can subscribe
     * to this and wait until we receive updates from them when sync responses
     * are processed.
     *
     * Note this method should be used sparingly since using callback
     * interfaces is expensive, as well as keeping them alive for a long
     * time. Usages of this method should be short-lived and dropped as
     * soon as possible.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `subscribeToRoomInfo`(`roomId`: kotlin.String, `listener`: RoomInfoListener) : TaskHandle {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_room_info(
                thisPtr,
                FfiConverterString.lower(`roomId`),FfiConverterTypeRoomInfoListener.lower(`listener`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeTaskHandle.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Subscribe to the global enablement status of the send queue, at the
     * client-wide level.
     *
     * The given listener will be immediately called with the initial value of
     * the enablement status.
     */override fun `subscribeToSendQueueStatus`(`listener`: SendQueueRoomErrorListener): TaskHandle {
            return FfiConverterTypeTaskHandle.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_send_queue_status(
        it, FfiConverterTypeSendQueueRoomErrorListener.lower(`listener`),_status)
}
    }
    )
    }
    

    
    /**
     * Subscribe to the global send queue update reporter, at the
     * client-wide level.
     *
     * The given listener will be immediately called with
     * `RoomSendQueueUpdate::NewLocalEvent` for each local echo existing in
     * the queue.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `subscribeToSendQueueUpdates`(`listener`: SendQueueRoomUpdateListener) : TaskHandle {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_send_queue_updates(
                thisPtr,
                FfiConverterTypeSendQueueRoomUpdateListener.lower(`listener`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeTaskHandle.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    override fun `syncService`(): SyncServiceBuilder {
            return FfiConverterTypeSyncServiceBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_sync_service(
        it, _status)
}
    }
    )
    }
    

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `trackRecentlyVisitedRoom`(`room`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_track_recently_visited_room(
                thisPtr,
                FfiConverterString.lower(`room`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `unignoreUser`(`userId`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_unignore_user(
                thisPtr,
                FfiConverterString.lower(`userId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `uploadAvatar`(`mimeType`: kotlin.String, `data`: kotlin.ByteArray) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_upload_avatar(
                thisPtr,
                FfiConverterString.lower(`mimeType`),FfiConverterByteArray.lower(`data`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `uploadMedia`(`mimeType`: kotlin.String, `data`: kotlin.ByteArray, `progressWatcher`: ProgressWatcher?) : kotlin.String {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_upload_media(
                thisPtr,
                FfiConverterString.lower(`mimeType`),FfiConverterByteArray.lower(`data`),FfiConverterOptionalTypeProgressWatcher.lower(`progressWatcher`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterString.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Requests the URL needed for opening a web view using OIDC. Once the web
     * view has succeeded, call `login_with_oidc_callback` with the callback it
     * returns. If a failure occurs and a callback isn't available, make sure
     * to call `abort_oidc_auth` to inform the client of this.
     *
     * # Arguments
     *
     * * `oidc_configuration` - The configuration used to load the credentials
     * of the client if it is already registered with the authorization
     * server, or register the client and store its credentials if it isn't.
     *
     * * `prompt` - The desired user experience in the web UI. No value means
     * that the user wishes to login into an existing account, and a value of
     * `Create` means that the user wishes to register a new account.
     *
     * * `login_hint` - A generic login hint that an identity provider can use
     * to pre-fill the login form. The format of this hint is not restricted
     * by the spec as external providers all have their own way to handle the hint.
     * However, it should be noted that when providing a user ID as a hint
     * for MAS (with no upstream provider), then the format to use is defined
     * by [MSC4198]: https://github.com/matrix-org/matrix-spec-proposals/pull/4198
     *
     * * `device_id` - The unique ID that will be associated with the session.
     * If not set, a random one will be generated. It can be an existing
     * device ID from a previous login call. Note that this should be done
     * only if the client also holds the corresponding encryption keys.
     *
     * * `additional_scopes` - Additional scopes to request from the
     * authorization server, e.g. "urn:matrix:client:com.example.msc9999.foo".
     * The scopes for API access and the device ID according to the
     * [specification](https://spec.matrix.org/v1.15/client-server-api/#allocated-scope-tokens)
     * are always requested.
     */
    @Throws(OidcException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `urlForOidc`(`oidcConfiguration`: OidcConfiguration, `prompt`: OidcPrompt?, `loginHint`: kotlin.String?, `deviceId`: kotlin.String?, `additionalScopes`: List<kotlin.String>?) : OAuthAuthorizationData {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_url_for_oidc(
                thisPtr,
                FfiConverterTypeOidcConfiguration.lower(`oidcConfiguration`),FfiConverterOptionalTypeOidcPrompt.lower(`prompt`),FfiConverterOptionalString.lower(`loginHint`),FfiConverterOptionalString.lower(`deviceId`),FfiConverterOptionalSequenceString.lower(`additionalScopes`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeOAuthAuthorizationData.lift(it) },
        // Error FFI converter
        OidcException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)override fun `userId`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_user_id(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * The server name part of the current user ID
     */
    @Throws(ClientException::class)override fun `userIdServerName`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_client_user_id_server_name(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

public object FfiConverterTypeClient: FfiConverter<Client, Pointer> {

    override fun lower(value: Client): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): Client {
        return Client(value)
    }

    override fun read(buf: ByteBuffer): Client {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Client) = 8UL

    override fun write(value: Client, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface ClientBuilderInterface {
    
    fun `addRootCertificates`(`certificates`: List<kotlin.ByteArray>): ClientBuilder
    
    /**
     * Automatically create a backup version if no backup exists.
     */
    fun `autoEnableBackups`(`autoEnableBackups`: kotlin.Boolean): ClientBuilder
    
    fun `autoEnableCrossSigning`(`autoEnableCrossSigning`: kotlin.Boolean): ClientBuilder
    
    /**
     * Select a strategy to download room keys from the backup. By default
     * we download after a decryption failure.
     *
     * Take a look at the [`BackupDownloadStrategy`] enum for more options.
     */
    fun `backupDownloadStrategy`(`backupDownloadStrategy`: BackupDownloadStrategy): ClientBuilder
    
    suspend fun `build`(): Client
    
    fun `crossProcessStoreLocksHolderName`(`holderName`: kotlin.String): ClientBuilder
    
    /**
     * Set the trust requirement to be used when decrypting events.
     */
    fun `decryptionSettings`(`decryptionSettings`: DecryptionSettings): ClientBuilder
    
    fun `disableAutomaticTokenRefresh`(): ClientBuilder
    
    /**
     * Don't trust any system root certificates, only trust the certificates
     * provided through
     * [`add_root_certificates`][ClientBuilder::add_root_certificates].
     */
    fun `disableBuiltInRootCertificates`(): ClientBuilder
    
    fun `disableSslVerification`(): ClientBuilder
    
    fun `enableOidcRefreshLock`(): ClientBuilder
    
    /**
     * Set whether to enable the experimental support for sending and receiving
     * encrypted room history on invite, per [MSC4268].
     *
     * [MSC4268]: https://github.com/matrix-org/matrix-spec-proposals/pull/4268
     */
    fun `enableShareHistoryOnInvite`(`enableShareHistoryOnInvite`: kotlin.Boolean): ClientBuilder
    
    fun `homeserverUrl`(`url`: kotlin.String): ClientBuilder
    
    fun `proxy`(`url`: kotlin.String): ClientBuilder
    
    /**
     * Add a default request config to this client.
     */
    fun `requestConfig`(`config`: RequestConfig): ClientBuilder
    
    /**
     * Set the strategy to be used for picking recipient devices when sending
     * an encrypted message.
     */
    fun `roomKeyRecipientStrategy`(`strategy`: CollectStrategy): ClientBuilder
    
    fun `serverName`(`serverName`: kotlin.String): ClientBuilder
    
    fun `serverNameOrHomeserverUrl`(`serverNameOrUrl`: kotlin.String): ClientBuilder
    
    /**
     * Set the cache size for the SQLite stores given to
     * [`ClientBuilder::session_paths`].
     *
     * Each store exposes a SQLite connection. This method controls the cache
     * size, in **bytes (!)**.
     *
     * The cache represents data SQLite holds in memory at once per open
     * database file. The default cache implementation does not allocate the
     * full amount of cache memory all at once. Cache memory is allocated
     * in smaller chunks on an as-needed basis.
     *
     * See [`SqliteStoreConfig::cache_size`] to learn more.
     */
    fun `sessionCacheSize`(`cacheSize`: kotlin.UInt?): ClientBuilder
    
    /**
     * Set the size limit for the SQLite WAL files of stores given to
     * [`ClientBuilder::session_paths`].
     *
     * Each store uses the WAL journal mode. This method controls the size
     * limit of the WAL files, in **bytes (!)**.
     *
     * See [`SqliteStoreConfig::journal_size_limit`] to learn more.
     */
    fun `sessionJournalSizeLimit`(`limit`: kotlin.UInt?): ClientBuilder
    
    /**
     * Set the passphrase for the stores given to
     * [`ClientBuilder::session_paths`].
     */
    fun `sessionPassphrase`(`passphrase`: kotlin.String?): ClientBuilder
    
    /**
     * Sets the paths that the client will use to store its data and caches.
     * Both paths **must** be unique per session as the SDK stores aren't
     * capable of handling multiple users, however it is valid to use the
     * same path for both stores on a single session.
     *
     * Leaving this unset tells the client to use an in-memory data store.
     */
    fun `sessionPaths`(`dataPath`: kotlin.String, `cachePath`: kotlin.String): ClientBuilder
    
    /**
     * Set the pool max size for the SQLite stores given to
     * [`ClientBuilder::session_paths`].
     *
     * Each store exposes an async pool of connections. This method controls
     * the size of the pool. The larger the pool is, the more memory is
     * consumed, but also the more the app is reactive because it doesn't need
     * to wait on a pool to be available to run queries.
     *
     * See [`SqliteStoreConfig::pool_max_size`] to learn more.
     */
    fun `sessionPoolMaxSize`(`poolMaxSize`: kotlin.UInt?): ClientBuilder
    
    fun `setSessionDelegate`(`sessionDelegate`: ClientSessionDelegate): ClientBuilder
    
    fun `slidingSyncVersionBuilder`(`versionBuilder`: SlidingSyncVersionBuilder): ClientBuilder
    
    /**
     * Tell the client that the system is memory constrained, like in a push
     * notification process for example.
     *
     * So far, at the time of writing (2025-04-07), it changes the defaults of
     * [`SqliteStoreConfig`], so one might not need to call
     * [`ClientBuilder::session_cache_size`] and siblings for example. Please
     * check [`SqliteStoreConfig::with_low_memory_config`].
     */
    fun `systemIsMemoryConstrained`(): ClientBuilder
    
    /**
     * Whether the client should support threads client-side or not, and enable
     * experimental support for MSC4306 (threads subscriptions) or not.
     */
    fun `threadsEnabled`(`enabled`: kotlin.Boolean, `threadSubscriptions`: kotlin.Boolean): ClientBuilder
    
    fun `userAgent`(`userAgent`: kotlin.String): ClientBuilder
    
    fun `username`(`username`: kotlin.String): ClientBuilder
    
    companion object
}

open class ClientBuilder: Disposable, AutoCloseable, ClientBuilderInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }
    constructor() :
        this(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_constructor_clientbuilder_new(
        _status)
}
    )

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_clientbuilder(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_clientbuilder(pointer!!, status)
        }
    }

    override fun `addRootCertificates`(`certificates`: List<kotlin.ByteArray>): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_add_root_certificates(
        it, FfiConverterSequenceByteArray.lower(`certificates`),_status)
}
    }
    )
    }
    

    
    /**
     * Automatically create a backup version if no backup exists.
     */override fun `autoEnableBackups`(`autoEnableBackups`: kotlin.Boolean): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_auto_enable_backups(
        it, FfiConverterBoolean.lower(`autoEnableBackups`),_status)
}
    }
    )
    }
    

    override fun `autoEnableCrossSigning`(`autoEnableCrossSigning`: kotlin.Boolean): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_auto_enable_cross_signing(
        it, FfiConverterBoolean.lower(`autoEnableCrossSigning`),_status)
}
    }
    )
    }
    

    
    /**
     * Select a strategy to download room keys from the backup. By default
     * we download after a decryption failure.
     *
     * Take a look at the [`BackupDownloadStrategy`] enum for more options.
     */override fun `backupDownloadStrategy`(`backupDownloadStrategy`: BackupDownloadStrategy): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_backup_download_strategy(
        it, FfiConverterTypeBackupDownloadStrategy.lower(`backupDownloadStrategy`),_status)
}
    }
    )
    }
    

    
    @Throws(ClientBuildException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `build`() : Client {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_build(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeClient.lift(it) },
        // Error FFI converter
        ClientBuildException.ErrorHandler,
    )
    }

    override fun `crossProcessStoreLocksHolderName`(`holderName`: kotlin.String): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_cross_process_store_locks_holder_name(
        it, FfiConverterString.lower(`holderName`),_status)
}
    }
    )
    }
    

    
    /**
     * Set the trust requirement to be used when decrypting events.
     */override fun `decryptionSettings`(`decryptionSettings`: DecryptionSettings): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_decryption_settings(
        it, FfiConverterTypeDecryptionSettings.lower(`decryptionSettings`),_status)
}
    }
    )
    }
    

    override fun `disableAutomaticTokenRefresh`(): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_automatic_token_refresh(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Don't trust any system root certificates, only trust the certificates
     * provided through
     * [`add_root_certificates`][ClientBuilder::add_root_certificates].
     */override fun `disableBuiltInRootCertificates`(): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_built_in_root_certificates(
        it, _status)
}
    }
    )
    }
    

    override fun `disableSslVerification`(): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_ssl_verification(
        it, _status)
}
    }
    )
    }
    

    override fun `enableOidcRefreshLock`(): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_enable_oidc_refresh_lock(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Set whether to enable the experimental support for sending and receiving
     * encrypted room history on invite, per [MSC4268].
     *
     * [MSC4268]: https://github.com/matrix-org/matrix-spec-proposals/pull/4268
     */override fun `enableShareHistoryOnInvite`(`enableShareHistoryOnInvite`: kotlin.Boolean): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_enable_share_history_on_invite(
        it, FfiConverterBoolean.lower(`enableShareHistoryOnInvite`),_status)
}
    }
    )
    }
    

    override fun `homeserverUrl`(`url`: kotlin.String): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_homeserver_url(
        it, FfiConverterString.lower(`url`),_status)
}
    }
    )
    }
    

    override fun `proxy`(`url`: kotlin.String): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_proxy(
        it, FfiConverterString.lower(`url`),_status)
}
    }
    )
    }
    

    
    /**
     * Add a default request config to this client.
     */override fun `requestConfig`(`config`: RequestConfig): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_request_config(
        it, FfiConverterTypeRequestConfig.lower(`config`),_status)
}
    }
    )
    }
    

    
    /**
     * Set the strategy to be used for picking recipient devices when sending
     * an encrypted message.
     */override fun `roomKeyRecipientStrategy`(`strategy`: CollectStrategy): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_room_key_recipient_strategy(
        it, FfiConverterTypeCollectStrategy.lower(`strategy`),_status)
}
    }
    )
    }
    

    override fun `serverName`(`serverName`: kotlin.String): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_name(
        it, FfiConverterString.lower(`serverName`),_status)
}
    }
    )
    }
    

    override fun `serverNameOrHomeserverUrl`(`serverNameOrUrl`: kotlin.String): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_name_or_homeserver_url(
        it, FfiConverterString.lower(`serverNameOrUrl`),_status)
}
    }
    )
    }
    

    
    /**
     * Set the cache size for the SQLite stores given to
     * [`ClientBuilder::session_paths`].
     *
     * Each store exposes a SQLite connection. This method controls the cache
     * size, in **bytes (!)**.
     *
     * The cache represents data SQLite holds in memory at once per open
     * database file. The default cache implementation does not allocate the
     * full amount of cache memory all at once. Cache memory is allocated
     * in smaller chunks on an as-needed basis.
     *
     * See [`SqliteStoreConfig::cache_size`] to learn more.
     */override fun `sessionCacheSize`(`cacheSize`: kotlin.UInt?): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_cache_size(
        it, FfiConverterOptionalUInt.lower(`cacheSize`),_status)
}
    }
    )
    }
    

    
    /**
     * Set the size limit for the SQLite WAL files of stores given to
     * [`ClientBuilder::session_paths`].
     *
     * Each store uses the WAL journal mode. This method controls the size
     * limit of the WAL files, in **bytes (!)**.
     *
     * See [`SqliteStoreConfig::journal_size_limit`] to learn more.
     */override fun `sessionJournalSizeLimit`(`limit`: kotlin.UInt?): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_journal_size_limit(
        it, FfiConverterOptionalUInt.lower(`limit`),_status)
}
    }
    )
    }
    

    
    /**
     * Set the passphrase for the stores given to
     * [`ClientBuilder::session_paths`].
     */override fun `sessionPassphrase`(`passphrase`: kotlin.String?): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_passphrase(
        it, FfiConverterOptionalString.lower(`passphrase`),_status)
}
    }
    )
    }
    

    
    /**
     * Sets the paths that the client will use to store its data and caches.
     * Both paths **must** be unique per session as the SDK stores aren't
     * capable of handling multiple users, however it is valid to use the
     * same path for both stores on a single session.
     *
     * Leaving this unset tells the client to use an in-memory data store.
     */override fun `sessionPaths`(`dataPath`: kotlin.String, `cachePath`: kotlin.String): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_paths(
        it, FfiConverterString.lower(`dataPath`),FfiConverterString.lower(`cachePath`),_status)
}
    }
    )
    }
    

    
    /**
     * Set the pool max size for the SQLite stores given to
     * [`ClientBuilder::session_paths`].
     *
     * Each store exposes an async pool of connections. This method controls
     * the size of the pool. The larger the pool is, the more memory is
     * consumed, but also the more the app is reactive because it doesn't need
     * to wait on a pool to be available to run queries.
     *
     * See [`SqliteStoreConfig::pool_max_size`] to learn more.
     */override fun `sessionPoolMaxSize`(`poolMaxSize`: kotlin.UInt?): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_pool_max_size(
        it, FfiConverterOptionalUInt.lower(`poolMaxSize`),_status)
}
    }
    )
    }
    

    override fun `setSessionDelegate`(`sessionDelegate`: ClientSessionDelegate): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_set_session_delegate(
        it, FfiConverterTypeClientSessionDelegate.lower(`sessionDelegate`),_status)
}
    }
    )
    }
    

    override fun `slidingSyncVersionBuilder`(`versionBuilder`: SlidingSyncVersionBuilder): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_sliding_sync_version_builder(
        it, FfiConverterTypeSlidingSyncVersionBuilder.lower(`versionBuilder`),_status)
}
    }
    )
    }
    

    
    /**
     * Tell the client that the system is memory constrained, like in a push
     * notification process for example.
     *
     * So far, at the time of writing (2025-04-07), it changes the defaults of
     * [`SqliteStoreConfig`], so one might not need to call
     * [`ClientBuilder::session_cache_size`] and siblings for example. Please
     * check [`SqliteStoreConfig::with_low_memory_config`].
     */override fun `systemIsMemoryConstrained`(): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_system_is_memory_constrained(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Whether the client should support threads client-side or not, and enable
     * experimental support for MSC4306 (threads subscriptions) or not.
     */override fun `threadsEnabled`(`enabled`: kotlin.Boolean, `threadSubscriptions`: kotlin.Boolean): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_threads_enabled(
        it, FfiConverterBoolean.lower(`enabled`),FfiConverterBoolean.lower(`threadSubscriptions`),_status)
}
    }
    )
    }
    

    override fun `userAgent`(`userAgent`: kotlin.String): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_user_agent(
        it, FfiConverterString.lower(`userAgent`),_status)
}
    }
    )
    }
    

    override fun `username`(`username`: kotlin.String): ClientBuilder {
            return FfiConverterTypeClientBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_username(
        it, FfiConverterString.lower(`username`),_status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

public object FfiConverterTypeClientBuilder: FfiConverter<ClientBuilder, Pointer> {

    override fun lower(value: ClientBuilder): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): ClientBuilder {
        return ClientBuilder(value)
    }

    override fun read(buf: ByteBuffer): ClientBuilder {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ClientBuilder) = 8UL

    override fun write(value: ClientBuilder, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface EncryptionInterface {
    
    /**
     * Does a backup exist on the server?
     *
     * Because the homeserver doesn't notify us about changes to the backup
     * version, the [`BackupState`] and its listener are a bit crippled.
     * The `BackupState::Unknown` state might mean there is no backup at all or
     * a backup exists but we don't have access to it.
     *
     * Therefore it is necessary to poll the server for an answer every time
     * you want to differentiate between those two states.
     */
    suspend fun `backupExistsOnServer`(): kotlin.Boolean
    
    fun `backupState`(): BackupState
    
    fun `backupStateListener`(`listener`: BackupStateListener): TaskHandle
    
    /**
     * Get the public curve25519 key of our own device in base64. This is
     * usually what is called the identity key of the device.
     */
    suspend fun `curve25519Key`(): kotlin.String?
    
    suspend fun `disableRecovery`()
    
    /**
     * Get the public ed25519 key of our own device. This is usually what is
     * called the fingerprint of the device.
     */
    suspend fun `ed25519Key`(): kotlin.String?
    
    suspend fun `enableBackups`()
    
    suspend fun `enableRecovery`(`waitForBackupsToUpload`: kotlin.Boolean, `passphrase`: kotlin.String?, `progressListener`: EnableRecoveryProgressListener): kotlin.String
    
    /**
     * Does the user have other devices that the current device can verify
     * against?
     *
     * The device must be signed by the user's cross-signing key, must have an
     * identity, and must not be a dehydrated device.
     */
    suspend fun `hasDevicesToVerifyAgainst`(): kotlin.Boolean
    
    suspend fun `isLastDevice`(): kotlin.Boolean
    
    suspend fun `recover`(`recoveryKey`: kotlin.String)
    
    suspend fun `recoverAndReset`(`oldRecoveryKey`: kotlin.String): kotlin.String
    
    fun `recoveryState`(): RecoveryState
    
    fun `recoveryStateListener`(`listener`: RecoveryStateListener): TaskHandle
    
    /**
     * Completely reset the current user's crypto identity: reset the cross
     * signing keys, delete the existing backup and recovery key.
     */
    suspend fun `resetIdentity`(): IdentityResetHandle?
    
    suspend fun `resetRecoveryKey`(): kotlin.String
    
    /**
     * Get the E2EE identity of a user.
     *
     * This method always tries to fetch the identity from the store, which we
     * only have if the user is tracked, meaning that we are both members
     * of the same encrypted room. If no user is found locally, a request will
     * be made to the homeserver.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user that the identity belongs to.
     *
     * Returns a `UserIdentity` if one is found. Returns an error if there
     * was an issue with the crypto store or with the request to the
     * homeserver.
     *
     * This will always return `None` if the client hasn't been logged in.
     */
    suspend fun `userIdentity`(`userId`: kotlin.String): UserIdentity?
    
    fun `verificationState`(): VerificationState
    
    fun `verificationStateListener`(`listener`: VerificationStateListener): TaskHandle
    
    suspend fun `waitForBackupUploadSteadyState`(`progressListener`: BackupSteadyStateListener?)
    
    /**
     * Waits for end-to-end encryption initialization tasks to finish, if any
     * was running in the background.
     */
    suspend fun `waitForE2eeInitializationTasks`()
    
    companion object
}

open class Encryption: Disposable, AutoCloseable, EncryptionInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_encryption(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_encryption(pointer!!, status)
        }
    }

    
    /**
     * Does a backup exist on the server?
     *
     * Because the homeserver doesn't notify us about changes to the backup
     * version, the [`BackupState`] and its listener are a bit crippled.
     * The `BackupState::Unknown` state might mean there is no backup at all or
     * a backup exists but we don't have access to it.
     *
     * Therefore it is necessary to poll the server for an answer every time
     * you want to differentiate between those two states.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `backupExistsOnServer`() : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_encryption_backup_exists_on_server(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    override fun `backupState`(): BackupState {
            return FfiConverterTypeBackupState.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_encryption_backup_state(
        it, _status)
}
    }
    )
    }
    

    override fun `backupStateListener`(`listener`: BackupStateListener): TaskHandle {
            return FfiConverterTypeTaskHandle.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_encryption_backup_state_listener(
        it, FfiConverterTypeBackupStateListener.lower(`listener`),_status)
}
    }
    )
    }
    

    
    /**
     * Get the public curve25519 key of our own device in base64. This is
     * usually what is called the identity key of the device.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `curve25519Key`() : kotlin.String? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_encryption_curve25519_key(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalString.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Throws(RecoveryException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `disableRecovery`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_encryption_disable_recovery(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        RecoveryException.ErrorHandler,
    )
    }

    
    /**
     * Get the public ed25519 key of our own device. This is usually what is
     * called the fingerprint of the device.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `ed25519Key`() : kotlin.String? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_encryption_ed25519_key(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalString.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Throws(RecoveryException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `enableBackups`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_encryption_enable_backups(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        RecoveryException.ErrorHandler,
    )
    }

    
    @Throws(RecoveryException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `enableRecovery`(`waitForBackupsToUpload`: kotlin.Boolean, `passphrase`: kotlin.String?, `progressListener`: EnableRecoveryProgressListener) : kotlin.String {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_encryption_enable_recovery(
                thisPtr,
                FfiConverterBoolean.lower(`waitForBackupsToUpload`),FfiConverterOptionalString.lower(`passphrase`),FfiConverterTypeEnableRecoveryProgressListener.lower(`progressListener`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterString.lift(it) },
        // Error FFI converter
        RecoveryException.ErrorHandler,
    )
    }

    
    /**
     * Does the user have other devices that the current device can verify
     * against?
     *
     * The device must be signed by the user's cross-signing key, must have an
     * identity, and must not be a dehydrated device.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `hasDevicesToVerifyAgainst`() : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_encryption_has_devices_to_verify_against(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(RecoveryException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `isLastDevice`() : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_encryption_is_last_device(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        RecoveryException.ErrorHandler,
    )
    }

    
    @Throws(RecoveryException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `recover`(`recoveryKey`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_encryption_recover(
                thisPtr,
                FfiConverterString.lower(`recoveryKey`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        RecoveryException.ErrorHandler,
    )
    }

    
    @Throws(RecoveryException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `recoverAndReset`(`oldRecoveryKey`: kotlin.String) : kotlin.String {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_encryption_recover_and_reset(
                thisPtr,
                FfiConverterString.lower(`oldRecoveryKey`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterString.lift(it) },
        // Error FFI converter
        RecoveryException.ErrorHandler,
    )
    }

    override fun `recoveryState`(): RecoveryState {
            return FfiConverterTypeRecoveryState.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_encryption_recovery_state(
        it, _status)
}
    }
    )
    }
    

    override fun `recoveryStateListener`(`listener`: RecoveryStateListener): TaskHandle {
            return FfiConverterTypeTaskHandle.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_encryption_recovery_state_listener(
        it, FfiConverterTypeRecoveryStateListener.lower(`listener`),_status)
}
    }
    )
    }
    

    
    /**
     * Completely reset the current user's crypto identity: reset the cross
     * signing keys, delete the existing backup and recovery key.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `resetIdentity`() : IdentityResetHandle? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_encryption_reset_identity(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeIdentityResetHandle.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(RecoveryException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `resetRecoveryKey`() : kotlin.String {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_encryption_reset_recovery_key(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterString.lift(it) },
        // Error FFI converter
        RecoveryException.ErrorHandler,
    )
    }

    
    /**
     * Get the E2EE identity of a user.
     *
     * This method always tries to fetch the identity from the store, which we
     * only have if the user is tracked, meaning that we are both members
     * of the same encrypted room. If no user is found locally, a request will
     * be made to the homeserver.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user that the identity belongs to.
     *
     * Returns a `UserIdentity` if one is found. Returns an error if there
     * was an issue with the crypto store or with the request to the
     * homeserver.
     *
     * This will always return `None` if the client hasn't been logged in.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `userIdentity`(`userId`: kotlin.String) : UserIdentity? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_encryption_user_identity(
                thisPtr,
                FfiConverterString.lower(`userId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeUserIdentity.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    override fun `verificationState`(): VerificationState {
            return FfiConverterTypeVerificationState.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_encryption_verification_state(
        it, _status)
}
    }
    )
    }
    

    override fun `verificationStateListener`(`listener`: VerificationStateListener): TaskHandle {
            return FfiConverterTypeTaskHandle.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_encryption_verification_state_listener(
        it, FfiConverterTypeVerificationStateListener.lower(`listener`),_status)
}
    }
    )
    }
    

    
    @Throws(SteadyStateException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `waitForBackupUploadSteadyState`(`progressListener`: BackupSteadyStateListener?) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_encryption_wait_for_backup_upload_steady_state(
                thisPtr,
                FfiConverterOptionalTypeBackupSteadyStateListener.lower(`progressListener`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        SteadyStateException.ErrorHandler,
    )
    }

    
    /**
     * Waits for end-to-end encryption initialization tasks to finish, if any
     * was running in the background.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `waitForE2eeInitializationTasks`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_encryption_wait_for_e2ee_initialization_tasks(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}

public object FfiConverterTypeEncryption: FfiConverter<Encryption, Pointer> {

    override fun lower(value: Encryption): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): Encryption {
        return Encryption(value)
    }

    override fun read(buf: ByteBuffer): Encryption {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Encryption) = 8UL

    override fun write(value: Encryption, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface HomeserverLoginDetailsInterface {
    
    /**
     * The sliding sync version.
     */
    fun `slidingSyncVersion`(): SlidingSyncVersion
    
    /**
     * The prompts advertised by the authentication issuer for use in the login
     * URL.
     */
    fun `supportedOidcPrompts`(): List<OidcPrompt>
    
    /**
     * Whether the current homeserver supports login using OIDC.
     */
    fun `supportsOidcLogin`(): kotlin.Boolean
    
    /**
     * Whether the current homeserver supports the password login flow.
     */
    fun `supportsPasswordLogin`(): kotlin.Boolean
    
    /**
     * Whether the current homeserver supports login using legacy SSO.
     */
    fun `supportsSsoLogin`(): kotlin.Boolean
    
    /**
     * The URL of the currently configured homeserver.
     */
    fun `url`(): kotlin.String
    
    companion object
}

open class HomeserverLoginDetails: Disposable, AutoCloseable, HomeserverLoginDetailsInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_homeserverlogindetails(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_homeserverlogindetails(pointer!!, status)
        }
    }

    
    /**
     * The sliding sync version.
     */override fun `slidingSyncVersion`(): SlidingSyncVersion {
            return FfiConverterTypeSlidingSyncVersion.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_sliding_sync_version(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * The prompts advertised by the authentication issuer for use in the login
     * URL.
     */override fun `supportedOidcPrompts`(): List<OidcPrompt> {
            return FfiConverterSequenceTypeOidcPrompt.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supported_oidc_prompts(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Whether the current homeserver supports login using OIDC.
     */override fun `supportsOidcLogin`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_oidc_login(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Whether the current homeserver supports the password login flow.
     */override fun `supportsPasswordLogin`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_password_login(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Whether the current homeserver supports login using legacy SSO.
     */override fun `supportsSsoLogin`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_sso_login(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * The URL of the currently configured homeserver.
     */override fun `url`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_url(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

public object FfiConverterTypeHomeserverLoginDetails: FfiConverter<HomeserverLoginDetails, Pointer> {

    override fun lower(value: HomeserverLoginDetails): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): HomeserverLoginDetails {
        return HomeserverLoginDetails(value)
    }

    override fun read(buf: ByteBuffer): HomeserverLoginDetails {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: HomeserverLoginDetails) = 8UL

    override fun write(value: HomeserverLoginDetails, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface IdentityResetHandleInterface {
    
    /**
     * Get the underlying [`CrossSigningResetAuthType`] this identity reset
     * process is using.
     */
    fun `authType`(): CrossSigningResetAuthType
    
    suspend fun `cancel`()
    
    /**
     * This method starts the identity reset process and
     * will go through the following steps:
     *
     * 1. Disable backing up room keys and delete the active backup
     * 2. Disable recovery and delete secret storage
     * 3. Go through the cross-signing key reset flow
     * 4. Finally, re-enable key backups only if they were enabled before
     */
    suspend fun `reset`(`auth`: AuthData?)
    
    companion object
}

open class IdentityResetHandle: Disposable, AutoCloseable, IdentityResetHandleInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_identityresethandle(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_identityresethandle(pointer!!, status)
        }
    }

    
    /**
     * Get the underlying [`CrossSigningResetAuthType`] this identity reset
     * process is using.
     */override fun `authType`(): CrossSigningResetAuthType {
            return FfiConverterTypeCrossSigningResetAuthType.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_identityresethandle_auth_type(
        it, _status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `cancel`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_identityresethandle_cancel(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * This method starts the identity reset process and
     * will go through the following steps:
     *
     * 1. Disable backing up room keys and delete the active backup
     * 2. Disable recovery and delete secret storage
     * 3. Go through the cross-signing key reset flow
     * 4. Finally, re-enable key backups only if they were enabled before
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `reset`(`auth`: AuthData?) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_identityresethandle_reset(
                thisPtr,
                FfiConverterOptionalTypeAuthData.lower(`auth`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    

    
    
    companion object
    
}

public object FfiConverterTypeIdentityResetHandle: FfiConverter<IdentityResetHandle, Pointer> {

    override fun lower(value: IdentityResetHandle): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): IdentityResetHandle {
        return IdentityResetHandle(value)
    }

    override fun read(buf: ByteBuffer): IdentityResetHandle {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: IdentityResetHandle) = 8UL

    override fun write(value: IdentityResetHandle, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface InReplyToDetailsInterface {
    
    fun `event`(): EmbeddedEventDetails
    
    fun `eventId`(): kotlin.String
    
    companion object
}

open class InReplyToDetails: Disposable, AutoCloseable, InReplyToDetailsInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_inreplytodetails(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_inreplytodetails(pointer!!, status)
        }
    }

    override fun `event`(): EmbeddedEventDetails {
            return FfiConverterTypeEmbeddedEventDetails.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_inreplytodetails_event(
        it, _status)
}
    }
    )
    }
    

    override fun `eventId`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_inreplytodetails_event_id(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

public object FfiConverterTypeInReplyToDetails: FfiConverter<InReplyToDetails, Pointer> {

    override fun lower(value: InReplyToDetails): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): InReplyToDetails {
        return InReplyToDetails(value)
    }

    override fun read(buf: ByteBuffer): InReplyToDetails {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: InReplyToDetails) = 8UL

    override fun write(value: InReplyToDetails, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * A set of actions to perform for a knock request.
 */
public interface KnockRequestActionsInterface {
    
    /**
     * Accepts the knock request by inviting the user to the room.
     */
    suspend fun `accept`()
    
    /**
     * Declines the knock request by kicking the user from the room with an
     * optional reason.
     */
    suspend fun `decline`(`reason`: kotlin.String?)
    
    /**
     * Declines the knock request by banning the user from the room with an
     * optional reason.
     */
    suspend fun `declineAndBan`(`reason`: kotlin.String?)
    
    /**
     * Marks the knock request as 'seen'.
     *
     * **IMPORTANT**: this won't update the current reference to this request,
     * a new one with the updated value should be emitted instead.
     */
    suspend fun `markAsSeen`()
    
    companion object
}

/**
 * A set of actions to perform for a knock request.
 */
open class KnockRequestActions: Disposable, AutoCloseable, KnockRequestActionsInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_knockrequestactions(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_knockrequestactions(pointer!!, status)
        }
    }

    
    /**
     * Accepts the knock request by inviting the user to the room.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `accept`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_accept(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Declines the knock request by kicking the user from the room with an
     * optional reason.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `decline`(`reason`: kotlin.String?) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_decline(
                thisPtr,
                FfiConverterOptionalString.lower(`reason`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Declines the knock request by banning the user from the room with an
     * optional reason.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `declineAndBan`(`reason`: kotlin.String?) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_decline_and_ban(
                thisPtr,
                FfiConverterOptionalString.lower(`reason`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Marks the knock request as 'seen'.
     *
     * **IMPORTANT**: this won't update the current reference to this request,
     * a new one with the updated value should be emitted instead.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `markAsSeen`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_mark_as_seen(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    

    
    
    companion object
    
}

public object FfiConverterTypeKnockRequestActions: FfiConverter<KnockRequestActions, Pointer> {

    override fun lower(value: KnockRequestActions): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): KnockRequestActions {
        return KnockRequestActions(value)
    }

    override fun read(buf: ByteBuffer): KnockRequestActions {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: KnockRequestActions) = 8UL

    override fun write(value: KnockRequestActions, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * Wrapper to retrieve some timeline item info lazily.
 */
public interface LazyTimelineItemProviderInterface {
    
    fun `containsOnlyEmojis`(): kotlin.Boolean
    
    /**
     * Returns some debug information for this event timeline item.
     */
    fun `debugInfo`(): EventTimelineItemDebugInfo
    
    /**
     * For local echoes, return the associated send handle; returns `None` for
     * remote echoes.
     */
    fun `getSendHandle`(): SendHandle?
    
    /**
     * Returns the shields for this event timeline item.
     */
    fun `getShields`(`strict`: kotlin.Boolean): ShieldState?
    
    companion object
}

/**
 * Wrapper to retrieve some timeline item info lazily.
 */
open class LazyTimelineItemProvider: Disposable, AutoCloseable, LazyTimelineItemProviderInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_lazytimelineitemprovider(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_lazytimelineitemprovider(pointer!!, status)
        }
    }

    override fun `containsOnlyEmojis`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_contains_only_emojis(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Returns some debug information for this event timeline item.
     */override fun `debugInfo`(): EventTimelineItemDebugInfo {
            return FfiConverterTypeEventTimelineItemDebugInfo.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_debug_info(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * For local echoes, return the associated send handle; returns `None` for
     * remote echoes.
     */override fun `getSendHandle`(): SendHandle? {
            return FfiConverterOptionalTypeSendHandle.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_get_send_handle(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Returns the shields for this event timeline item.
     */override fun `getShields`(`strict`: kotlin.Boolean): ShieldState? {
            return FfiConverterOptionalTypeShieldState.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_get_shields(
        it, FfiConverterBoolean.lower(`strict`),_status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

public object FfiConverterTypeLazyTimelineItemProvider: FfiConverter<LazyTimelineItemProvider, Pointer> {

    override fun lower(value: LazyTimelineItemProvider): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): LazyTimelineItemProvider {
        return LazyTimelineItemProvider(value)
    }

    override fun read(buf: ByteBuffer): LazyTimelineItemProvider {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: LazyTimelineItemProvider) = 8UL

    override fun write(value: LazyTimelineItemProvider, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * The `LeaveSpaceHandle` processes rooms to be left in the order they were
 * provided by the [`SpaceService`] and annotates them with extra data to
 * inform the leave process e.g. if the current user is the last room admin.
 *
 * Once the upstream client decides what rooms should actually be left, the
 * handle provides a method to execute that too.
 */
public interface LeaveSpaceHandleInterface {
    
    /**
     * Bulk leave the given rooms. Stops when encountering an error.
     */
    suspend fun `leave`(`roomIds`: List<kotlin.String>)
    
    /**
     * A list of rooms to be left which next to normal [`SpaceRoom`] data also
     * include leave specific information.
     */
    fun `rooms`(): List<LeaveSpaceRoom>
    
    companion object
}

/**
 * The `LeaveSpaceHandle` processes rooms to be left in the order they were
 * provided by the [`SpaceService`] and annotates them with extra data to
 * inform the leave process e.g. if the current user is the last room admin.
 *
 * Once the upstream client decides what rooms should actually be left, the
 * handle provides a method to execute that too.
 */
open class LeaveSpaceHandle: Disposable, AutoCloseable, LeaveSpaceHandleInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_leavespacehandle(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_leavespacehandle(pointer!!, status)
        }
    }

    
    /**
     * Bulk leave the given rooms. Stops when encountering an error.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `leave`(`roomIds`: List<kotlin.String>) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_leavespacehandle_leave(
                thisPtr,
                FfiConverterSequenceString.lower(`roomIds`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * A list of rooms to be left which next to normal [`SpaceRoom`] data also
     * include leave specific information.
     */override fun `rooms`(): List<LeaveSpaceRoom> {
            return FfiConverterSequenceTypeLeaveSpaceRoom.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_leavespacehandle_rooms(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

public object FfiConverterTypeLeaveSpaceHandle: FfiConverter<LeaveSpaceHandle, Pointer> {

    override fun lower(value: LeaveSpaceHandle): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): LeaveSpaceHandle {
        return LeaveSpaceHandle(value)
    }

    override fun read(buf: ByteBuffer): LeaveSpaceHandle {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: LeaveSpaceHandle) = 8UL

    override fun write(value: LeaveSpaceHandle, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * Handler for logging in with a QR code.
 */
public interface LoginWithQrCodeHandlerInterface {
    
    /**
     * This method allows you to log in by generating a QR code.
     *
     * This device needs to call this method and handle its progress updates to
     * generate a QR code which the existing device can scan and grant the
     * log in.
     *
     * This method uses the login mechanism described in [MSC4108]. As such,
     * it requires OAuth 2.0 support as well as Sliding Sync support.
     *
     * For the reverse flow where the existing device generates the QR code
     * for this device to scan, use [`LoginWithQrCodeHandler::scan`].
     *
     * # Arguments
     *
     * * `progress_listener` - A progress listener that must also be used to
     * obtain the [`QrCodeData`] and collect the [`CheckCode`] from the user.
     *
     * [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
     */
    suspend fun `generate`(`progressListener`: GeneratedQrLoginProgressListener)
    
    /**
     * This method allows you to log in with a scanned QR code.
     *
     * The existing device needs to display the QR code which this device can
     * scan, call this method and handle its progress updates to log in.
     *
     * For the login to succeed, the [`Client`] associated with the
     * [`LoginWithQrCodeHandler`] must have been built with
     * [`QrCodeData::server_name`] as the server name.
     *
     * This method uses the login mechanism described in [MSC4108]. As such,
     * it requires OAuth 2.0 support as well as Sliding Sync support.
     *
     * For the reverse flow where this device generates the QR code for the
     * existing device to scan, use [`LoginWithQrCodeHandler::generate`].
     *
     * # Arguments
     *
     * * `qr_code_data` - The [`QrCodeData`] scanned from the QR code.
     * * `progress_listener` - A progress listener that must also be used to
     * transfer the [`CheckCode`] to the existing device.
     *
     * [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
     */
    suspend fun `scan`(`qrCodeData`: QrCodeData, `progressListener`: QrLoginProgressListener)
    
    companion object
}

/**
 * Handler for logging in with a QR code.
 */
open class LoginWithQrCodeHandler: Disposable, AutoCloseable, LoginWithQrCodeHandlerInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_loginwithqrcodehandler(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_loginwithqrcodehandler(pointer!!, status)
        }
    }

    
    /**
     * This method allows you to log in by generating a QR code.
     *
     * This device needs to call this method and handle its progress updates to
     * generate a QR code which the existing device can scan and grant the
     * log in.
     *
     * This method uses the login mechanism described in [MSC4108]. As such,
     * it requires OAuth 2.0 support as well as Sliding Sync support.
     *
     * For the reverse flow where the existing device generates the QR code
     * for this device to scan, use [`LoginWithQrCodeHandler::scan`].
     *
     * # Arguments
     *
     * * `progress_listener` - A progress listener that must also be used to
     * obtain the [`QrCodeData`] and collect the [`CheckCode`] from the user.
     *
     * [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
     */
    @Throws(HumanQrLoginException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `generate`(`progressListener`: GeneratedQrLoginProgressListener) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_loginwithqrcodehandler_generate(
                thisPtr,
                FfiConverterTypeGeneratedQrLoginProgressListener.lower(`progressListener`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        HumanQrLoginException.ErrorHandler,
    )
    }

    
    /**
     * This method allows you to log in with a scanned QR code.
     *
     * The existing device needs to display the QR code which this device can
     * scan, call this method and handle its progress updates to log in.
     *
     * For the login to succeed, the [`Client`] associated with the
     * [`LoginWithQrCodeHandler`] must have been built with
     * [`QrCodeData::server_name`] as the server name.
     *
     * This method uses the login mechanism described in [MSC4108]. As such,
     * it requires OAuth 2.0 support as well as Sliding Sync support.
     *
     * For the reverse flow where this device generates the QR code for the
     * existing device to scan, use [`LoginWithQrCodeHandler::generate`].
     *
     * # Arguments
     *
     * * `qr_code_data` - The [`QrCodeData`] scanned from the QR code.
     * * `progress_listener` - A progress listener that must also be used to
     * transfer the [`CheckCode`] to the existing device.
     *
     * [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
     */
    @Throws(HumanQrLoginException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `scan`(`qrCodeData`: QrCodeData, `progressListener`: QrLoginProgressListener) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_loginwithqrcodehandler_scan(
                thisPtr,
                FfiConverterTypeQrCodeData.lower(`qrCodeData`),FfiConverterTypeQrLoginProgressListener.lower(`progressListener`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        HumanQrLoginException.ErrorHandler,
    )
    }

    

    
    
    companion object
    
}

public object FfiConverterTypeLoginWithQrCodeHandler: FfiConverter<LoginWithQrCodeHandler, Pointer> {

    override fun lower(value: LoginWithQrCodeHandler): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): LoginWithQrCodeHandler {
        return LoginWithQrCodeHandler(value)
    }

    override fun read(buf: ByteBuffer): LoginWithQrCodeHandler {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: LoginWithQrCodeHandler) = 8UL

    override fun write(value: LoginWithQrCodeHandler, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * A file handle that takes ownership of a media file on disk. When the handle
 * is dropped, the file will be removed from the disk.
 */
public interface MediaFileHandleInterface {
    
    /**
     * Get the media file's path.
     */
    fun `path`(): kotlin.String
    
    fun `persist`(`path`: kotlin.String): kotlin.Boolean
    
    companion object
}

/**
 * A file handle that takes ownership of a media file on disk. When the handle
 * is dropped, the file will be removed from the disk.
 */
open class MediaFileHandle: Disposable, AutoCloseable, MediaFileHandleInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_mediafilehandle(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_mediafilehandle(pointer!!, status)
        }
    }

    
    /**
     * Get the media file's path.
     */
    @Throws(ClientException::class)override fun `path`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_mediafilehandle_path(
        it, _status)
}
    }
    )
    }
    

    
    @Throws(ClientException::class)override fun `persist`(`path`: kotlin.String): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_mediafilehandle_persist(
        it, FfiConverterString.lower(`path`),_status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

public object FfiConverterTypeMediaFileHandle: FfiConverter<MediaFileHandle, Pointer> {

    override fun lower(value: MediaFileHandle): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): MediaFileHandle {
        return MediaFileHandle(value)
    }

    override fun read(buf: ByteBuffer): MediaFileHandle {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: MediaFileHandle) = 8UL

    override fun write(value: MediaFileHandle, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface MediaSourceInterface {
    
    fun `toJson`(): kotlin.String
    
    fun `url`(): kotlin.String
    
    companion object
}

open class MediaSource: Disposable, AutoCloseable, MediaSourceInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_mediasource(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_mediasource(pointer!!, status)
        }
    }

    override fun `toJson`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_mediasource_to_json(
        it, _status)
}
    }
    )
    }
    

    override fun `url`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_mediasource_url(
        it, _status)
}
    }
    )
    }
    

    

    
    companion object {
        
    @Throws(ClientException::class) fun `fromJson`(`json`: kotlin.String): MediaSource {
            return FfiConverterTypeMediaSource.lift(
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_constructor_mediasource_from_json(
        FfiConverterString.lower(`json`),_status)
}
    )
    }
    

        
    @Throws(ClientException::class) fun `fromUrl`(`url`: kotlin.String): MediaSource {
            return FfiConverterTypeMediaSource.lift(
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_constructor_mediasource_from_url(
        FfiConverterString.lower(`url`),_status)
}
    )
    }
    

        
    }
    
}

public object FfiConverterTypeMediaSource: FfiConverter<MediaSource, Pointer> {

    override fun lower(value: MediaSource): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): MediaSource {
        return MediaSource(value)
    }

    override fun read(buf: ByteBuffer): MediaSource {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: MediaSource) = 8UL

    override fun write(value: MediaSource, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface NotificationClientInterface {
    
    /**
     * Fetches the content of a notification.
     *
     * This will first try to get the notification using a short-lived sliding
     * sync, and if the sliding-sync can't find the event, then it'll use a
     * `/context` query to find the event with associated member information.
     *
     * An error result means that we couldn't resolve the notification; in that
     * case, a dummy notification may be displayed instead.
     */
    suspend fun `getNotification`(`roomId`: kotlin.String, `eventId`: kotlin.String): NotificationStatus
    
    /**
     * Get several notification items in a single batch.
     *
     * Returns an error if the flow failed when preparing to fetch the
     * notifications, and a [`HashMap`] containing either a
     * [`BatchNotificationResult`], that indicates if the notification was
     * successfully fetched (in which case, it's a [`NotificationStatus`]), or
     * an error message if it couldn't be fetched.
     */
    suspend fun `getNotifications`(`requests`: List<NotificationItemsRequest>): Map<kotlin.String, BatchNotificationResult>
    
    /**
     * Fetches a room by its ID using the in-memory state store backed client.
     *
     * Useful to retrieve room information after running the limited
     * notification client sliding sync loop.
     */
    fun `getRoom`(`roomId`: kotlin.String): Room?
    
    companion object
}

open class NotificationClient: Disposable, AutoCloseable, NotificationClientInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_notificationclient(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_notificationclient(pointer!!, status)
        }
    }

    
    /**
     * Fetches the content of a notification.
     *
     * This will first try to get the notification using a short-lived sliding
     * sync, and if the sliding-sync can't find the event, then it'll use a
     * `/context` query to find the event with associated member information.
     *
     * An error result means that we couldn't resolve the notification; in that
     * case, a dummy notification may be displayed instead.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getNotification`(`roomId`: kotlin.String, `eventId`: kotlin.String) : NotificationStatus {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_notificationclient_get_notification(
                thisPtr,
                FfiConverterString.lower(`roomId`),FfiConverterString.lower(`eventId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeNotificationStatus.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Get several notification items in a single batch.
     *
     * Returns an error if the flow failed when preparing to fetch the
     * notifications, and a [`HashMap`] containing either a
     * [`BatchNotificationResult`], that indicates if the notification was
     * successfully fetched (in which case, it's a [`NotificationStatus`]), or
     * an error message if it couldn't be fetched.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getNotifications`(`requests`: List<NotificationItemsRequest>) : Map<kotlin.String, BatchNotificationResult> {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_notificationclient_get_notifications(
                thisPtr,
                FfiConverterSequenceTypeNotificationItemsRequest.lower(`requests`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterMapStringTypeBatchNotificationResult.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Fetches a room by its ID using the in-memory state store backed client.
     *
     * Useful to retrieve room information after running the limited
     * notification client sliding sync loop.
     */
    @Throws(ClientException::class)override fun `getRoom`(`roomId`: kotlin.String): Room? {
            return FfiConverterOptionalTypeRoom.lift(
    callWithPointer {
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_notificationclient_get_room(
        it, FfiConverterString.lower(`roomId`),_status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

public object FfiConverterTypeNotificationClient: FfiConverter<NotificationClient, Pointer> {

    override fun lower(value: NotificationClient): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): NotificationClient {
        return NotificationClient(value)
    }

    override fun read(buf: ByteBuffer): NotificationClient {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: NotificationClient) = 8UL

    override fun write(value: NotificationClient, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface NotificationSettingsInterface {
    
    /**
     * Check whether [MSC 4028 push rule][rule] is enabled on the homeserver.
     *
     * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
     */
    suspend fun `canHomeserverPushEncryptedEventToDevice`(): kotlin.Boolean
    
    /**
     * Returns true if [MSC 4028 push rule][rule] is supported and enabled.
     *
     * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
     */
    suspend fun `canPushEncryptedEventToDevice`(): kotlin.Boolean
    
    /**
     * Get whether some enabled keyword rules exist.
     */
    suspend fun `containsKeywordsRules`(): kotlin.Boolean
    
    /**
     * Get the default room notification mode
     *
     * The mode will depend on the associated `PushRule` based on whether the
     * room is encrypted or not, and on the number of members.
     *
     * # Arguments
     *
     * * `is_encrypted` - whether the room is encrypted
     * * `is_one_to_one` - whether the room is a direct chats involving two
     * people
     */
    suspend fun `getDefaultRoomNotificationMode`(`isEncrypted`: kotlin.Boolean, `isOneToOne`: kotlin.Boolean): RoomNotificationMode
    
    /**
     * Returns the raw push rules in JSON format.
     */
    suspend fun `getRawPushRules`(): kotlin.String?
    
    /**
     * Get the notification settings for a room.
     *
     * # Arguments
     *
     * * `room_id` - the room ID
     * * `is_encrypted` - whether the room is encrypted
     * * `is_one_to_one` - whether the room is a direct chat involving two
     * people
     */
    suspend fun `getRoomNotificationSettings`(`roomId`: kotlin.String, `isEncrypted`: kotlin.Boolean, `isOneToOne`: kotlin.Boolean): RoomNotificationSettings
    
    /**
     * Get all room IDs for which a user-defined rule exists.
     */
    suspend fun `getRoomsWithUserDefinedRules`(`enabled`: kotlin.Boolean?): List<kotlin.String>
    
    /**
     * Get the user defined room notification mode
     */
    suspend fun `getUserDefinedRoomNotificationMode`(`roomId`: kotlin.String): RoomNotificationMode?
    
    /**
     * Get whether the `.m.rule.call` push rule is enabled
     */
    suspend fun `isCallEnabled`(): kotlin.Boolean
    
    /**
     * Get whether the `.m.rule.invite_for_me` push rule is enabled
     */
    suspend fun `isInviteForMeEnabled`(): kotlin.Boolean
    
    /**
     * Get whether room mentions are enabled.
     */
    suspend fun `isRoomMentionEnabled`(): kotlin.Boolean
    
    /**
     * Get whether user mentions are enabled.
     */
    suspend fun `isUserMentionEnabled`(): kotlin.Boolean
    
    /**
     * Restore the default notification mode for a room
     */
    suspend fun `restoreDefaultRoomNotificationMode`(`roomId`: kotlin.String)
    
    /**
     * Set whether the `.m.rule.call` push rule is enabled
     */
    suspend fun `setCallEnabled`(`enabled`: kotlin.Boolean)
    
    /**
     * Sets a custom push rule with the given actions and conditions.
     */
    suspend fun `setCustomPushRule`(`ruleId`: kotlin.String, `ruleKind`: RuleKind, `actions`: List<Action>, `conditions`: List<PushCondition>)
    
    /**
     * Set the default room notification mode
     *
     * # Arguments
     *
     * * `is_encrypted` - whether the mode is for encrypted rooms
     * * `is_one_to_one` - whether the mode is for direct chats involving two
     * people
     * * `mode` - the new default mode
     */
    suspend fun `setDefaultRoomNotificationMode`(`isEncrypted`: kotlin.Boolean, `isOneToOne`: kotlin.Boolean, `mode`: RoomNotificationMode)
    
    fun `setDelegate`(`delegate`: NotificationSettingsDelegate?)
    
    /**
     * Set whether the `.m.rule.invite_for_me` push rule is enabled
     */
    suspend fun `setInviteForMeEnabled`(`enabled`: kotlin.Boolean)
    
    /**
     * Set whether room mentions are enabled.
     */
    suspend fun `setRoomMentionEnabled`(`enabled`: kotlin.Boolean)
    
    /**
     * Set the notification mode for a room.
     */
    suspend fun `setRoomNotificationMode`(`roomId`: kotlin.String, `mode`: RoomNotificationMode)
    
    /**
     * Set whether user mentions are enabled.
     */
    suspend fun `setUserMentionEnabled`(`enabled`: kotlin.Boolean)
    
    /**
     * Unmute a room.
     *
     * # Arguments
     *
     * * `room_id` - the room to unmute
     * * `is_encrypted` - whether the room is encrypted
     * * `is_one_to_one` - whether the room is a direct chat involving two
     * people
     */
    suspend fun `unmuteRoom`(`roomId`: kotlin.String, `isEncrypted`: kotlin.Boolean, `isOneToOne`: kotlin.Boolean)
    
    companion object
}

open class NotificationSettings: Disposable, AutoCloseable, NotificationSettingsInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_notificationsettings(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_notificationsettings(pointer!!, status)
        }
    }

    
    /**
     * Check whether [MSC 4028 push rule][rule] is enabled on the homeserver.
     *
     * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `canHomeserverPushEncryptedEventToDevice`() : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_can_homeserver_push_encrypted_event_to_device(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Returns true if [MSC 4028 push rule][rule] is supported and enabled.
     *
     * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `canPushEncryptedEventToDevice`() : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_can_push_encrypted_event_to_device(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Get whether some enabled keyword rules exist.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `containsKeywordsRules`() : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_contains_keywords_rules(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Get the default room notification mode
     *
     * The mode will depend on the associated `PushRule` based on whether the
     * room is encrypted or not, and on the number of members.
     *
     * # Arguments
     *
     * * `is_encrypted` - whether the room is encrypted
     * * `is_one_to_one` - whether the room is a direct chats involving two
     * people
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getDefaultRoomNotificationMode`(`isEncrypted`: kotlin.Boolean, `isOneToOne`: kotlin.Boolean) : RoomNotificationMode {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_default_room_notification_mode(
                thisPtr,
                FfiConverterBoolean.lower(`isEncrypted`),FfiConverterBoolean.lower(`isOneToOne`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeRoomNotificationMode.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Returns the raw push rules in JSON format.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getRawPushRules`() : kotlin.String? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_raw_push_rules(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalString.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Get the notification settings for a room.
     *
     * # Arguments
     *
     * * `room_id` - the room ID
     * * `is_encrypted` - whether the room is encrypted
     * * `is_one_to_one` - whether the room is a direct chat involving two
     * people
     */
    @Throws(NotificationSettingsException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getRoomNotificationSettings`(`roomId`: kotlin.String, `isEncrypted`: kotlin.Boolean, `isOneToOne`: kotlin.Boolean) : RoomNotificationSettings {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_room_notification_settings(
                thisPtr,
                FfiConverterString.lower(`roomId`),FfiConverterBoolean.lower(`isEncrypted`),FfiConverterBoolean.lower(`isOneToOne`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeRoomNotificationSettings.lift(it) },
        // Error FFI converter
        NotificationSettingsException.ErrorHandler,
    )
    }

    
    /**
     * Get all room IDs for which a user-defined rule exists.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getRoomsWithUserDefinedRules`(`enabled`: kotlin.Boolean?) : List<kotlin.String> {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_rooms_with_user_defined_rules(
                thisPtr,
                FfiConverterOptionalBoolean.lower(`enabled`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterSequenceString.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Get the user defined room notification mode
     */
    @Throws(NotificationSettingsException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getUserDefinedRoomNotificationMode`(`roomId`: kotlin.String) : RoomNotificationMode? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_user_defined_room_notification_mode(
                thisPtr,
                FfiConverterString.lower(`roomId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeRoomNotificationMode.lift(it) },
        // Error FFI converter
        NotificationSettingsException.ErrorHandler,
    )
    }

    
    /**
     * Get whether the `.m.rule.call` push rule is enabled
     */
    @Throws(NotificationSettingsException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `isCallEnabled`() : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_call_enabled(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        NotificationSettingsException.ErrorHandler,
    )
    }

    
    /**
     * Get whether the `.m.rule.invite_for_me` push rule is enabled
     */
    @Throws(NotificationSettingsException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `isInviteForMeEnabled`() : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_invite_for_me_enabled(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        NotificationSettingsException.ErrorHandler,
    )
    }

    
    /**
     * Get whether room mentions are enabled.
     */
    @Throws(NotificationSettingsException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `isRoomMentionEnabled`() : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_room_mention_enabled(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        NotificationSettingsException.ErrorHandler,
    )
    }

    
    /**
     * Get whether user mentions are enabled.
     */
    @Throws(NotificationSettingsException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `isUserMentionEnabled`() : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_user_mention_enabled(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        NotificationSettingsException.ErrorHandler,
    )
    }

    
    /**
     * Restore the default notification mode for a room
     */
    @Throws(NotificationSettingsException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `restoreDefaultRoomNotificationMode`(`roomId`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_restore_default_room_notification_mode(
                thisPtr,
                FfiConverterString.lower(`roomId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        NotificationSettingsException.ErrorHandler,
    )
    }

    
    /**
     * Set whether the `.m.rule.call` push rule is enabled
     */
    @Throws(NotificationSettingsException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setCallEnabled`(`enabled`: kotlin.Boolean) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_call_enabled(
                thisPtr,
                FfiConverterBoolean.lower(`enabled`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        NotificationSettingsException.ErrorHandler,
    )
    }

    
    /**
     * Sets a custom push rule with the given actions and conditions.
     */
    @Throws(NotificationSettingsException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setCustomPushRule`(`ruleId`: kotlin.String, `ruleKind`: RuleKind, `actions`: List<Action>, `conditions`: List<PushCondition>) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_custom_push_rule(
                thisPtr,
                FfiConverterString.lower(`ruleId`),FfiConverterTypeRuleKind.lower(`ruleKind`),FfiConverterSequenceTypeAction.lower(`actions`),FfiConverterSequenceTypePushCondition.lower(`conditions`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        NotificationSettingsException.ErrorHandler,
    )
    }

    
    /**
     * Set the default room notification mode
     *
     * # Arguments
     *
     * * `is_encrypted` - whether the mode is for encrypted rooms
     * * `is_one_to_one` - whether the mode is for direct chats involving two
     * people
     * * `mode` - the new default mode
     */
    @Throws(NotificationSettingsException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setDefaultRoomNotificationMode`(`isEncrypted`: kotlin.Boolean, `isOneToOne`: kotlin.Boolean, `mode`: RoomNotificationMode) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_default_room_notification_mode(
                thisPtr,
                FfiConverterBoolean.lower(`isEncrypted`),FfiConverterBoolean.lower(`isOneToOne`),FfiConverterTypeRoomNotificationMode.lower(`mode`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        NotificationSettingsException.ErrorHandler,
    )
    }

    override fun `setDelegate`(`delegate`: NotificationSettingsDelegate?)
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_delegate(
        it, FfiConverterOptionalTypeNotificationSettingsDelegate.lower(`delegate`),_status)
}
    }
    
    

    
    /**
     * Set whether the `.m.rule.invite_for_me` push rule is enabled
     */
    @Throws(NotificationSettingsException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setInviteForMeEnabled`(`enabled`: kotlin.Boolean) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_invite_for_me_enabled(
                thisPtr,
                FfiConverterBoolean.lower(`enabled`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        NotificationSettingsException.ErrorHandler,
    )
    }

    
    /**
     * Set whether room mentions are enabled.
     */
    @Throws(NotificationSettingsException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setRoomMentionEnabled`(`enabled`: kotlin.Boolean) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_room_mention_enabled(
                thisPtr,
                FfiConverterBoolean.lower(`enabled`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        NotificationSettingsException.ErrorHandler,
    )
    }

    
    /**
     * Set the notification mode for a room.
     */
    @Throws(NotificationSettingsException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setRoomNotificationMode`(`roomId`: kotlin.String, `mode`: RoomNotificationMode) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_room_notification_mode(
                thisPtr,
                FfiConverterString.lower(`roomId`),FfiConverterTypeRoomNotificationMode.lower(`mode`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        NotificationSettingsException.ErrorHandler,
    )
    }

    
    /**
     * Set whether user mentions are enabled.
     */
    @Throws(NotificationSettingsException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setUserMentionEnabled`(`enabled`: kotlin.Boolean) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_user_mention_enabled(
                thisPtr,
                FfiConverterBoolean.lower(`enabled`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        NotificationSettingsException.ErrorHandler,
    )
    }

    
    /**
     * Unmute a room.
     *
     * # Arguments
     *
     * * `room_id` - the room to unmute
     * * `is_encrypted` - whether the room is encrypted
     * * `is_one_to_one` - whether the room is a direct chat involving two
     * people
     */
    @Throws(NotificationSettingsException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `unmuteRoom`(`roomId`: kotlin.String, `isEncrypted`: kotlin.Boolean, `isOneToOne`: kotlin.Boolean) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_unmute_room(
                thisPtr,
                FfiConverterString.lower(`roomId`),FfiConverterBoolean.lower(`isEncrypted`),FfiConverterBoolean.lower(`isOneToOne`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        NotificationSettingsException.ErrorHandler,
    )
    }

    

    
    
    companion object
    
}

public object FfiConverterTypeNotificationSettings: FfiConverter<NotificationSettings, Pointer> {

    override fun lower(value: NotificationSettings): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): NotificationSettings {
        return NotificationSettings(value)
    }

    override fun read(buf: ByteBuffer): NotificationSettings {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: NotificationSettings) = 8UL

    override fun write(value: NotificationSettings, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * Data for the QR code login mechanism.
 *
 * The [`QrCodeData`] can be serialized and encoded as a QR code or it can be
 * decoded from a QR code.
 */
public interface QrCodeDataInterface {
    
    /**
     * The server name contained within the scanned QR code data.
     *
     * Note: This value is only present when scanning a QR code the belongs to
     * a logged in client. The mode where the new client shows the QR code
     * will return `None`.
     */
    fun `serverName`(): kotlin.String?
    
    companion object
}

/**
 * Data for the QR code login mechanism.
 *
 * The [`QrCodeData`] can be serialized and encoded as a QR code or it can be
 * decoded from a QR code.
 */
open class QrCodeData: Disposable, AutoCloseable, QrCodeDataInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_qrcodedata(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_qrcodedata(pointer!!, status)
        }
    }

    
    /**
     * The server name contained within the scanned QR code data.
     *
     * Note: This value is only present when scanning a QR code the belongs to
     * a logged in client. The mode where the new client shows the QR code
     * will return `None`.
     */override fun `serverName`(): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_qrcodedata_server_name(
        it, _status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Attempt to decode a slice of bytes into a [`QrCodeData`] object.
     *
     * The slice of bytes would generally be returned by a QR code decoder.
     */
    @Throws(QrCodeDecodeException::class) fun `fromBytes`(`bytes`: kotlin.ByteArray): QrCodeData {
            return FfiConverterTypeQrCodeData.lift(
    uniffiRustCallWithError(QrCodeDecodeException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_constructor_qrcodedata_from_bytes(
        FfiConverterByteArray.lower(`bytes`),_status)
}
    )
    }
    

        
    }
    
}

public object FfiConverterTypeQrCodeData: FfiConverter<QrCodeData, Pointer> {

    override fun lower(value: QrCodeData): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): QrCodeData {
        return QrCodeData(value)
    }

    override fun read(buf: ByteBuffer): QrCodeData {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: QrCodeData) = 8UL

    override fun write(value: QrCodeData, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface RoomInterface {
    
    fun `activeMembersCount`(): kotlin.ULong
    
    /**
     * Returns a Vec of userId's that participate in the room call.
     *
     * MatrixRTC memberships with application "m.call" and scope "m.room" are
     * considered. A user can occur twice if they join with two devices.
     * convert to a set depending if the different users are required or the
     * amount of sessions.
     *
     * The vector is ordered by oldest membership user to newest.
     */
    fun `activeRoomCallParticipants`(): List<kotlin.String>
    
    fun `alternativeAliases`(): List<kotlin.String>
    
    suspend fun `applyPowerLevelChanges`(`changes`: RoomPowerLevelChanges)
    
    fun `avatarUrl`(): kotlin.String?
    
    suspend fun `banUser`(`userId`: kotlin.String, `reason`: kotlin.String?)
    
    fun `canonicalAlias`(): kotlin.String?
    
    /**
     * Remove the `ComposerDraft` stored in the state store for this room.
     */
    suspend fun `clearComposerDraft`(`threadRoot`: kotlin.String?)
    
    /**
     * Clear the event cache storage for the current room.
     *
     * This will remove all the information related to the event cache, in
     * memory and in the persisted storage, if enabled.
     */
    suspend fun `clearEventCacheStorage`()
    
    /**
     * Declines a call (and stop ringing).
     *
     * # Arguments
     *
     * * `rtc_notification_event_id` - the event id of the m.rtc.notification
     * event.
     */
    suspend fun `declineCall`(`rtcNotificationEventId`: kotlin.String)
    
    /**
     * Forces the currently active room key, which is used to encrypt messages,
     * to be rotated.
     *
     * A new room key will be crated and shared with all the room members the
     * next time a message will be sent. You don't have to call this method,
     * room keys will be rotated automatically when necessary. This method is
     * still useful for debugging purposes.
     */
    suspend fun `discardRoomKey`()
    
    /**
     * Returns the room's name from the state event if available, otherwise
     * compute a room name based on the room's nature (DM or not) and number of
     * members.
     */
    fun `displayName`(): kotlin.String?
    
    /**
     * Edit an event given its event id.
     *
     * Useful outside the context of a timeline, or when a timeline doesn't
     * have the full content of an event.
     */
    suspend fun `edit`(`eventId`: kotlin.String, `newContent`: RoomMessageEventContentWithoutRelation)
    
    /**
     * Enable End-to-end encryption in this room.
     */
    suspend fun `enableEncryption`()
    
    /**
     * Enable or disable the send queue for that particular room.
     */
    fun `enableSendQueue`(`enable`: kotlin.Boolean)
    
    fun `encryptionState`(): EncryptionState
    
    /**
     * Return the current MSC4306 thread subscription for the given thread root
     * in this room.
     *
     * Returns `None` if the thread doesn't exist, or isn't subscribed to, or
     * the server can't handle MSC4306; otherwise, returns the thread
     * subscription status.
     */
    suspend fun `fetchThreadSubscription`(`threadRootEventId`: kotlin.String): ThreadSubscription?
    
    /**
     * Forget this room.
     *
     * This communicates to the homeserver that it should forget the room.
     *
     * Only left or banned-from rooms can be forgotten.
     */
    suspend fun `forget`()
    
    suspend fun `getPowerLevels`(): RoomPowerLevels
    
    /**
     * Returns the visibility for this room in the room directory.
     *
     * [Public](`RoomVisibility::Public`) rooms are listed in the room
     * directory and can be found using it.
     */
    suspend fun `getRoomVisibility`(): RoomVisibility
    
    /**
     * Is there a non expired membership with application "m.call" and scope
     * "m.room" in this room.
     */
    fun `hasActiveRoomCall`(): kotlin.Boolean
    
    /**
     * Returns the room heroes for this room.
     */
    fun `heroes`(): List<RoomHero>
    
    fun `id`(): kotlin.String
    
    /**
     * Set the local trust for the given devices to `LocalTrust::Ignored`
     * and resend messages that failed to send because said devices are
     * unverified (in response to
     * `SessionRecipientCollectionError::VerifiedUserHasUnsignedDevice`).
     * # Arguments
     *
     * * `devices` - The map of users identifiers to device identifiers
     * received in the error
     * * `transaction_id` - The send queue transaction identifier of the local
     * echo the send error applies to
     */
    suspend fun `ignoreDeviceTrustAndResend`(`devices`: Map<kotlin.String, List<kotlin.String>>, `sendHandle`: SendHandle)
    
    /**
     * Ignores a user.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user to ignore.
     */
    suspend fun `ignoreUser`(`userId`: kotlin.String)
    
    suspend fun `inviteUserById`(`userId`: kotlin.String)
    
    fun `invitedMembersCount`(): kotlin.ULong
    
    /**
     * Get the user who created the invite, if any.
     */
    suspend fun `inviter`(): RoomMember?
    
    suspend fun `isDirect`(): kotlin.Boolean
    
    /**
     * Checks whether the room is encrypted or not.
     *
     * **Note**: this info may not be reliable if you don't set up
     * `m.room.encryption` as required state.
     */
    suspend fun `isEncrypted`(): kotlin.Boolean
    
    /**
     * Whether the room can be publicly joined or not, based on its join rule.
     *
     * Can return `None` if the join rule state event is missing.
     */
    fun `isPublic`(): kotlin.Boolean?
    
    /**
     * Returns whether the send queue for that particular room is enabled or
     * not.
     */
    fun `isSendQueueEnabled`(): kotlin.Boolean
    
    fun `isSpace`(): kotlin.Boolean
    
    /**
     * Join this room.
     *
     * Only invited and left rooms can be joined via this method.
     */
    suspend fun `join`()
    
    fun `joinedMembersCount`(): kotlin.ULong
    
    suspend fun `kickUser`(`userId`: kotlin.String, `reason`: kotlin.String?)
    
    suspend fun `latestEncryptionState`(): EncryptionState
    
    suspend fun `latestEvent`(): EventTimelineItem?
    
    /**
     * Leave this room.
     *
     * Only invited and joined rooms can be left.
     */
    suspend fun `leave`()
    
    /**
     * Retrieve the `ComposerDraft` stored in the state store for this room.
     */
    suspend fun `loadComposerDraft`(`threadRoot`: kotlin.String?): ComposerDraft?
    
    /**
     * Either loads the event associated with the `event_id` from the event
     * cache or fetches it from the homeserver.
     */
    suspend fun `loadOrFetchEvent`(`eventId`: kotlin.String): TimelineEvent
    
    /**
     * Mark a room as fully read, by attaching a read receipt to the provided
     * `event_id`.
     *
     * **Warning:** using this method is **NOT** recommended, as providing the
     * latest event id can cause incorrect read receipts. This method won't
     * check if sending the read receipt is necessary or valid. It should
     * *only* be used when some constraint prevents you from instantiating a
     * [`Timeline`]. For any other case use [`Timeline::mark_as_read`]
     * instead.
     */
    suspend fun `markAsFullyReadUnchecked`(`eventId`: kotlin.String)
    
    /**
     * Mark a room as read, by attaching a read receipt on the latest event.
     *
     * Note: this does NOT unset the unread flag; it's the caller's
     * responsibility to do so, if need be.
     */
    suspend fun `markAsRead`(`receiptType`: ReceiptType)
    
    suspend fun `matrixToEventPermalink`(`eventId`: kotlin.String): kotlin.String
    
    suspend fun `matrixToPermalink`(): kotlin.String
    
    suspend fun `member`(`userId`: kotlin.String): RoomMember
    
    suspend fun `memberAvatarUrl`(`userId`: kotlin.String): kotlin.String?
    
    suspend fun `memberDisplayName`(`userId`: kotlin.String): kotlin.String?
    
    /**
     * Get the membership details for the current user.
     *
     * Returns:
     * - If the user was present in the room, a
     * [`matrix_sdk::room::RoomMemberWithSenderInfo`] containing both the
     * user info and the member info of the sender of the `m.room.member`
     * event.
     * - If the current user is not present, an error.
     */
    suspend fun `memberWithSenderInfo`(`userId`: kotlin.String): RoomMemberWithSenderInfo
    
    suspend fun `members`(): RoomMembersIterator
    
    suspend fun `membersNoSync`(): RoomMembersIterator
    
    /**
     * The room's current membership state.
     */
    fun `membership`(): Membership
    
    suspend fun `newLatestEvent`(): LatestEventValue
    
    fun `ownUserId`(): kotlin.String
    
    /**
     * If this room is the successor of a tombstoned room, return the
     * reference to the predecessor room.
     *
     * A room is tombstoned if it has received a [`m.room.tombstone`] state
     * event.
     *
     * To determine if a room is the successor of a tombstoned room, the
     * [`m.room.create`] must have been received, **with** a `predecessor`
     * field.
     *
     * [`m.room.tombstone`]: https://spec.matrix.org/v1.14/client-server-api/#mroomtombstone
     * [`m.room.create`]: https://spec.matrix.org/v1.14/client-server-api/#mroomcreate
     */
    fun `predecessorRoom`(): PredecessorRoom?
    
    /**
     * Builds a `RoomPreview` from a room list item. This is intended for
     * invited, knocked or banned rooms.
     */
    suspend fun `previewRoom`(`via`: List<kotlin.String>): RoomPreview
    
    /**
     * Publish a new room alias for this room in the room directory.
     *
     * Returns:
     * - `true` if the room alias didn't exist and it's now published.
     * - `false` if the room alias was already present so it couldn't be
     * published.
     */
    suspend fun `publishRoomAliasInRoomDirectory`(`alias`: kotlin.String): kotlin.Boolean
    
    /**
     * The raw name as present in the room state event.
     */
    fun `rawName`(): kotlin.String?
    
    /**
     * Redacts an event from the room.
     *
     * # Arguments
     *
     * * `event_id` - The ID of the event to redact
     *
     * * `reason` - The reason for the event being redacted (optional). its
     * transaction ID (optional). If not given one is created.
     */
    suspend fun `redact`(`eventId`: kotlin.String, `reason`: kotlin.String?)
    
    /**
     * Removes the current room avatar
     */
    suspend fun `removeAvatar`()
    
    /**
     * Remove an existing room alias for this room in the room directory.
     *
     * Returns:
     * - `true` if the room alias was present and it's now removed from the
     * room directory.
     * - `false` if the room alias didn't exist so it couldn't be removed.
     */
    suspend fun `removeRoomAliasFromRoomDirectory`(`alias`: kotlin.String): kotlin.Boolean
    
    /**
     * Reports an event from the room.
     *
     * # Arguments
     *
     * * `event_id` - The ID of the event to report
     *
     * * `reason` - The reason for the event being reported (optional).
     *
     * * `score` - The score to rate this content as where -100 is most
     * offensive and 0 is inoffensive (optional).
     */
    suspend fun `reportContent`(`eventId`: kotlin.String, `score`: kotlin.Int?, `reason`: kotlin.String?)
    
    /**
     * Reports a room as inappropriate to the server.
     * The caller is not required to be joined to the room to report it.
     *
     * # Arguments
     *
     * * `reason` - The reason the room is being reported.
     *
     * # Errors
     *
     * Returns an error if the room is not found or on rate limit
     */
    suspend fun `reportRoom`(`reason`: kotlin.String)
    
    suspend fun `resetPowerLevels`(): RoomPowerLevels
    
    /**
     * Return a debug representation for the internal room events data
     * structure, one line per entry in the resulting vector.
     */
    suspend fun `roomEventsDebugString`(): List<kotlin.String>
    
    suspend fun `roomInfo`(): RoomInfo
    
    /**
     * Store the given `ComposerDraft` in the state store using the current
     * room id, as identifier.
     */
    suspend fun `saveComposerDraft`(`draft`: ComposerDraft, `threadRoot`: kotlin.String?)
    
    /**
     * Send the current users live location beacon in the room.
     */
    suspend fun `sendLiveLocation`(`geoUri`: kotlin.String)
    
    /**
     * Send a raw event to the room.
     *
     * # Arguments
     *
     * * `event_type` - The type of the event to send.
     *
     * * `content` - The content of the event to send encoded as JSON string.
     */
    suspend fun `sendRaw`(`eventType`: kotlin.String, `content`: kotlin.String)
    
    suspend fun `setIsFavourite`(`isFavourite`: kotlin.Boolean, `tagOrder`: kotlin.Double?)
    
    suspend fun `setIsLowPriority`(`isLowPriority`: kotlin.Boolean, `tagOrder`: kotlin.Double?)
    
    /**
     * Sets a new name to the room.
     */
    suspend fun `setName`(`name`: kotlin.String)
    
    /**
     * Set a MSC4306 subscription to a thread in this room, based on the thread
     * root event id.
     *
     * If `subscribed` is `true`, it will subscribe to the thread, with a
     * precision that the subscription was manually requested by the user
     * (i.e. not automatic).
     *
     * If the thread was already subscribed to (resp. unsubscribed from), while
     * trying to subscribe to it (resp. unsubscribe from it), it will do
     * nothing, i.e. subscribing (resp. unsubscribing) to a thread is an
     * idempotent operation.
     */
    suspend fun `setThreadSubscription`(`threadRootEventId`: kotlin.String, `subscribed`: kotlin.Boolean)
    
    /**
     * Sets a new topic in the room.
     */
    suspend fun `setTopic`(`topic`: kotlin.String)
    
    /**
     * Set (or unset) a flag on the room to indicate that the user has
     * explicitly marked it as unread.
     */
    suspend fun `setUnreadFlag`(`newValue`: kotlin.Boolean)
    
    /**
     * Start the current users live location share in the room.
     */
    suspend fun `startLiveLocationShare`(`durationMillis`: kotlin.ULong)
    
    /**
     * Stop the current users live location share in the room.
     */
    suspend fun `stopLiveLocationShare`()
    
    /**
     * Subscribes to call decline for a currently ringing call, using a
     * `listener` to be notified when someone declines.
     *
     * Will error if `rtc_notification_event_id` is not a valid event id.
     * Use the [`TaskHandle`] to cancel the subscription.
     */
    fun `subscribeToCallDeclineEvents`(`rtcNotificationEventId`: kotlin.String, `listener`: CallDeclineListener): TaskHandle
    
    suspend fun `subscribeToIdentityStatusChanges`(`listener`: IdentityStatusChangeListener): TaskHandle
    
    /**
     * Subscribes to requests to join this room (knock member events), using a
     * `listener` to be notified of the changes.
     *
     * The current requests to join the room will be emitted immediately
     * when subscribing, along with a [`TaskHandle`] to cancel the
     * subscription.
     */
    suspend fun `subscribeToKnockRequests`(`listener`: KnockRequestsListener): TaskHandle
    
    /**
     * Subscribes to live location shares in this room, using a `listener` to
     * be notified of the changes.
     *
     * The current live location shares will be emitted immediately when
     * subscribing, along with a [`TaskHandle`] to cancel the subscription.
     */
    fun `subscribeToLiveLocationShares`(`listener`: LiveLocationShareListener): TaskHandle
    
    fun `subscribeToRoomInfoUpdates`(`listener`: RoomInfoListener): TaskHandle
    
    /**
     * Subscribe to all send queue updates in this room.
     *
     * The given listener will be immediately called with
     * `RoomSendQueueUpdate::NewLocalEvent` for each local echo existing in
     * the queue.
     */
    suspend fun `subscribeToSendQueueUpdates`(`listener`: SendQueueListener): TaskHandle
    
    fun `subscribeToTypingNotifications`(`listener`: TypingNotificationsListener): TaskHandle
    
    /**
     * If this room is tombstoned, return the reference to the successor room
     * i.e. the room replacing this one.
     *
     * A room is tombstoned if it has received a [`m.room.tombstone`] state
     * event.
     *
     * [`m.room.tombstone`]: https://spec.matrix.org/v1.14/client-server-api/#mroomtombstone
     */
    fun `successorRoom`(): SuccessorRoom?
    
    suspend fun `suggestedRoleForUser`(`userId`: kotlin.String): RoomMemberRole
    
    /**
     * Create a timeline with a default configuration, i.e. a live timeline
     * with read receipts and read marker tracking.
     */
    suspend fun `timeline`(): Timeline
    
    /**
     * Build a new timeline instance with the given configuration.
     */
    suspend fun `timelineWithConfiguration`(`configuration`: TimelineConfiguration): Timeline
    
    fun `topic`(): kotlin.String?
    
    suspend fun `typingNotice`(`isTyping`: kotlin.Boolean)
    
    suspend fun `unbanUser`(`userId`: kotlin.String, `reason`: kotlin.String?)
    
    /**
     * Update the canonical alias of the room.
     *
     * Note that publishing the alias in the room directory is done separately.
     */
    suspend fun `updateCanonicalAlias`(`alias`: kotlin.String?, `altAliases`: List<kotlin.String>)
    
    /**
     * Update room history visibility for this room.
     */
    suspend fun `updateHistoryVisibility`(`visibility`: RoomHistoryVisibility)
    
    /**
     * Update the join rule for this room.
     */
    suspend fun `updateJoinRules`(`newRule`: JoinRule)
    
    suspend fun `updatePowerLevelsForUsers`(`updates`: List<UserPowerLevelUpdate>)
    
    /**
     * Update the room's visibility in the room directory.
     */
    suspend fun `updateRoomVisibility`(`visibility`: RoomVisibility)
    
    /**
     * Upload and set the room's avatar.
     *
     * This will upload the data produced by the reader to the homeserver's
     * content repository, and set the room's avatar to the MXC URI for the
     * uploaded file.
     *
     * # Arguments
     *
     * * `mime_type` - The mime description of the avatar, for example
     * image/jpeg
     * * `data` - The raw data that will be uploaded to the homeserver's
     * content repository
     * * `media_info` - The media info used as avatar image info.
     */
    suspend fun `uploadAvatar`(`mimeType`: kotlin.String, `data`: kotlin.ByteArray, `mediaInfo`: ImageInfo?)
    
    /**
     * Remove verification requirements for the given users and
     * resend messages that failed to send because their identities were no
     * longer verified (in response to
     * `SessionRecipientCollectionError::VerifiedUserChangedIdentity`)
     *
     * # Arguments
     *
     * * `user_ids` - The list of users identifiers received in the error
     * * `transaction_id` - The send queue transaction identifier of the local
     * echo the send error applies to
     */
    suspend fun `withdrawVerificationAndResend`(`userIds`: List<kotlin.String>, `sendHandle`: SendHandle)
    
    companion object
}

open class Room: Disposable, AutoCloseable, RoomInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_room(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_room(pointer!!, status)
        }
    }

    override fun `activeMembersCount`(): kotlin.ULong {
            return FfiConverterULong.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_active_members_count(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Returns a Vec of userId's that participate in the room call.
     *
     * MatrixRTC memberships with application "m.call" and scope "m.room" are
     * considered. A user can occur twice if they join with two devices.
     * convert to a set depending if the different users are required or the
     * amount of sessions.
     *
     * The vector is ordered by oldest membership user to newest.
     */override fun `activeRoomCallParticipants`(): List<kotlin.String> {
            return FfiConverterSequenceString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_active_room_call_participants(
        it, _status)
}
    }
    )
    }
    

    override fun `alternativeAliases`(): List<kotlin.String> {
            return FfiConverterSequenceString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_alternative_aliases(
        it, _status)
}
    }
    )
    }
    

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `applyPowerLevelChanges`(`changes`: RoomPowerLevelChanges) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_apply_power_level_changes(
                thisPtr,
                FfiConverterTypeRoomPowerLevelChanges.lower(`changes`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    override fun `avatarUrl`(): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_avatar_url(
        it, _status)
}
    }
    )
    }
    

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `banUser`(`userId`: kotlin.String, `reason`: kotlin.String?) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_ban_user(
                thisPtr,
                FfiConverterString.lower(`userId`),FfiConverterOptionalString.lower(`reason`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    override fun `canonicalAlias`(): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_canonical_alias(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Remove the `ComposerDraft` stored in the state store for this room.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `clearComposerDraft`(`threadRoot`: kotlin.String?) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_clear_composer_draft(
                thisPtr,
                FfiConverterOptionalString.lower(`threadRoot`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Clear the event cache storage for the current room.
     *
     * This will remove all the information related to the event cache, in
     * memory and in the persisted storage, if enabled.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `clearEventCacheStorage`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_clear_event_cache_storage(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Declines a call (and stop ringing).
     *
     * # Arguments
     *
     * * `rtc_notification_event_id` - the event id of the m.rtc.notification
     * event.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `declineCall`(`rtcNotificationEventId`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_decline_call(
                thisPtr,
                FfiConverterString.lower(`rtcNotificationEventId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Forces the currently active room key, which is used to encrypt messages,
     * to be rotated.
     *
     * A new room key will be crated and shared with all the room members the
     * next time a message will be sent. You don't have to call this method,
     * room keys will be rotated automatically when necessary. This method is
     * still useful for debugging purposes.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `discardRoomKey`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_discard_room_key(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Returns the room's name from the state event if available, otherwise
     * compute a room name based on the room's nature (DM or not) and number of
     * members.
     */override fun `displayName`(): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_display_name(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Edit an event given its event id.
     *
     * Useful outside the context of a timeline, or when a timeline doesn't
     * have the full content of an event.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `edit`(`eventId`: kotlin.String, `newContent`: RoomMessageEventContentWithoutRelation) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_edit(
                thisPtr,
                FfiConverterString.lower(`eventId`),FfiConverterTypeRoomMessageEventContentWithoutRelation.lower(`newContent`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Enable End-to-end encryption in this room.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `enableEncryption`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_enable_encryption(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Enable or disable the send queue for that particular room.
     */override fun `enableSendQueue`(`enable`: kotlin.Boolean)
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_enable_send_queue(
        it, FfiConverterBoolean.lower(`enable`),_status)
}
    }
    
    

    override fun `encryptionState`(): EncryptionState {
            return FfiConverterTypeEncryptionState.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_encryption_state(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Return the current MSC4306 thread subscription for the given thread root
     * in this room.
     *
     * Returns `None` if the thread doesn't exist, or isn't subscribed to, or
     * the server can't handle MSC4306; otherwise, returns the thread
     * subscription status.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `fetchThreadSubscription`(`threadRootEventId`: kotlin.String) : ThreadSubscription? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_fetch_thread_subscription(
                thisPtr,
                FfiConverterString.lower(`threadRootEventId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeThreadSubscription.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Forget this room.
     *
     * This communicates to the homeserver that it should forget the room.
     *
     * Only left or banned-from rooms can be forgotten.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `forget`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_forget(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getPowerLevels`() : RoomPowerLevels {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_get_power_levels(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeRoomPowerLevels.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Returns the visibility for this room in the room directory.
     *
     * [Public](`RoomVisibility::Public`) rooms are listed in the room
     * directory and can be found using it.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getRoomVisibility`() : RoomVisibility {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_get_room_visibility(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeRoomVisibility.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Is there a non expired membership with application "m.call" and scope
     * "m.room" in this room.
     */override fun `hasActiveRoomCall`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_has_active_room_call(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Returns the room heroes for this room.
     */override fun `heroes`(): List<RoomHero> {
            return FfiConverterSequenceTypeRoomHero.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_heroes(
        it, _status)
}
    }
    )
    }
    

    override fun `id`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_id(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Set the local trust for the given devices to `LocalTrust::Ignored`
     * and resend messages that failed to send because said devices are
     * unverified (in response to
     * `SessionRecipientCollectionError::VerifiedUserHasUnsignedDevice`).
     * # Arguments
     *
     * * `devices` - The map of users identifiers to device identifiers
     * received in the error
     * * `transaction_id` - The send queue transaction identifier of the local
     * echo the send error applies to
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `ignoreDeviceTrustAndResend`(`devices`: Map<kotlin.String, List<kotlin.String>>, `sendHandle`: SendHandle) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_ignore_device_trust_and_resend(
                thisPtr,
                FfiConverterMapStringSequenceString.lower(`devices`),FfiConverterTypeSendHandle.lower(`sendHandle`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Ignores a user.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user to ignore.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `ignoreUser`(`userId`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_ignore_user(
                thisPtr,
                FfiConverterString.lower(`userId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `inviteUserById`(`userId`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_invite_user_by_id(
                thisPtr,
                FfiConverterString.lower(`userId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    override fun `invitedMembersCount`(): kotlin.ULong {
            return FfiConverterULong.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_invited_members_count(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the user who created the invite, if any.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `inviter`() : RoomMember? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_inviter(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeRoomMember.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `isDirect`() : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_is_direct(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Checks whether the room is encrypted or not.
     *
     * **Note**: this info may not be reliable if you don't set up
     * `m.room.encryption` as required state.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `isEncrypted`() : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_is_encrypted(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Whether the room can be publicly joined or not, based on its join rule.
     *
     * Can return `None` if the join rule state event is missing.
     */override fun `isPublic`(): kotlin.Boolean? {
            return FfiConverterOptionalBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_is_public(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Returns whether the send queue for that particular room is enabled or
     * not.
     */override fun `isSendQueueEnabled`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_is_send_queue_enabled(
        it, _status)
}
    }
    )
    }
    

    override fun `isSpace`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_is_space(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Join this room.
     *
     * Only invited and left rooms can be joined via this method.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `join`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_join(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    override fun `joinedMembersCount`(): kotlin.ULong {
            return FfiConverterULong.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_joined_members_count(
        it, _status)
}
    }
    )
    }
    

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `kickUser`(`userId`: kotlin.String, `reason`: kotlin.String?) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_kick_user(
                thisPtr,
                FfiConverterString.lower(`userId`),FfiConverterOptionalString.lower(`reason`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `latestEncryptionState`() : EncryptionState {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_latest_encryption_state(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation).let { RustBufferEncryptionState.create(it.capacity.toULong(), it.len.toULong(), it.data) } },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeEncryptionState.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `latestEvent`() : EventTimelineItem? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_latest_event(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeEventTimelineItem.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Leave this room.
     *
     * Only invited and joined rooms can be left.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `leave`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_leave(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Retrieve the `ComposerDraft` stored in the state store for this room.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `loadComposerDraft`(`threadRoot`: kotlin.String?) : ComposerDraft? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_load_composer_draft(
                thisPtr,
                FfiConverterOptionalString.lower(`threadRoot`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeComposerDraft.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Either loads the event associated with the `event_id` from the event
     * cache or fetches it from the homeserver.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `loadOrFetchEvent`(`eventId`: kotlin.String) : TimelineEvent {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_load_or_fetch_event(
                thisPtr,
                FfiConverterString.lower(`eventId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeTimelineEvent.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Mark a room as fully read, by attaching a read receipt to the provided
     * `event_id`.
     *
     * **Warning:** using this method is **NOT** recommended, as providing the
     * latest event id can cause incorrect read receipts. This method won't
     * check if sending the read receipt is necessary or valid. It should
     * *only* be used when some constraint prevents you from instantiating a
     * [`Timeline`]. For any other case use [`Timeline::mark_as_read`]
     * instead.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `markAsFullyReadUnchecked`(`eventId`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_mark_as_fully_read_unchecked(
                thisPtr,
                FfiConverterString.lower(`eventId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Mark a room as read, by attaching a read receipt on the latest event.
     *
     * Note: this does NOT unset the unread flag; it's the caller's
     * responsibility to do so, if need be.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `markAsRead`(`receiptType`: ReceiptType) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_mark_as_read(
                thisPtr,
                FfiConverterTypeReceiptType.lower(`receiptType`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `matrixToEventPermalink`(`eventId`: kotlin.String) : kotlin.String {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_matrix_to_event_permalink(
                thisPtr,
                FfiConverterString.lower(`eventId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterString.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `matrixToPermalink`() : kotlin.String {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_matrix_to_permalink(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterString.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `member`(`userId`: kotlin.String) : RoomMember {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_member(
                thisPtr,
                FfiConverterString.lower(`userId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeRoomMember.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `memberAvatarUrl`(`userId`: kotlin.String) : kotlin.String? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_member_avatar_url(
                thisPtr,
                FfiConverterString.lower(`userId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalString.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `memberDisplayName`(`userId`: kotlin.String) : kotlin.String? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_member_display_name(
                thisPtr,
                FfiConverterString.lower(`userId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalString.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Get the membership details for the current user.
     *
     * Returns:
     * - If the user was present in the room, a
     * [`matrix_sdk::room::RoomMemberWithSenderInfo`] containing both the
     * user info and the member info of the sender of the `m.room.member`
     * event.
     * - If the current user is not present, an error.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `memberWithSenderInfo`(`userId`: kotlin.String) : RoomMemberWithSenderInfo {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_member_with_sender_info(
                thisPtr,
                FfiConverterString.lower(`userId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeRoomMemberWithSenderInfo.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `members`() : RoomMembersIterator {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_members(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeRoomMembersIterator.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `membersNoSync`() : RoomMembersIterator {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_members_no_sync(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeRoomMembersIterator.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * The room's current membership state.
     */override fun `membership`(): Membership {
            return FfiConverterTypeMembership.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_membership(
        it, _status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `newLatestEvent`() : LatestEventValue {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_new_latest_event(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeLatestEventValue.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `ownUserId`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_own_user_id(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * If this room is the successor of a tombstoned room, return the
     * reference to the predecessor room.
     *
     * A room is tombstoned if it has received a [`m.room.tombstone`] state
     * event.
     *
     * To determine if a room is the successor of a tombstoned room, the
     * [`m.room.create`] must have been received, **with** a `predecessor`
     * field.
     *
     * [`m.room.tombstone`]: https://spec.matrix.org/v1.14/client-server-api/#mroomtombstone
     * [`m.room.create`]: https://spec.matrix.org/v1.14/client-server-api/#mroomcreate
     */override fun `predecessorRoom`(): PredecessorRoom? {
            return FfiConverterOptionalTypePredecessorRoom.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_predecessor_room(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Builds a `RoomPreview` from a room list item. This is intended for
     * invited, knocked or banned rooms.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `previewRoom`(`via`: List<kotlin.String>) : RoomPreview {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_preview_room(
                thisPtr,
                FfiConverterSequenceString.lower(`via`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeRoomPreview.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Publish a new room alias for this room in the room directory.
     *
     * Returns:
     * - `true` if the room alias didn't exist and it's now published.
     * - `false` if the room alias was already present so it couldn't be
     * published.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `publishRoomAliasInRoomDirectory`(`alias`: kotlin.String) : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_publish_room_alias_in_room_directory(
                thisPtr,
                FfiConverterString.lower(`alias`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * The raw name as present in the room state event.
     */override fun `rawName`(): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_raw_name(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Redacts an event from the room.
     *
     * # Arguments
     *
     * * `event_id` - The ID of the event to redact
     *
     * * `reason` - The reason for the event being redacted (optional). its
     * transaction ID (optional). If not given one is created.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `redact`(`eventId`: kotlin.String, `reason`: kotlin.String?) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_redact(
                thisPtr,
                FfiConverterString.lower(`eventId`),FfiConverterOptionalString.lower(`reason`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Removes the current room avatar
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `removeAvatar`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_remove_avatar(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Remove an existing room alias for this room in the room directory.
     *
     * Returns:
     * - `true` if the room alias was present and it's now removed from the
     * room directory.
     * - `false` if the room alias didn't exist so it couldn't be removed.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `removeRoomAliasFromRoomDirectory`(`alias`: kotlin.String) : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_remove_room_alias_from_room_directory(
                thisPtr,
                FfiConverterString.lower(`alias`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Reports an event from the room.
     *
     * # Arguments
     *
     * * `event_id` - The ID of the event to report
     *
     * * `reason` - The reason for the event being reported (optional).
     *
     * * `score` - The score to rate this content as where -100 is most
     * offensive and 0 is inoffensive (optional).
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `reportContent`(`eventId`: kotlin.String, `score`: kotlin.Int?, `reason`: kotlin.String?) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_report_content(
                thisPtr,
                FfiConverterString.lower(`eventId`),FfiConverterOptionalInt.lower(`score`),FfiConverterOptionalString.lower(`reason`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Reports a room as inappropriate to the server.
     * The caller is not required to be joined to the room to report it.
     *
     * # Arguments
     *
     * * `reason` - The reason the room is being reported.
     *
     * # Errors
     *
     * Returns an error if the room is not found or on rate limit
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `reportRoom`(`reason`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_report_room(
                thisPtr,
                FfiConverterString.lower(`reason`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `resetPowerLevels`() : RoomPowerLevels {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_reset_power_levels(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeRoomPowerLevels.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Return a debug representation for the internal room events data
     * structure, one line per entry in the resulting vector.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `roomEventsDebugString`() : List<kotlin.String> {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_room_events_debug_string(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterSequenceString.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `roomInfo`() : RoomInfo {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_room_info(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeRoomInfo.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Store the given `ComposerDraft` in the state store using the current
     * room id, as identifier.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `saveComposerDraft`(`draft`: ComposerDraft, `threadRoot`: kotlin.String?) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_save_composer_draft(
                thisPtr,
                FfiConverterTypeComposerDraft.lower(`draft`),FfiConverterOptionalString.lower(`threadRoot`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Send the current users live location beacon in the room.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `sendLiveLocation`(`geoUri`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_send_live_location(
                thisPtr,
                FfiConverterString.lower(`geoUri`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Send a raw event to the room.
     *
     * # Arguments
     *
     * * `event_type` - The type of the event to send.
     *
     * * `content` - The content of the event to send encoded as JSON string.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `sendRaw`(`eventType`: kotlin.String, `content`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_send_raw(
                thisPtr,
                FfiConverterString.lower(`eventType`),FfiConverterString.lower(`content`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setIsFavourite`(`isFavourite`: kotlin.Boolean, `tagOrder`: kotlin.Double?) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_set_is_favourite(
                thisPtr,
                FfiConverterBoolean.lower(`isFavourite`),FfiConverterOptionalDouble.lower(`tagOrder`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setIsLowPriority`(`isLowPriority`: kotlin.Boolean, `tagOrder`: kotlin.Double?) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_set_is_low_priority(
                thisPtr,
                FfiConverterBoolean.lower(`isLowPriority`),FfiConverterOptionalDouble.lower(`tagOrder`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Sets a new name to the room.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setName`(`name`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_set_name(
                thisPtr,
                FfiConverterString.lower(`name`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Set a MSC4306 subscription to a thread in this room, based on the thread
     * root event id.
     *
     * If `subscribed` is `true`, it will subscribe to the thread, with a
     * precision that the subscription was manually requested by the user
     * (i.e. not automatic).
     *
     * If the thread was already subscribed to (resp. unsubscribed from), while
     * trying to subscribe to it (resp. unsubscribe from it), it will do
     * nothing, i.e. subscribing (resp. unsubscribing) to a thread is an
     * idempotent operation.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setThreadSubscription`(`threadRootEventId`: kotlin.String, `subscribed`: kotlin.Boolean) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_set_thread_subscription(
                thisPtr,
                FfiConverterString.lower(`threadRootEventId`),FfiConverterBoolean.lower(`subscribed`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Sets a new topic in the room.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setTopic`(`topic`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_set_topic(
                thisPtr,
                FfiConverterString.lower(`topic`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Set (or unset) a flag on the room to indicate that the user has
     * explicitly marked it as unread.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setUnreadFlag`(`newValue`: kotlin.Boolean) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_set_unread_flag(
                thisPtr,
                FfiConverterBoolean.lower(`newValue`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Start the current users live location share in the room.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `startLiveLocationShare`(`durationMillis`: kotlin.ULong) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_start_live_location_share(
                thisPtr,
                FfiConverterULong.lower(`durationMillis`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Stop the current users live location share in the room.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `stopLiveLocationShare`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_stop_live_location_share(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Subscribes to call decline for a currently ringing call, using a
     * `listener` to be notified when someone declines.
     *
     * Will error if `rtc_notification_event_id` is not a valid event id.
     * Use the [`TaskHandle`] to cancel the subscription.
     */
    @Throws(ClientException::class)override fun `subscribeToCallDeclineEvents`(`rtcNotificationEventId`: kotlin.String, `listener`: CallDeclineListener): TaskHandle {
            return FfiConverterTypeTaskHandle.lift(
    callWithPointer {
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_call_decline_events(
        it, FfiConverterString.lower(`rtcNotificationEventId`),FfiConverterTypeCallDeclineListener.lower(`listener`),_status)
}
    }
    )
    }
    

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `subscribeToIdentityStatusChanges`(`listener`: IdentityStatusChangeListener) : TaskHandle {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_identity_status_changes(
                thisPtr,
                FfiConverterTypeIdentityStatusChangeListener.lower(`listener`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeTaskHandle.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Subscribes to requests to join this room (knock member events), using a
     * `listener` to be notified of the changes.
     *
     * The current requests to join the room will be emitted immediately
     * when subscribing, along with a [`TaskHandle`] to cancel the
     * subscription.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `subscribeToKnockRequests`(`listener`: KnockRequestsListener) : TaskHandle {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_knock_requests(
                thisPtr,
                FfiConverterTypeKnockRequestsListener.lower(`listener`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeTaskHandle.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Subscribes to live location shares in this room, using a `listener` to
     * be notified of the changes.
     *
     * The current live location shares will be emitted immediately when
     * subscribing, along with a [`TaskHandle`] to cancel the subscription.
     */override fun `subscribeToLiveLocationShares`(`listener`: LiveLocationShareListener): TaskHandle {
            return FfiConverterTypeTaskHandle.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_live_location_shares(
        it, FfiConverterTypeLiveLocationShareListener.lower(`listener`),_status)
}
    }
    )
    }
    

    override fun `subscribeToRoomInfoUpdates`(`listener`: RoomInfoListener): TaskHandle {
            return FfiConverterTypeTaskHandle.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_room_info_updates(
        it, FfiConverterTypeRoomInfoListener.lower(`listener`),_status)
}
    }
    )
    }
    

    
    /**
     * Subscribe to all send queue updates in this room.
     *
     * The given listener will be immediately called with
     * `RoomSendQueueUpdate::NewLocalEvent` for each local echo existing in
     * the queue.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `subscribeToSendQueueUpdates`(`listener`: SendQueueListener) : TaskHandle {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_send_queue_updates(
                thisPtr,
                FfiConverterTypeSendQueueListener.lower(`listener`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeTaskHandle.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    override fun `subscribeToTypingNotifications`(`listener`: TypingNotificationsListener): TaskHandle {
            return FfiConverterTypeTaskHandle.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_typing_notifications(
        it, FfiConverterTypeTypingNotificationsListener.lower(`listener`),_status)
}
    }
    )
    }
    

    
    /**
     * If this room is tombstoned, return the reference to the successor room
     * i.e. the room replacing this one.
     *
     * A room is tombstoned if it has received a [`m.room.tombstone`] state
     * event.
     *
     * [`m.room.tombstone`]: https://spec.matrix.org/v1.14/client-server-api/#mroomtombstone
     */override fun `successorRoom`(): SuccessorRoom? {
            return FfiConverterOptionalTypeSuccessorRoom.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_successor_room(
        it, _status)
}
    }
    )
    }
    

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `suggestedRoleForUser`(`userId`: kotlin.String) : RoomMemberRole {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_suggested_role_for_user(
                thisPtr,
                FfiConverterString.lower(`userId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation).let { RustBufferRoomMemberRole.create(it.capacity.toULong(), it.len.toULong(), it.data) } },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeRoomMemberRole.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Create a timeline with a default configuration, i.e. a live timeline
     * with read receipts and read marker tracking.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `timeline`() : Timeline {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_timeline(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeTimeline.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Build a new timeline instance with the given configuration.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `timelineWithConfiguration`(`configuration`: TimelineConfiguration) : Timeline {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_timeline_with_configuration(
                thisPtr,
                FfiConverterTypeTimelineConfiguration.lower(`configuration`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeTimeline.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    override fun `topic`(): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_topic(
        it, _status)
}
    }
    )
    }
    

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `typingNotice`(`isTyping`: kotlin.Boolean) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_typing_notice(
                thisPtr,
                FfiConverterBoolean.lower(`isTyping`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `unbanUser`(`userId`: kotlin.String, `reason`: kotlin.String?) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_unban_user(
                thisPtr,
                FfiConverterString.lower(`userId`),FfiConverterOptionalString.lower(`reason`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Update the canonical alias of the room.
     *
     * Note that publishing the alias in the room directory is done separately.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `updateCanonicalAlias`(`alias`: kotlin.String?, `altAliases`: List<kotlin.String>) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_update_canonical_alias(
                thisPtr,
                FfiConverterOptionalString.lower(`alias`),FfiConverterSequenceString.lower(`altAliases`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Update room history visibility for this room.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `updateHistoryVisibility`(`visibility`: RoomHistoryVisibility) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_update_history_visibility(
                thisPtr,
                FfiConverterTypeRoomHistoryVisibility.lower(`visibility`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Update the join rule for this room.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `updateJoinRules`(`newRule`: JoinRule) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_update_join_rules(
                thisPtr,
                FfiConverterTypeJoinRule.lower(`newRule`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `updatePowerLevelsForUsers`(`updates`: List<UserPowerLevelUpdate>) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_update_power_levels_for_users(
                thisPtr,
                FfiConverterSequenceTypeUserPowerLevelUpdate.lower(`updates`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Update the room's visibility in the room directory.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `updateRoomVisibility`(`visibility`: RoomVisibility) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_update_room_visibility(
                thisPtr,
                FfiConverterTypeRoomVisibility.lower(`visibility`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Upload and set the room's avatar.
     *
     * This will upload the data produced by the reader to the homeserver's
     * content repository, and set the room's avatar to the MXC URI for the
     * uploaded file.
     *
     * # Arguments
     *
     * * `mime_type` - The mime description of the avatar, for example
     * image/jpeg
     * * `data` - The raw data that will be uploaded to the homeserver's
     * content repository
     * * `media_info` - The media info used as avatar image info.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `uploadAvatar`(`mimeType`: kotlin.String, `data`: kotlin.ByteArray, `mediaInfo`: ImageInfo?) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_upload_avatar(
                thisPtr,
                FfiConverterString.lower(`mimeType`),FfiConverterByteArray.lower(`data`),FfiConverterOptionalTypeImageInfo.lower(`mediaInfo`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Remove verification requirements for the given users and
     * resend messages that failed to send because their identities were no
     * longer verified (in response to
     * `SessionRecipientCollectionError::VerifiedUserChangedIdentity`)
     *
     * # Arguments
     *
     * * `user_ids` - The list of users identifiers received in the error
     * * `transaction_id` - The send queue transaction identifier of the local
     * echo the send error applies to
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `withdrawVerificationAndResend`(`userIds`: List<kotlin.String>, `sendHandle`: SendHandle) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_room_withdraw_verification_and_resend(
                thisPtr,
                FfiConverterSequenceString.lower(`userIds`),FfiConverterTypeSendHandle.lower(`sendHandle`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    

    
    
    companion object
    
}

public object FfiConverterTypeRoom: FfiConverter<Room, Pointer> {

    override fun lower(value: Room): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): Room {
        return Room(value)
    }

    override fun read(buf: ByteBuffer): Room {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Room) = 8UL

    override fun write(value: Room, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * A helper for performing room searches in the room directory.
 * The way this is intended to be used is:
 *
 * 1. Register a callback using [`RoomDirectorySearch::results`].
 * 2. Start the room search with [`RoomDirectorySearch::search`].
 * 3. To get more results, use [`RoomDirectorySearch::next_page`].
 */
public interface RoomDirectorySearchInterface {
    
    /**
     * Get whether the search is at the last page.
     */
    suspend fun `isAtLastPage`(): kotlin.Boolean
    
    /**
     * Get the number of pages that have been loaded so far.
     */
    suspend fun `loadedPages`(): kotlin.UInt
    
    /**
     * Asks the server for the next page of the current search.
     */
    suspend fun `nextPage`()
    
    /**
     * Registers a callback to receive new search results when starting a
     * search or getting new paginated results.
     */
    suspend fun `results`(`listener`: RoomDirectorySearchEntriesListener): TaskHandle
    
    /**
     * Starts a filtered search for the server.
     *
     * If the `filter` is not provided it will search for all the rooms.
     * You can specify a `batch_size` to control the number of rooms to fetch
     * per request.
     *
     * If the `via_server` is not provided it will search in the current
     * homeserver by default.
     *
     * This method will clear the current search results and start a new one.
     */
    suspend fun `search`(`filter`: kotlin.String?, `batchSize`: kotlin.UInt, `viaServerName`: kotlin.String?)
    
    companion object
}

/**
 * A helper for performing room searches in the room directory.
 * The way this is intended to be used is:
 *
 * 1. Register a callback using [`RoomDirectorySearch::results`].
 * 2. Start the room search with [`RoomDirectorySearch::search`].
 * 3. To get more results, use [`RoomDirectorySearch::next_page`].
 */
open class RoomDirectorySearch: Disposable, AutoCloseable, RoomDirectorySearchInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_roomdirectorysearch(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_roomdirectorysearch(pointer!!, status)
        }
    }

    
    /**
     * Get whether the search is at the last page.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `isAtLastPage`() : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_is_at_last_page(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Get the number of pages that have been loaded so far.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `loadedPages`() : kotlin.UInt {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_loaded_pages(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_u32(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_u32(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_u32(future) },
        // lift function
        { FfiConverterUInt.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Asks the server for the next page of the current search.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `nextPage`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_next_page(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Registers a callback to receive new search results when starting a
     * search or getting new paginated results.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `results`(`listener`: RoomDirectorySearchEntriesListener) : TaskHandle {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_results(
                thisPtr,
                FfiConverterTypeRoomDirectorySearchEntriesListener.lower(`listener`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeTaskHandle.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Starts a filtered search for the server.
     *
     * If the `filter` is not provided it will search for all the rooms.
     * You can specify a `batch_size` to control the number of rooms to fetch
     * per request.
     *
     * If the `via_server` is not provided it will search in the current
     * homeserver by default.
     *
     * This method will clear the current search results and start a new one.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `search`(`filter`: kotlin.String?, `batchSize`: kotlin.UInt, `viaServerName`: kotlin.String?) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_search(
                thisPtr,
                FfiConverterOptionalString.lower(`filter`),FfiConverterUInt.lower(`batchSize`),FfiConverterOptionalString.lower(`viaServerName`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    

    
    
    companion object
    
}

public object FfiConverterTypeRoomDirectorySearch: FfiConverter<RoomDirectorySearch, Pointer> {

    override fun lower(value: RoomDirectorySearch): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): RoomDirectorySearch {
        return RoomDirectorySearch(value)
    }

    override fun read(buf: ByteBuffer): RoomDirectorySearch {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: RoomDirectorySearch) = 8UL

    override fun write(value: RoomDirectorySearch, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface RoomListInterface {
    
    fun `entriesWithDynamicAdapters`(`pageSize`: kotlin.UInt, `listener`: RoomListEntriesListener): RoomListEntriesWithDynamicAdaptersResult
    
    fun `entriesWithDynamicAdaptersWith`(`pageSize`: kotlin.UInt, `enableLatestEventSorter`: kotlin.Boolean, `listener`: RoomListEntriesListener): RoomListEntriesWithDynamicAdaptersResult
    
    fun `loadingState`(`listener`: RoomListLoadingStateListener): RoomListLoadingStateResult
    
    fun `room`(`roomId`: kotlin.String): Room
    
    companion object
}

open class RoomList: Disposable, AutoCloseable, RoomListInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_roomlist(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_roomlist(pointer!!, status)
        }
    }

    override fun `entriesWithDynamicAdapters`(`pageSize`: kotlin.UInt, `listener`: RoomListEntriesListener): RoomListEntriesWithDynamicAdaptersResult {
            return FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roomlist_entries_with_dynamic_adapters(
        it, FfiConverterUInt.lower(`pageSize`),FfiConverterTypeRoomListEntriesListener.lower(`listener`),_status)
}
    }
    )
    }
    

    override fun `entriesWithDynamicAdaptersWith`(`pageSize`: kotlin.UInt, `enableLatestEventSorter`: kotlin.Boolean, `listener`: RoomListEntriesListener): RoomListEntriesWithDynamicAdaptersResult {
            return FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roomlist_entries_with_dynamic_adapters_with(
        it, FfiConverterUInt.lower(`pageSize`),FfiConverterBoolean.lower(`enableLatestEventSorter`),FfiConverterTypeRoomListEntriesListener.lower(`listener`),_status)
}
    }
    )
    }
    

    
    @Throws(RoomListException::class)override fun `loadingState`(`listener`: RoomListLoadingStateListener): RoomListLoadingStateResult {
            return FfiConverterTypeRoomListLoadingStateResult.lift(
    callWithPointer {
    uniffiRustCallWithError(RoomListException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roomlist_loading_state(
        it, FfiConverterTypeRoomListLoadingStateListener.lower(`listener`),_status)
}
    }
    )
    }
    

    
    @Throws(RoomListException::class)override fun `room`(`roomId`: kotlin.String): Room {
            return FfiConverterTypeRoom.lift(
    callWithPointer {
    uniffiRustCallWithError(RoomListException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roomlist_room(
        it, FfiConverterString.lower(`roomId`),_status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

public object FfiConverterTypeRoomList: FfiConverter<RoomList, Pointer> {

    override fun lower(value: RoomList): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): RoomList {
        return RoomList(value)
    }

    override fun read(buf: ByteBuffer): RoomList {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: RoomList) = 8UL

    override fun write(value: RoomList, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface RoomListDynamicEntriesControllerInterface {
    
    fun `addOnePage`()
    
    fun `resetToOnePage`()
    
    fun `setFilter`(`kind`: RoomListEntriesDynamicFilterKind): kotlin.Boolean
    
    companion object
}

open class RoomListDynamicEntriesController: Disposable, AutoCloseable, RoomListDynamicEntriesControllerInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_roomlistdynamicentriescontroller(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_roomlistdynamicentriescontroller(pointer!!, status)
        }
    }

    override fun `addOnePage`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_add_one_page(
        it, _status)
}
    }
    
    

    override fun `resetToOnePage`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_reset_to_one_page(
        it, _status)
}
    }
    
    

    override fun `setFilter`(`kind`: RoomListEntriesDynamicFilterKind): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_set_filter(
        it, FfiConverterTypeRoomListEntriesDynamicFilterKind.lower(`kind`),_status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

public object FfiConverterTypeRoomListDynamicEntriesController: FfiConverter<RoomListDynamicEntriesController, Pointer> {

    override fun lower(value: RoomListDynamicEntriesController): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): RoomListDynamicEntriesController {
        return RoomListDynamicEntriesController(value)
    }

    override fun read(buf: ByteBuffer): RoomListDynamicEntriesController {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: RoomListDynamicEntriesController) = 8UL

    override fun write(value: RoomListDynamicEntriesController, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface RoomListEntriesWithDynamicAdaptersResultInterface {
    
    fun `controller`(): RoomListDynamicEntriesController
    
    fun `entriesStream`(): TaskHandle
    
    companion object
}

open class RoomListEntriesWithDynamicAdaptersResult: Disposable, AutoCloseable, RoomListEntriesWithDynamicAdaptersResultInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_roomlistentrieswithdynamicadaptersresult(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_roomlistentrieswithdynamicadaptersresult(pointer!!, status)
        }
    }

    override fun `controller`(): RoomListDynamicEntriesController {
            return FfiConverterTypeRoomListDynamicEntriesController.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roomlistentrieswithdynamicadaptersresult_controller(
        it, _status)
}
    }
    )
    }
    

    override fun `entriesStream`(): TaskHandle {
            return FfiConverterTypeTaskHandle.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roomlistentrieswithdynamicadaptersresult_entries_stream(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

public object FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult: FfiConverter<RoomListEntriesWithDynamicAdaptersResult, Pointer> {

    override fun lower(value: RoomListEntriesWithDynamicAdaptersResult): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): RoomListEntriesWithDynamicAdaptersResult {
        return RoomListEntriesWithDynamicAdaptersResult(value)
    }

    override fun read(buf: ByteBuffer): RoomListEntriesWithDynamicAdaptersResult {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: RoomListEntriesWithDynamicAdaptersResult) = 8UL

    override fun write(value: RoomListEntriesWithDynamicAdaptersResult, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface RoomListServiceInterface {
    
    suspend fun `allRooms`(): RoomList
    
    fun `room`(`roomId`: kotlin.String): Room
    
    fun `state`(`listener`: RoomListServiceStateListener): TaskHandle
    
    suspend fun `subscribeToRooms`(`roomIds`: List<kotlin.String>)
    
    fun `syncIndicator`(`delayBeforeShowingInMs`: kotlin.UInt, `delayBeforeHidingInMs`: kotlin.UInt, `listener`: RoomListServiceSyncIndicatorListener): TaskHandle
    
    companion object
}

open class RoomListService: Disposable, AutoCloseable, RoomListServiceInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_roomlistservice(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_roomlistservice(pointer!!, status)
        }
    }

    
    @Throws(RoomListException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `allRooms`() : RoomList {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roomlistservice_all_rooms(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeRoomList.lift(it) },
        // Error FFI converter
        RoomListException.ErrorHandler,
    )
    }

    
    @Throws(RoomListException::class)override fun `room`(`roomId`: kotlin.String): Room {
            return FfiConverterTypeRoom.lift(
    callWithPointer {
    uniffiRustCallWithError(RoomListException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roomlistservice_room(
        it, FfiConverterString.lower(`roomId`),_status)
}
    }
    )
    }
    

    override fun `state`(`listener`: RoomListServiceStateListener): TaskHandle {
            return FfiConverterTypeTaskHandle.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roomlistservice_state(
        it, FfiConverterTypeRoomListServiceStateListener.lower(`listener`),_status)
}
    }
    )
    }
    

    
    @Throws(RoomListException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `subscribeToRooms`(`roomIds`: List<kotlin.String>) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roomlistservice_subscribe_to_rooms(
                thisPtr,
                FfiConverterSequenceString.lower(`roomIds`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        RoomListException.ErrorHandler,
    )
    }

    override fun `syncIndicator`(`delayBeforeShowingInMs`: kotlin.UInt, `delayBeforeHidingInMs`: kotlin.UInt, `listener`: RoomListServiceSyncIndicatorListener): TaskHandle {
            return FfiConverterTypeTaskHandle.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roomlistservice_sync_indicator(
        it, FfiConverterUInt.lower(`delayBeforeShowingInMs`),FfiConverterUInt.lower(`delayBeforeHidingInMs`),FfiConverterTypeRoomListServiceSyncIndicatorListener.lower(`listener`),_status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

public object FfiConverterTypeRoomListService: FfiConverter<RoomListService, Pointer> {

    override fun lower(value: RoomListService): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): RoomListService {
        return RoomListService(value)
    }

    override fun read(buf: ByteBuffer): RoomListService {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: RoomListService) = 8UL

    override fun write(value: RoomListService, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface RoomMembersIteratorInterface {
    
    fun `len`(): kotlin.UInt
    
    fun `nextChunk`(`chunkSize`: kotlin.UInt): List<RoomMember>?
    
    companion object
}

open class RoomMembersIterator: Disposable, AutoCloseable, RoomMembersIteratorInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_roommembersiterator(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_roommembersiterator(pointer!!, status)
        }
    }

    override fun `len`(): kotlin.UInt {
            return FfiConverterUInt.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roommembersiterator_len(
        it, _status)
}
    }
    )
    }
    

    override fun `nextChunk`(`chunkSize`: kotlin.UInt): List<RoomMember>? {
            return FfiConverterOptionalSequenceTypeRoomMember.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roommembersiterator_next_chunk(
        it, FfiConverterUInt.lower(`chunkSize`),_status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

public object FfiConverterTypeRoomMembersIterator: FfiConverter<RoomMembersIterator, Pointer> {

    override fun lower(value: RoomMembersIterator): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): RoomMembersIterator {
        return RoomMembersIterator(value)
    }

    override fun read(buf: ByteBuffer): RoomMembersIterator {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: RoomMembersIterator) = 8UL

    override fun write(value: RoomMembersIterator, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface RoomMessageEventContentWithoutRelationInterface {
    
    fun `withMentions`(`mentions`: Mentions): RoomMessageEventContentWithoutRelation
    
    companion object
}

open class RoomMessageEventContentWithoutRelation: Disposable, AutoCloseable, RoomMessageEventContentWithoutRelationInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_roommessageeventcontentwithoutrelation(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_roommessageeventcontentwithoutrelation(pointer!!, status)
        }
    }

    override fun `withMentions`(`mentions`: Mentions): RoomMessageEventContentWithoutRelation {
            return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roommessageeventcontentwithoutrelation_with_mentions(
        it, FfiConverterTypeMentions.lower(`mentions`),_status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

public object FfiConverterTypeRoomMessageEventContentWithoutRelation: FfiConverter<RoomMessageEventContentWithoutRelation, Pointer> {

    override fun lower(value: RoomMessageEventContentWithoutRelation): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): RoomMessageEventContentWithoutRelation {
        return RoomMessageEventContentWithoutRelation(value)
    }

    override fun read(buf: ByteBuffer): RoomMessageEventContentWithoutRelation {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: RoomMessageEventContentWithoutRelation) = 8UL

    override fun write(value: RoomMessageEventContentWithoutRelation, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface RoomPowerLevelsInterface {
    
    /**
     * Returns true if the current user is able to ban in the room.
     */
    fun `canOwnUserBan`(): kotlin.Boolean
    
    /**
     * Returns true if the current user is able to invite in the room.
     */
    fun `canOwnUserInvite`(): kotlin.Boolean
    
    /**
     * Returns true if the current user is able to kick in the room.
     */
    fun `canOwnUserKick`(): kotlin.Boolean
    
    /**
     * Returns true if the current user is able to pin or unpin events in the
     * room.
     */
    fun `canOwnUserPinUnpin`(): kotlin.Boolean
    
    /**
     * Returns true if the current user user is able to redact messages of
     * other users in the room.
     */
    fun `canOwnUserRedactOther`(): kotlin.Boolean
    
    /**
     * Returns true if the current user is able to redact their own messages in
     * the room.
     */
    fun `canOwnUserRedactOwn`(): kotlin.Boolean
    
    /**
     * Returns true if the current user is able to send a specific message type
     * in the room.
     */
    fun `canOwnUserSendMessage`(`message`: MessageLikeEventType): kotlin.Boolean
    
    /**
     * Returns true if the current user is able to send a specific state event
     * type in the room.
     */
    fun `canOwnUserSendState`(`stateEvent`: StateEventType): kotlin.Boolean
    
    /**
     * Returns true if the current user is able to trigger a notification in
     * the room.
     */
    fun `canOwnUserTriggerRoomNotification`(): kotlin.Boolean
    
    /**
     * Returns true if the user with the given user_id is able to ban in the
     * room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    fun `canUserBan`(`userId`: kotlin.String): kotlin.Boolean
    
    /**
     * Returns true if the user with the given user_id is able to invite in the
     * room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    fun `canUserInvite`(`userId`: kotlin.String): kotlin.Boolean
    
    /**
     * Returns true if the user with the given user_id is able to kick in the
     * room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    fun `canUserKick`(`userId`: kotlin.String): kotlin.Boolean
    
    /**
     * Returns true if the user with the given user_id is able to pin or unpin
     * events in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    fun `canUserPinUnpin`(`userId`: kotlin.String): kotlin.Boolean
    
    /**
     * Returns true if the user with the given user_id is able to redact
     * messages of other users in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    fun `canUserRedactOther`(`userId`: kotlin.String): kotlin.Boolean
    
    /**
     * Returns true if the user with the given user_id is able to redact
     * their own messages in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    fun `canUserRedactOwn`(`userId`: kotlin.String): kotlin.Boolean
    
    /**
     * Returns true if the user with the given user_id is able to send a
     * specific message type in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    fun `canUserSendMessage`(`userId`: kotlin.String, `message`: MessageLikeEventType): kotlin.Boolean
    
    /**
     * Returns true if the user with the given user_id is able to send a
     * specific state event type in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    fun `canUserSendState`(`userId`: kotlin.String, `stateEvent`: StateEventType): kotlin.Boolean
    
    /**
     * Returns true if the user with the given user_id is able to trigger a
     * notification in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    fun `canUserTriggerRoomNotification`(`userId`: kotlin.String): kotlin.Boolean
    
    /**
     * Gets a map with the `UserId` of users with power levels other than `0`
     * and their power level.
     */
    fun `userPowerLevels`(): Map<kotlin.String, kotlin.Long>
    
    fun `values`(): RoomPowerLevelsValues
    
    companion object
}

open class RoomPowerLevels: Disposable, AutoCloseable, RoomPowerLevelsInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_roompowerlevels(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_roompowerlevels(pointer!!, status)
        }
    }

    
    /**
     * Returns true if the current user is able to ban in the room.
     */override fun `canOwnUserBan`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_ban(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Returns true if the current user is able to invite in the room.
     */override fun `canOwnUserInvite`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_invite(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Returns true if the current user is able to kick in the room.
     */override fun `canOwnUserKick`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_kick(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Returns true if the current user is able to pin or unpin events in the
     * room.
     */override fun `canOwnUserPinUnpin`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_pin_unpin(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Returns true if the current user user is able to redact messages of
     * other users in the room.
     */override fun `canOwnUserRedactOther`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_redact_other(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Returns true if the current user is able to redact their own messages in
     * the room.
     */override fun `canOwnUserRedactOwn`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_redact_own(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Returns true if the current user is able to send a specific message type
     * in the room.
     */override fun `canOwnUserSendMessage`(`message`: MessageLikeEventType): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_send_message(
        it, FfiConverterTypeMessageLikeEventType.lower(`message`),_status)
}
    }
    )
    }
    

    
    /**
     * Returns true if the current user is able to send a specific state event
     * type in the room.
     */override fun `canOwnUserSendState`(`stateEvent`: StateEventType): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_send_state(
        it, FfiConverterTypeStateEventType.lower(`stateEvent`),_status)
}
    }
    )
    }
    

    
    /**
     * Returns true if the current user is able to trigger a notification in
     * the room.
     */override fun `canOwnUserTriggerRoomNotification`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_trigger_room_notification(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Returns true if the user with the given user_id is able to ban in the
     * room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    @Throws(ClientException::class)override fun `canUserBan`(`userId`: kotlin.String): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_ban(
        it, FfiConverterString.lower(`userId`),_status)
}
    }
    )
    }
    

    
    /**
     * Returns true if the user with the given user_id is able to invite in the
     * room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    @Throws(ClientException::class)override fun `canUserInvite`(`userId`: kotlin.String): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_invite(
        it, FfiConverterString.lower(`userId`),_status)
}
    }
    )
    }
    

    
    /**
     * Returns true if the user with the given user_id is able to kick in the
     * room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    @Throws(ClientException::class)override fun `canUserKick`(`userId`: kotlin.String): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_kick(
        it, FfiConverterString.lower(`userId`),_status)
}
    }
    )
    }
    

    
    /**
     * Returns true if the user with the given user_id is able to pin or unpin
     * events in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    @Throws(ClientException::class)override fun `canUserPinUnpin`(`userId`: kotlin.String): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_pin_unpin(
        it, FfiConverterString.lower(`userId`),_status)
}
    }
    )
    }
    

    
    /**
     * Returns true if the user with the given user_id is able to redact
     * messages of other users in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    @Throws(ClientException::class)override fun `canUserRedactOther`(`userId`: kotlin.String): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_redact_other(
        it, FfiConverterString.lower(`userId`),_status)
}
    }
    )
    }
    

    
    /**
     * Returns true if the user with the given user_id is able to redact
     * their own messages in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    @Throws(ClientException::class)override fun `canUserRedactOwn`(`userId`: kotlin.String): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_redact_own(
        it, FfiConverterString.lower(`userId`),_status)
}
    }
    )
    }
    

    
    /**
     * Returns true if the user with the given user_id is able to send a
     * specific message type in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    @Throws(ClientException::class)override fun `canUserSendMessage`(`userId`: kotlin.String, `message`: MessageLikeEventType): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_send_message(
        it, FfiConverterString.lower(`userId`),FfiConverterTypeMessageLikeEventType.lower(`message`),_status)
}
    }
    )
    }
    

    
    /**
     * Returns true if the user with the given user_id is able to send a
     * specific state event type in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    @Throws(ClientException::class)override fun `canUserSendState`(`userId`: kotlin.String, `stateEvent`: StateEventType): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_send_state(
        it, FfiConverterString.lower(`userId`),FfiConverterTypeStateEventType.lower(`stateEvent`),_status)
}
    }
    )
    }
    

    
    /**
     * Returns true if the user with the given user_id is able to trigger a
     * notification in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    @Throws(ClientException::class)override fun `canUserTriggerRoomNotification`(`userId`: kotlin.String): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_trigger_room_notification(
        it, FfiConverterString.lower(`userId`),_status)
}
    }
    )
    }
    

    
    /**
     * Gets a map with the `UserId` of users with power levels other than `0`
     * and their power level.
     */override fun `userPowerLevels`(): Map<kotlin.String, kotlin.Long> {
            return FfiConverterMapStringLong.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_user_power_levels(
        it, _status)
}
    }
    )
    }
    

    override fun `values`(): RoomPowerLevelsValues {
            return FfiConverterTypeRoomPowerLevelsValues.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_values(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

public object FfiConverterTypeRoomPowerLevels: FfiConverter<RoomPowerLevels, Pointer> {

    override fun lower(value: RoomPowerLevels): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): RoomPowerLevels {
        return RoomPowerLevels(value)
    }

    override fun read(buf: ByteBuffer): RoomPowerLevels {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: RoomPowerLevels) = 8UL

    override fun write(value: RoomPowerLevels, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * A room preview for a room. It's intended to be used to represent rooms that
 * aren't joined yet.
 */
public interface RoomPreviewInterface {
    
    /**
     * Forget the room if we had access to it, and it was left or banned.
     */
    suspend fun `forget`()
    
    /**
     * Returns the room info the preview contains.
     */
    fun `info`(): RoomPreviewInfo
    
    /**
     * Get the user who created the invite, if any.
     */
    suspend fun `inviter`(): RoomMember?
    
    /**
     * Leave the room if the room preview state is either joined, invited or
     * knocked.
     *
     * If rejecting an invite then also forget it as an extra layer of
     * protection against spam attacks.
     *
     * Will return an error otherwise.
     */
    suspend fun `leave`()
    
    /**
     * Get the membership details for the current user.
     */
    suspend fun `ownMembershipDetails`(): RoomMemberWithSenderInfo?
    
    companion object
}

/**
 * A room preview for a room. It's intended to be used to represent rooms that
 * aren't joined yet.
 */
open class RoomPreview: Disposable, AutoCloseable, RoomPreviewInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_roompreview(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_roompreview(pointer!!, status)
        }
    }

    
    /**
     * Forget the room if we had access to it, and it was left or banned.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `forget`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roompreview_forget(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Returns the room info the preview contains.
     */override fun `info`(): RoomPreviewInfo {
            return FfiConverterTypeRoomPreviewInfo.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roompreview_info(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the user who created the invite, if any.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `inviter`() : RoomMember? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roompreview_inviter(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeRoomMember.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Leave the room if the room preview state is either joined, invited or
     * knocked.
     *
     * If rejecting an invite then also forget it as an extra layer of
     * protection against spam attacks.
     *
     * Will return an error otherwise.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `leave`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roompreview_leave(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Get the membership details for the current user.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `ownMembershipDetails`() : RoomMemberWithSenderInfo? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_roompreview_own_membership_details(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalTypeRoomMemberWithSenderInfo.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}

public object FfiConverterTypeRoomPreview: FfiConverter<RoomPreview, Pointer> {

    override fun lower(value: RoomPreview): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): RoomPreview {
        return RoomPreview(value)
    }

    override fun read(buf: ByteBuffer): RoomPreview {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: RoomPreview) = 8UL

    override fun write(value: RoomPreview, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface SendAttachmentJoinHandleInterface {
    
    /**
     * Cancel the current sending task.
     *
     * A subsequent call to [`Self::join`] will return immediately.
     */
    fun `cancel`()
    
    /**
     * Wait until the attachment has been sent.
     *
     * If the sending had been cancelled, will return immediately.
     */
    suspend fun `join`()
    
    companion object
}

open class SendAttachmentJoinHandle: Disposable, AutoCloseable, SendAttachmentJoinHandleInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_sendattachmentjoinhandle(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_sendattachmentjoinhandle(pointer!!, status)
        }
    }

    
    /**
     * Cancel the current sending task.
     *
     * A subsequent call to [`Self::join`] will return immediately.
     */override fun `cancel`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_sendattachmentjoinhandle_cancel(
        it, _status)
}
    }
    
    

    
    /**
     * Wait until the attachment has been sent.
     *
     * If the sending had been cancelled, will return immediately.
     */
    @Throws(RoomException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `join`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_sendattachmentjoinhandle_join(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        RoomException.ErrorHandler,
    )
    }

    

    
    
    companion object
    
}

public object FfiConverterTypeSendAttachmentJoinHandle: FfiConverter<SendAttachmentJoinHandle, Pointer> {

    override fun lower(value: SendAttachmentJoinHandle): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): SendAttachmentJoinHandle {
        return SendAttachmentJoinHandle(value)
    }

    override fun read(buf: ByteBuffer): SendAttachmentJoinHandle {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: SendAttachmentJoinHandle) = 8UL

    override fun write(value: SendAttachmentJoinHandle, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface SendGalleryJoinHandleInterface {
    
    /**
     * Cancel the current sending task.
     *
     * A subsequent call to [`Self::join`] will return immediately.
     */
    fun `cancel`()
    
    /**
     * Wait until the gallery has been sent.
     *
     * If the sending had been cancelled, will return immediately.
     */
    suspend fun `join`()
    
    companion object
}

open class SendGalleryJoinHandle: Disposable, AutoCloseable, SendGalleryJoinHandleInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_sendgalleryjoinhandle(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_sendgalleryjoinhandle(pointer!!, status)
        }
    }

    
    /**
     * Cancel the current sending task.
     *
     * A subsequent call to [`Self::join`] will return immediately.
     */override fun `cancel`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_sendgalleryjoinhandle_cancel(
        it, _status)
}
    }
    
    

    
    /**
     * Wait until the gallery has been sent.
     *
     * If the sending had been cancelled, will return immediately.
     */
    @Throws(RoomException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `join`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_sendgalleryjoinhandle_join(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        RoomException.ErrorHandler,
    )
    }

    

    
    
    companion object
    
}

public object FfiConverterTypeSendGalleryJoinHandle: FfiConverter<SendGalleryJoinHandle, Pointer> {

    override fun lower(value: SendGalleryJoinHandle): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): SendGalleryJoinHandle {
        return SendGalleryJoinHandle(value)
    }

    override fun read(buf: ByteBuffer): SendGalleryJoinHandle {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: SendGalleryJoinHandle) = 8UL

    override fun write(value: SendGalleryJoinHandle, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * A handle to perform actions onto a local echo.
 */
public interface SendHandleInterface {
    
    /**
     * Try to abort the sending of the current event.
     *
     * If this returns `true`, then the sending could be aborted, because the
     * event hasn't been sent yet. Otherwise, if this returns `false`, the
     * event had already been sent and could not be aborted.
     *
     * This has an effect only on the first call; subsequent calls will always
     * return `false`.
     */
    suspend fun `abort`(): kotlin.Boolean
    
    /**
     * Attempt to manually resend messages that failed to send due to issues
     * that should now have been fixed.
     *
     * This is useful for example, when there's a
     * `SessionRecipientCollectionError::VerifiedUserChangedIdentity` error;
     * the user may have re-verified on a different device and would now
     * like to send the failed message that's waiting on this device.
     *
     * # Arguments
     *
     * * `transaction_id` - The send queue transaction identifier of the local
     * echo that should be unwedged.
     */
    suspend fun `tryResend`()
    
    companion object
}

/**
 * A handle to perform actions onto a local echo.
 */
open class SendHandle: Disposable, AutoCloseable, SendHandleInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_sendhandle(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_sendhandle(pointer!!, status)
        }
    }

    
    /**
     * Try to abort the sending of the current event.
     *
     * If this returns `true`, then the sending could be aborted, because the
     * event hasn't been sent yet. Otherwise, if this returns `false`, the
     * event had already been sent and could not be aborted.
     *
     * This has an effect only on the first call; subsequent calls will always
     * return `false`.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `abort`() : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_sendhandle_abort(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Attempt to manually resend messages that failed to send due to issues
     * that should now have been fixed.
     *
     * This is useful for example, when there's a
     * `SessionRecipientCollectionError::VerifiedUserChangedIdentity` error;
     * the user may have re-verified on a different device and would now
     * like to send the failed message that's waiting on this device.
     *
     * # Arguments
     *
     * * `transaction_id` - The send queue transaction identifier of the local
     * echo that should be unwedged.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `tryResend`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_sendhandle_try_resend(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    

    
    
    companion object
    
}

public object FfiConverterTypeSendHandle: FfiConverter<SendHandle, Pointer> {

    override fun lower(value: SendHandle): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): SendHandle {
        return SendHandle(value)
    }

    override fun read(buf: ByteBuffer): SendHandle {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: SendHandle) = 8UL

    override fun write(value: SendHandle, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface SessionVerificationControllerInterface {
    
    /**
     * Accept the previously acknowledged verification request
     */
    suspend fun `acceptVerificationRequest`()
    
    /**
     * Set this particular request as the currently active one and register for
     * events pertaining it.
     * * `sender_id` - The user requesting verification.
     * * `flow_id` - - The ID that uniquely identifies the verification flow.
     */
    suspend fun `acknowledgeVerificationRequest`(`senderId`: kotlin.String, `flowId`: kotlin.String)
    
    /**
     * Confirm that the short auth strings match on both sides.
     */
    suspend fun `approveVerification`()
    
    /**
     * Cancel the current verification request
     */
    suspend fun `cancelVerification`()
    
    /**
     * Reject the short auth string
     */
    suspend fun `declineVerification`()
    
    /**
     * Request verification for the current device
     */
    suspend fun `requestDeviceVerification`()
    
    /**
     * Request verification for the given user
     */
    suspend fun `requestUserVerification`(`userId`: kotlin.String)
    
    fun `setDelegate`(`delegate`: SessionVerificationControllerDelegate?)
    
    /**
     * Transition the current verification request into a SAS verification
     * flow.
     */
    suspend fun `startSasVerification`()
    
    companion object
}

open class SessionVerificationController: Disposable, AutoCloseable, SessionVerificationControllerInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_sessionverificationcontroller(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_sessionverificationcontroller(pointer!!, status)
        }
    }

    
    /**
     * Accept the previously acknowledged verification request
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `acceptVerificationRequest`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_accept_verification_request(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Set this particular request as the currently active one and register for
     * events pertaining it.
     * * `sender_id` - The user requesting verification.
     * * `flow_id` - - The ID that uniquely identifies the verification flow.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `acknowledgeVerificationRequest`(`senderId`: kotlin.String, `flowId`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_acknowledge_verification_request(
                thisPtr,
                FfiConverterString.lower(`senderId`),FfiConverterString.lower(`flowId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Confirm that the short auth strings match on both sides.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `approveVerification`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_approve_verification(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Cancel the current verification request
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `cancelVerification`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_cancel_verification(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Reject the short auth string
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `declineVerification`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_decline_verification(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Request verification for the current device
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `requestDeviceVerification`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_request_device_verification(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Request verification for the given user
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `requestUserVerification`(`userId`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_request_user_verification(
                thisPtr,
                FfiConverterString.lower(`userId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    override fun `setDelegate`(`delegate`: SessionVerificationControllerDelegate?)
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_set_delegate(
        it, FfiConverterOptionalTypeSessionVerificationControllerDelegate.lower(`delegate`),_status)
}
    }
    
    

    
    /**
     * Transition the current verification request into a SAS verification
     * flow.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `startSasVerification`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_start_sas_verification(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    

    
    
    companion object
    
}

public object FfiConverterTypeSessionVerificationController: FfiConverter<SessionVerificationController, Pointer> {

    override fun lower(value: SessionVerificationController): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): SessionVerificationController {
        return SessionVerificationController(value)
    }

    override fun read(buf: ByteBuffer): SessionVerificationController {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: SessionVerificationController) = 8UL

    override fun write(value: SessionVerificationController, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface SessionVerificationEmojiInterface {
    
    fun `description`(): kotlin.String
    
    fun `symbol`(): kotlin.String
    
    companion object
}

open class SessionVerificationEmoji: Disposable, AutoCloseable, SessionVerificationEmojiInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_sessionverificationemoji(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_sessionverificationemoji(pointer!!, status)
        }
    }

    override fun `description`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_description(
        it, _status)
}
    }
    )
    }
    

    override fun `symbol`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_symbol(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

public object FfiConverterTypeSessionVerificationEmoji: FfiConverter<SessionVerificationEmoji, Pointer> {

    override fun lower(value: SessionVerificationEmoji): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): SessionVerificationEmoji {
        return SessionVerificationEmoji(value)
    }

    override fun read(buf: ByteBuffer): SessionVerificationEmoji {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: SessionVerificationEmoji) = 8UL

    override fun write(value: SessionVerificationEmoji, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * The `SpaceRoomList`represents a paginated list of direct rooms
 * that belong to a particular space.
 *
 * It can be used to paginate through the list (and have live updates on the
 * pagination state) as well as subscribe to changes as rooms are joined or
 * left.
 *
 * The `SpaceRoomList` also automatically subscribes to client room changes
 * and updates the list accordingly as rooms are joined or left.
 */
public interface SpaceRoomListInterface {
    
    /**
     * Ask the list to retrieve the next page if the end hasn't been reached
     * yet. Otherwise it no-ops.
     */
    suspend fun `paginate`()
    
    /**
     * Returns if the room list is currently paginating or not.
     */
    fun `paginationState`(): SpaceRoomListPaginationState
    
    /**
     * Return the current list of rooms.
     */
    fun `rooms`(): List<SpaceRoom>
    
    /**
     * Returns the space of the room list if known.
     */
    fun `space`(): SpaceRoom?
    
    /**
     * Subscribe to pagination updates.
     */
    fun `subscribeToPaginationStateUpdates`(`listener`: SpaceRoomListPaginationStateListener): TaskHandle
    
    /**
     * Subscribes to room list updates.
     */
    fun `subscribeToRoomUpdate`(`listener`: SpaceRoomListEntriesListener): TaskHandle
    
    /**
     * Subscribe to space updates.
     */
    fun `subscribeToSpaceUpdates`(`listener`: SpaceRoomListSpaceListener): TaskHandle
    
    companion object
}

/**
 * The `SpaceRoomList`represents a paginated list of direct rooms
 * that belong to a particular space.
 *
 * It can be used to paginate through the list (and have live updates on the
 * pagination state) as well as subscribe to changes as rooms are joined or
 * left.
 *
 * The `SpaceRoomList` also automatically subscribes to client room changes
 * and updates the list accordingly as rooms are joined or left.
 */
open class SpaceRoomList: Disposable, AutoCloseable, SpaceRoomListInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_spaceroomlist(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_spaceroomlist(pointer!!, status)
        }
    }

    
    /**
     * Ask the list to retrieve the next page if the end hasn't been reached
     * yet. Otherwise it no-ops.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `paginate`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_paginate(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Returns if the room list is currently paginating or not.
     */override fun `paginationState`(): SpaceRoomListPaginationState {
            return FfiConverterTypeSpaceRoomListPaginationState.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_pagination_state(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Return the current list of rooms.
     */override fun `rooms`(): List<SpaceRoom> {
            return FfiConverterSequenceTypeSpaceRoom.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_rooms(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Returns the space of the room list if known.
     */override fun `space`(): SpaceRoom? {
            return FfiConverterOptionalTypeSpaceRoom.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_space(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Subscribe to pagination updates.
     */override fun `subscribeToPaginationStateUpdates`(`listener`: SpaceRoomListPaginationStateListener): TaskHandle {
            return FfiConverterTypeTaskHandle.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_subscribe_to_pagination_state_updates(
        it, FfiConverterTypeSpaceRoomListPaginationStateListener.lower(`listener`),_status)
}
    }
    )
    }
    

    
    /**
     * Subscribes to room list updates.
     */override fun `subscribeToRoomUpdate`(`listener`: SpaceRoomListEntriesListener): TaskHandle {
            return FfiConverterTypeTaskHandle.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_subscribe_to_room_update(
        it, FfiConverterTypeSpaceRoomListEntriesListener.lower(`listener`),_status)
}
    }
    )
    }
    

    
    /**
     * Subscribe to space updates.
     */override fun `subscribeToSpaceUpdates`(`listener`: SpaceRoomListSpaceListener): TaskHandle {
            return FfiConverterTypeTaskHandle.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_subscribe_to_space_updates(
        it, FfiConverterTypeSpaceRoomListSpaceListener.lower(`listener`),_status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

public object FfiConverterTypeSpaceRoomList: FfiConverter<SpaceRoomList, Pointer> {

    override fun lower(value: SpaceRoomList): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): SpaceRoomList {
        return SpaceRoomList(value)
    }

    override fun read(buf: ByteBuffer): SpaceRoomList {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: SpaceRoomList) = 8UL

    override fun write(value: SpaceRoomList, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * The main entry point into the Spaces facilities.
 *
 * The spaces service is responsible for retrieving one's joined rooms,
 * building a graph out of their `m.space.parent` and `m.space.child` state
 * events, and providing access to the top-level spaces and their children.
 */
public interface SpaceServiceInterface {
    
    /**
     * Returns a list of all the top-level joined spaces. It will eagerly
     * compute the latest version and also notify subscribers if there were
     * any changes.
     */
    suspend fun `joinedSpaces`(): List<SpaceRoom>
    
    /**
     * Start a space leave process returning a [`LeaveSpaceHandle`] from which
     * rooms can be retrieved in reversed BFS order starting from the requested
     * `space_id` graph node. If the room is unknown then an error will be
     * returned.
     *
     * Once the rooms to be left are chosen the handle can be used to leave
     * them.
     */
    suspend fun `leaveSpace`(`spaceId`: kotlin.String): LeaveSpaceHandle
    
    /**
     * Returns a `SpaceRoomList` for the given space ID.
     */
    suspend fun `spaceRoomList`(`spaceId`: kotlin.String): SpaceRoomList
    
    /**
     * Subscribes to updates on the joined spaces list. If space rooms are
     * joined or left, the stream will yield diffs that reflect the changes.
     */
    suspend fun `subscribeToJoinedSpaces`(`listener`: SpaceServiceJoinedSpacesListener): TaskHandle
    
    companion object
}

/**
 * The main entry point into the Spaces facilities.
 *
 * The spaces service is responsible for retrieving one's joined rooms,
 * building a graph out of their `m.space.parent` and `m.space.child` state
 * events, and providing access to the top-level spaces and their children.
 */
open class SpaceService: Disposable, AutoCloseable, SpaceServiceInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_spaceservice(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_spaceservice(pointer!!, status)
        }
    }

    
    /**
     * Returns a list of all the top-level joined spaces. It will eagerly
     * compute the latest version and also notify subscribers if there were
     * any changes.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `joinedSpaces`() : List<SpaceRoom> {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_spaceservice_joined_spaces(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterSequenceTypeSpaceRoom.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Start a space leave process returning a [`LeaveSpaceHandle`] from which
     * rooms can be retrieved in reversed BFS order starting from the requested
     * `space_id` graph node. If the room is unknown then an error will be
     * returned.
     *
     * Once the rooms to be left are chosen the handle can be used to leave
     * them.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `leaveSpace`(`spaceId`: kotlin.String) : LeaveSpaceHandle {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_spaceservice_leave_space(
                thisPtr,
                FfiConverterString.lower(`spaceId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeLeaveSpaceHandle.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Returns a `SpaceRoomList` for the given space ID.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `spaceRoomList`(`spaceId`: kotlin.String) : SpaceRoomList {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_spaceservice_space_room_list(
                thisPtr,
                FfiConverterString.lower(`spaceId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeSpaceRoomList.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Subscribes to updates on the joined spaces list. If space rooms are
     * joined or left, the stream will yield diffs that reflect the changes.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `subscribeToJoinedSpaces`(`listener`: SpaceServiceJoinedSpacesListener) : TaskHandle {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_spaceservice_subscribe_to_joined_spaces(
                thisPtr,
                FfiConverterTypeSpaceServiceJoinedSpacesListener.lower(`listener`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeTaskHandle.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}

public object FfiConverterTypeSpaceService: FfiConverter<SpaceService, Pointer> {

    override fun lower(value: SpaceService): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): SpaceService {
        return SpaceService(value)
    }

    override fun read(buf: ByteBuffer): SpaceService {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: SpaceService) = 8UL

    override fun write(value: SpaceService, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface SpanInterface {
    
    fun `enter`()
    
    fun `exit`()
    
    fun `isNone`(): kotlin.Boolean
    
    companion object
}

open class Span: Disposable, AutoCloseable, SpanInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }
    /**
     * Create a span originating at the given callsite (file, line and column).
     *
     * The target should be something like a module path, and can be referenced
     * in the filter string given to `setup_tracing`. `level` and `target`
     * for a callsite are fixed at the first creation of a span for that
     * callsite and can not be changed afterwards, i.e. the level and
     * target passed for second and following creation of a span with the same
     * callsite will be ignored.
     *
     * This function leaks a little bit of memory for each unique (file +
     * line + level + target + name) it is called with. Please make sure that
     * the number of different combinations of those parameters this can be
     * called with is constant in the final executable.
     *
     * For a span to have an effect, you must `.enter()` it at the start of a
     * logical unit of work and `.exit()` it at the end of the same (including
     * on failure). Entering registers the span in thread-local storage, so
     * future calls to `log_event` on the same thread are able to attach the
     * events they create to the span, exiting unregisters it. For this to
     * work, exiting a span must be done on the same thread where it was
     * entered. It is possible to enter a span on multiple threads, in which
     * case it should also be exited on all of them individually; that is,
     * unless you *want* the span to be attached to all further events created
     * on that thread.
     */
    constructor(`file`: kotlin.String, `line`: kotlin.UInt?, `level`: LogLevel, `target`: kotlin.String, `name`: kotlin.String) :
        this(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_constructor_span_new(
        FfiConverterString.lower(`file`),FfiConverterOptionalUInt.lower(`line`),FfiConverterTypeLogLevel.lower(`level`),FfiConverterString.lower(`target`),FfiConverterString.lower(`name`),_status)
}
    )

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_span(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_span(pointer!!, status)
        }
    }

    override fun `enter`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_span_enter(
        it, _status)
}
    }
    
    

    override fun `exit`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_span_exit(
        it, _status)
}
    }
    
    

    override fun `isNone`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_span_is_none(
        it, _status)
}
    }
    )
    }
    

    

    
    companion object {
         fun `current`(): Span {
            return FfiConverterTypeSpan.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_constructor_span_current(
        _status)
}
    )
    }
    

        
    }
    
}

public object FfiConverterTypeSpan: FfiConverter<Span, Pointer> {

    override fun lower(value: Span): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): Span {
        return Span(value)
    }

    override fun read(buf: ByteBuffer): Span {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Span) = 8UL

    override fun write(value: Span, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * An object encapsulating the SSO login flow
 */
public interface SsoHandlerInterface {
    
    /**
     * Completes the SSO login process.
     */
    suspend fun `finish`(`callbackUrl`: kotlin.String)
    
    /**
     * Returns the URL for starting SSO authentication. The URL should be
     * opened in a web view. Once the web view succeeds, call `finish` with
     * the callback URL.
     */
    fun `url`(): kotlin.String
    
    companion object
}

/**
 * An object encapsulating the SSO login flow
 */
open class SsoHandler: Disposable, AutoCloseable, SsoHandlerInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_ssohandler(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_ssohandler(pointer!!, status)
        }
    }

    
    /**
     * Completes the SSO login process.
     */
    @Throws(SsoException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `finish`(`callbackUrl`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_ssohandler_finish(
                thisPtr,
                FfiConverterString.lower(`callbackUrl`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        SsoException.ErrorHandler,
    )
    }

    
    /**
     * Returns the URL for starting SSO authentication. The URL should be
     * opened in a web view. Once the web view succeeds, call `finish` with
     * the callback URL.
     */override fun `url`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_ssohandler_url(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

public object FfiConverterTypeSsoHandler: FfiConverter<SsoHandler, Pointer> {

    override fun lower(value: SsoHandler): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): SsoHandler {
        return SsoHandler(value)
    }

    override fun read(buf: ByteBuffer): SsoHandler {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: SsoHandler) = 8UL

    override fun write(value: SsoHandler, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface SyncServiceInterface {
    
    /**
     * Force expiring both sliding sync sessions.
     *
     * This ensures that the sync service is stopped before expiring both
     * sessions. It should be used sparingly, as it will cause a restart of
     * the sessions on the server as well.
     */
    suspend fun `expireSessions`()
    
    fun `roomListService`(): RoomListService
    
    suspend fun `start`()
    
    fun `state`(`listener`: SyncServiceStateObserver): TaskHandle
    
    suspend fun `stop`()
    
    companion object
}

open class SyncService: Disposable, AutoCloseable, SyncServiceInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_syncservice(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_syncservice(pointer!!, status)
        }
    }

    
    /**
     * Force expiring both sliding sync sessions.
     *
     * This ensures that the sync service is stopped before expiring both
     * sessions. It should be used sparingly, as it will cause a restart of
     * the sessions on the server as well.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `expireSessions`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_syncservice_expire_sessions(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `roomListService`(): RoomListService {
            return FfiConverterTypeRoomListService.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_syncservice_room_list_service(
        it, _status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `start`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_syncservice_start(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `state`(`listener`: SyncServiceStateObserver): TaskHandle {
            return FfiConverterTypeTaskHandle.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_syncservice_state(
        it, FfiConverterTypeSyncServiceStateObserver.lower(`listener`),_status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `stop`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_syncservice_stop(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}

public object FfiConverterTypeSyncService: FfiConverter<SyncService, Pointer> {

    override fun lower(value: SyncService): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): SyncService {
        return SyncService(value)
    }

    override fun read(buf: ByteBuffer): SyncService {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: SyncService) = 8UL

    override fun write(value: SyncService, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface SyncServiceBuilderInterface {
    
    suspend fun `finish`(): SyncService
    
    fun `withCrossProcessLock`(): SyncServiceBuilder
    
    /**
     * Enable the "offline" mode for the [`SyncService`].
     */
    fun `withOfflineMode`(): SyncServiceBuilder
    
    fun `withSharePos`(`enable`: kotlin.Boolean): SyncServiceBuilder
    
    companion object
}

open class SyncServiceBuilder: Disposable, AutoCloseable, SyncServiceBuilderInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_syncservicebuilder(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_syncservicebuilder(pointer!!, status)
        }
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `finish`() : SyncService {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_finish(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeSyncService.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    override fun `withCrossProcessLock`(): SyncServiceBuilder {
            return FfiConverterTypeSyncServiceBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_cross_process_lock(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Enable the "offline" mode for the [`SyncService`].
     */override fun `withOfflineMode`(): SyncServiceBuilder {
            return FfiConverterTypeSyncServiceBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_offline_mode(
        it, _status)
}
    }
    )
    }
    

    override fun `withSharePos`(`enable`: kotlin.Boolean): SyncServiceBuilder {
            return FfiConverterTypeSyncServiceBuilder.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_share_pos(
        it, FfiConverterBoolean.lower(`enable`),_status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

public object FfiConverterTypeSyncServiceBuilder: FfiConverter<SyncServiceBuilder, Pointer> {

    override fun lower(value: SyncServiceBuilder): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): SyncServiceBuilder {
        return SyncServiceBuilder(value)
    }

    override fun read(buf: ByteBuffer): SyncServiceBuilder {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: SyncServiceBuilder) = 8UL

    override fun write(value: SyncServiceBuilder, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * A task handle is a way to keep the handle a task running by itself in
 * detached mode.
 *
 * It's a thin wrapper around [`JoinHandle`].
 */
public interface TaskHandleInterface {
    
    fun `cancel`()
    
    /**
     * Check whether the handle is finished.
     */
    fun `isFinished`(): kotlin.Boolean
    
    companion object
}

/**
 * A task handle is a way to keep the handle a task running by itself in
 * detached mode.
 *
 * It's a thin wrapper around [`JoinHandle`].
 */
open class TaskHandle: Disposable, AutoCloseable, TaskHandleInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_taskhandle(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_taskhandle(pointer!!, status)
        }
    }

    override fun `cancel`()
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_taskhandle_cancel(
        it, _status)
}
    }
    
    

    
    /**
     * Check whether the handle is finished.
     */override fun `isFinished`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_taskhandle_is_finished(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

public object FfiConverterTypeTaskHandle: FfiConverter<TaskHandle, Pointer> {

    override fun lower(value: TaskHandle): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): TaskHandle {
        return TaskHandle(value)
    }

    override fun read(buf: ByteBuffer): TaskHandle {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: TaskHandle) = 8UL

    override fun write(value: TaskHandle, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface ThreadSummaryInterface {
    
    fun `latestEvent`(): EmbeddedEventDetails
    
    fun `numReplies`(): kotlin.ULong
    
    companion object
}

open class ThreadSummary: Disposable, AutoCloseable, ThreadSummaryInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_threadsummary(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_threadsummary(pointer!!, status)
        }
    }

    override fun `latestEvent`(): EmbeddedEventDetails {
            return FfiConverterTypeEmbeddedEventDetails.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_threadsummary_latest_event(
        it, _status)
}
    }
    )
    }
    

    override fun `numReplies`(): kotlin.ULong {
            return FfiConverterULong.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_threadsummary_num_replies(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

public object FfiConverterTypeThreadSummary: FfiConverter<ThreadSummary, Pointer> {

    override fun lower(value: ThreadSummary): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): ThreadSummary {
        return ThreadSummary(value)
    }

    override fun read(buf: ByteBuffer): ThreadSummary {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ThreadSummary) = 8UL

    override fun write(value: ThreadSummary, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface TimelineInterface {
    
    suspend fun `addListener`(`listener`: TimelineListener): TaskHandle
    
    fun `createMessageContent`(`msgType`: MessageType): RoomMessageEventContentWithoutRelation?
    
    suspend fun `createPoll`(`question`: kotlin.String, `answers`: List<kotlin.String>, `maxSelections`: kotlin.UByte, `pollKind`: PollKind)
    
    /**
     * Edits an event from the timeline.
     *
     * If it was a local event, this will *try* to edit it, if it was not
     * being sent already. If the event was a remote event, then it will be
     * redacted by sending an edit request to the server.
     *
     * Returns whether the edit did happen. It can only return false for
     * local events that are being processed.
     */
    suspend fun `edit`(`eventOrTransactionId`: EventOrTransactionId, `newContent`: EditedContent)
    
    suspend fun `endPoll`(`pollStartEventId`: kotlin.String, `text`: kotlin.String)
    
    suspend fun `fetchDetailsForEvent`(`eventId`: kotlin.String)
    
    suspend fun `fetchMembers`()
    
    /**
     * Get the current timeline item for the given event ID, if any.
     *
     * Will return a remote event, *or* a local echo that has been sent but not
     * yet replaced by a remote echo.
     *
     * It's preferable to store the timeline items in the model for your UI, if
     * possible, instead of just storing IDs and coming back to the timeline
     * object to look up items.
     */
    suspend fun `getEventTimelineItemByEventId`(`eventId`: kotlin.String): EventTimelineItem
    
    /**
     * Returns the [`EventId`] of the latest event in the timeline.
     */
    suspend fun `latestEventId`(): kotlin.String?
    
    /**
     * Load the reply details for the given event id.
     *
     * This will return an `InReplyToDetails` object that contains the details
     * which will either be ready or an error.
     */
    suspend fun `loadReplyDetails`(`eventIdStr`: kotlin.String): InReplyToDetails
    
    /**
     * Mark the room as read by trying to attach an *unthreaded* read receipt
     * to the latest room event.
     *
     * This works even if the latest event belongs to a thread, as a threaded
     * reply also belongs to the unthreaded timeline. No threaded receipt
     * will be sent here (see also #3123).
     */
    suspend fun `markAsRead`(`receiptType`: ReceiptType)
    
    /**
     * Paginate backwards, whether we are in focused mode or in live mode.
     *
     * Returns whether we hit the start of the timeline or not.
     */
    suspend fun `paginateBackwards`(`numEvents`: kotlin.UShort): kotlin.Boolean
    
    /**
     * Paginate forwards, whether we are in focused mode or in live mode.
     *
     * Returns whether we hit the end of the timeline or not.
     */
    suspend fun `paginateForwards`(`numEvents`: kotlin.UShort): kotlin.Boolean
    
    /**
     * Adds a new pinned event by sending an updated `m.room.pinned_events`
     * event containing the new event id.
     *
     * Returns `true` if we sent the request, `false` if the event was already
     * pinned.
     */
    suspend fun `pinEvent`(`eventId`: kotlin.String): kotlin.Boolean
    
    /**
     * Redacts an event from the timeline.
     *
     * Only works for events that exist as timeline items.
     *
     * If it was a local event, this will *try* to cancel it, if it was not
     * being sent already. If the event was a remote event, then it will be
     * redacted by sending a redaction request to the server.
     *
     * Will return an error if the event couldn't be redacted.
     */
    suspend fun `redactEvent`(`eventOrTransactionId`: EventOrTransactionId, `reason`: kotlin.String?)
    
    fun `retryDecryption`(`sessionIds`: List<kotlin.String>)
    
    /**
     * Queues an event in the room's send queue so it's processed for
     * sending later.
     *
     * Returns an abort handle that allows to abort sending, if it hasn't
     * happened yet.
     */
    suspend fun `send`(`msg`: RoomMessageEventContentWithoutRelation): SendHandle
    
    fun `sendAudio`(`params`: UploadParameters, `audioInfo`: AudioInfo): SendAttachmentJoinHandle
    
    fun `sendFile`(`params`: UploadParameters, `fileInfo`: FileInfo): SendAttachmentJoinHandle
    
    fun `sendGallery`(`params`: GalleryUploadParameters, `itemInfos`: List<GalleryItemInfo>): SendGalleryJoinHandle
    
    fun `sendImage`(`params`: UploadParameters, `thumbnailSource`: UploadSource?, `imageInfo`: ImageInfo): SendAttachmentJoinHandle
    
    suspend fun `sendLocation`(`body`: kotlin.String, `geoUri`: kotlin.String, `description`: kotlin.String?, `zoomLevel`: kotlin.UByte?, `assetType`: AssetType?, `repliedToEventId`: kotlin.String?)
    
    suspend fun `sendPollResponse`(`pollStartEventId`: kotlin.String, `answers`: List<kotlin.String>)
    
    suspend fun `sendReadReceipt`(`receiptType`: ReceiptType, `eventId`: kotlin.String)
    
    /**
     * Send a reply.
     *
     * If the replied to event has a thread relation, it is forwarded on the
     * reply so that clients that support threads can render the reply
     * inside the thread.
     */
    suspend fun `sendReply`(`msg`: RoomMessageEventContentWithoutRelation, `eventId`: kotlin.String)
    
    fun `sendVideo`(`params`: UploadParameters, `thumbnailSource`: UploadSource?, `videoInfo`: VideoInfo): SendAttachmentJoinHandle
    
    fun `sendVoiceMessage`(`params`: UploadParameters, `audioInfo`: AudioInfo, `waveform`: List<kotlin.Float>): SendAttachmentJoinHandle
    
    suspend fun `subscribeToBackPaginationStatus`(`listener`: PaginationStatusListener): TaskHandle
    
    /**
     * Toggle a reaction on an event.
     *
     * Adds or redacts a reaction based on the state of the reaction at the
     * time it is called.
     *
     * This method works both on local echoes and remote items.
     *
     * When redacting a previous reaction, the redaction reason is not set.
     *
     * Ensures that only one reaction is sent at a time to avoid race
     * conditions and spamming the homeserver with requests.
     *
     * Returns `true` if the reaction was added, `false` if it was removed.
     */
    suspend fun `toggleReaction`(`itemId`: EventOrTransactionId, `key`: kotlin.String): kotlin.Boolean
    
    /**
     * Adds a new pinned event by sending an updated `m.room.pinned_events`
     * event without the event id we want to remove.
     *
     * Returns `true` if we sent the request, `false` if the event wasn't
     * pinned
     */
    suspend fun `unpinEvent`(`eventId`: kotlin.String): kotlin.Boolean
    
    companion object
}

open class Timeline: Disposable, AutoCloseable, TimelineInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_timeline(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_timeline(pointer!!, status)
        }
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `addListener`(`listener`: TimelineListener) : TaskHandle {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_add_listener(
                thisPtr,
                FfiConverterTypeTimelineListener.lower(`listener`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeTaskHandle.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `createMessageContent`(`msgType`: MessageType): RoomMessageEventContentWithoutRelation? {
            return FfiConverterOptionalTypeRoomMessageEventContentWithoutRelation.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_create_message_content(
        it, FfiConverterTypeMessageType.lower(`msgType`),_status)
}
    }
    )
    }
    

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `createPoll`(`question`: kotlin.String, `answers`: List<kotlin.String>, `maxSelections`: kotlin.UByte, `pollKind`: PollKind) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_create_poll(
                thisPtr,
                FfiConverterString.lower(`question`),FfiConverterSequenceString.lower(`answers`),FfiConverterUByte.lower(`maxSelections`),FfiConverterTypePollKind.lower(`pollKind`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Edits an event from the timeline.
     *
     * If it was a local event, this will *try* to edit it, if it was not
     * being sent already. If the event was a remote event, then it will be
     * redacted by sending an edit request to the server.
     *
     * Returns whether the edit did happen. It can only return false for
     * local events that are being processed.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `edit`(`eventOrTransactionId`: EventOrTransactionId, `newContent`: EditedContent) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_edit(
                thisPtr,
                FfiConverterTypeEventOrTransactionId.lower(`eventOrTransactionId`),FfiConverterTypeEditedContent.lower(`newContent`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `endPoll`(`pollStartEventId`: kotlin.String, `text`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_end_poll(
                thisPtr,
                FfiConverterString.lower(`pollStartEventId`),FfiConverterString.lower(`text`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `fetchDetailsForEvent`(`eventId`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_fetch_details_for_event(
                thisPtr,
                FfiConverterString.lower(`eventId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `fetchMembers`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_fetch_members(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Get the current timeline item for the given event ID, if any.
     *
     * Will return a remote event, *or* a local echo that has been sent but not
     * yet replaced by a remote echo.
     *
     * It's preferable to store the timeline items in the model for your UI, if
     * possible, instead of just storing IDs and coming back to the timeline
     * object to look up items.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getEventTimelineItemByEventId`(`eventId`: kotlin.String) : EventTimelineItem {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_get_event_timeline_item_by_event_id(
                thisPtr,
                FfiConverterString.lower(`eventId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeEventTimelineItem.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Returns the [`EventId`] of the latest event in the timeline.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `latestEventId`() : kotlin.String? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_latest_event_id(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalString.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     * Load the reply details for the given event id.
     *
     * This will return an `InReplyToDetails` object that contains the details
     * which will either be ready or an error.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `loadReplyDetails`(`eventIdStr`: kotlin.String) : InReplyToDetails {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_load_reply_details(
                thisPtr,
                FfiConverterString.lower(`eventIdStr`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeInReplyToDetails.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Mark the room as read by trying to attach an *unthreaded* read receipt
     * to the latest room event.
     *
     * This works even if the latest event belongs to a thread, as a threaded
     * reply also belongs to the unthreaded timeline. No threaded receipt
     * will be sent here (see also #3123).
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `markAsRead`(`receiptType`: ReceiptType) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_mark_as_read(
                thisPtr,
                FfiConverterTypeReceiptType.lower(`receiptType`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Paginate backwards, whether we are in focused mode or in live mode.
     *
     * Returns whether we hit the start of the timeline or not.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `paginateBackwards`(`numEvents`: kotlin.UShort) : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_paginate_backwards(
                thisPtr,
                FfiConverterUShort.lower(`numEvents`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Paginate forwards, whether we are in focused mode or in live mode.
     *
     * Returns whether we hit the end of the timeline or not.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `paginateForwards`(`numEvents`: kotlin.UShort) : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_paginate_forwards(
                thisPtr,
                FfiConverterUShort.lower(`numEvents`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Adds a new pinned event by sending an updated `m.room.pinned_events`
     * event containing the new event id.
     *
     * Returns `true` if we sent the request, `false` if the event was already
     * pinned.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `pinEvent`(`eventId`: kotlin.String) : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_pin_event(
                thisPtr,
                FfiConverterString.lower(`eventId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Redacts an event from the timeline.
     *
     * Only works for events that exist as timeline items.
     *
     * If it was a local event, this will *try* to cancel it, if it was not
     * being sent already. If the event was a remote event, then it will be
     * redacted by sending a redaction request to the server.
     *
     * Will return an error if the event couldn't be redacted.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `redactEvent`(`eventOrTransactionId`: EventOrTransactionId, `reason`: kotlin.String?) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_redact_event(
                thisPtr,
                FfiConverterTypeEventOrTransactionId.lower(`eventOrTransactionId`),FfiConverterOptionalString.lower(`reason`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    override fun `retryDecryption`(`sessionIds`: List<kotlin.String>)
        = 
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_retry_decryption(
        it, FfiConverterSequenceString.lower(`sessionIds`),_status)
}
    }
    
    

    
    /**
     * Queues an event in the room's send queue so it's processed for
     * sending later.
     *
     * Returns an abort handle that allows to abort sending, if it hasn't
     * happened yet.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `send`(`msg`: RoomMessageEventContentWithoutRelation) : SendHandle {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_send(
                thisPtr,
                FfiConverterTypeRoomMessageEventContentWithoutRelation.lower(`msg`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeSendHandle.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(RoomException::class)override fun `sendAudio`(`params`: UploadParameters, `audioInfo`: AudioInfo): SendAttachmentJoinHandle {
            return FfiConverterTypeSendAttachmentJoinHandle.lift(
    callWithPointer {
    uniffiRustCallWithError(RoomException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_send_audio(
        it, FfiConverterTypeUploadParameters.lower(`params`),FfiConverterTypeAudioInfo.lower(`audioInfo`),_status)
}
    }
    )
    }
    

    
    @Throws(RoomException::class)override fun `sendFile`(`params`: UploadParameters, `fileInfo`: FileInfo): SendAttachmentJoinHandle {
            return FfiConverterTypeSendAttachmentJoinHandle.lift(
    callWithPointer {
    uniffiRustCallWithError(RoomException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_send_file(
        it, FfiConverterTypeUploadParameters.lower(`params`),FfiConverterTypeFileInfo.lower(`fileInfo`),_status)
}
    }
    )
    }
    

    
    @Throws(RoomException::class)override fun `sendGallery`(`params`: GalleryUploadParameters, `itemInfos`: List<GalleryItemInfo>): SendGalleryJoinHandle {
            return FfiConverterTypeSendGalleryJoinHandle.lift(
    callWithPointer {
    uniffiRustCallWithError(RoomException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_send_gallery(
        it, FfiConverterTypeGalleryUploadParameters.lower(`params`),FfiConverterSequenceTypeGalleryItemInfo.lower(`itemInfos`),_status)
}
    }
    )
    }
    

    
    @Throws(RoomException::class)override fun `sendImage`(`params`: UploadParameters, `thumbnailSource`: UploadSource?, `imageInfo`: ImageInfo): SendAttachmentJoinHandle {
            return FfiConverterTypeSendAttachmentJoinHandle.lift(
    callWithPointer {
    uniffiRustCallWithError(RoomException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_send_image(
        it, FfiConverterTypeUploadParameters.lower(`params`),FfiConverterOptionalTypeUploadSource.lower(`thumbnailSource`),FfiConverterTypeImageInfo.lower(`imageInfo`),_status)
}
    }
    )
    }
    

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `sendLocation`(`body`: kotlin.String, `geoUri`: kotlin.String, `description`: kotlin.String?, `zoomLevel`: kotlin.UByte?, `assetType`: AssetType?, `repliedToEventId`: kotlin.String?) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_send_location(
                thisPtr,
                FfiConverterString.lower(`body`),FfiConverterString.lower(`geoUri`),FfiConverterOptionalString.lower(`description`),FfiConverterOptionalUByte.lower(`zoomLevel`),FfiConverterOptionalTypeAssetType.lower(`assetType`),FfiConverterOptionalString.lower(`repliedToEventId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `sendPollResponse`(`pollStartEventId`: kotlin.String, `answers`: List<kotlin.String>) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_send_poll_response(
                thisPtr,
                FfiConverterString.lower(`pollStartEventId`),FfiConverterSequenceString.lower(`answers`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `sendReadReceipt`(`receiptType`: ReceiptType, `eventId`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_send_read_receipt(
                thisPtr,
                FfiConverterTypeReceiptType.lower(`receiptType`),FfiConverterString.lower(`eventId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Send a reply.
     *
     * If the replied to event has a thread relation, it is forwarded on the
     * reply so that clients that support threads can render the reply
     * inside the thread.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `sendReply`(`msg`: RoomMessageEventContentWithoutRelation, `eventId`: kotlin.String) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_send_reply(
                thisPtr,
                FfiConverterTypeRoomMessageEventContentWithoutRelation.lower(`msg`),FfiConverterString.lower(`eventId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    @Throws(RoomException::class)override fun `sendVideo`(`params`: UploadParameters, `thumbnailSource`: UploadSource?, `videoInfo`: VideoInfo): SendAttachmentJoinHandle {
            return FfiConverterTypeSendAttachmentJoinHandle.lift(
    callWithPointer {
    uniffiRustCallWithError(RoomException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_send_video(
        it, FfiConverterTypeUploadParameters.lower(`params`),FfiConverterOptionalTypeUploadSource.lower(`thumbnailSource`),FfiConverterTypeVideoInfo.lower(`videoInfo`),_status)
}
    }
    )
    }
    

    
    @Throws(RoomException::class)override fun `sendVoiceMessage`(`params`: UploadParameters, `audioInfo`: AudioInfo, `waveform`: List<kotlin.Float>): SendAttachmentJoinHandle {
            return FfiConverterTypeSendAttachmentJoinHandle.lift(
    callWithPointer {
    uniffiRustCallWithError(RoomException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_send_voice_message(
        it, FfiConverterTypeUploadParameters.lower(`params`),FfiConverterTypeAudioInfo.lower(`audioInfo`),FfiConverterSequenceFloat.lower(`waveform`),_status)
}
    }
    )
    }
    

    
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `subscribeToBackPaginationStatus`(`listener`: PaginationStatusListener) : TaskHandle {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_subscribe_to_back_pagination_status(
                thisPtr,
                FfiConverterTypePaginationStatusListener.lower(`listener`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_pointer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_pointer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_pointer(future) },
        // lift function
        { FfiConverterTypeTaskHandle.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Toggle a reaction on an event.
     *
     * Adds or redacts a reaction based on the state of the reaction at the
     * time it is called.
     *
     * This method works both on local echoes and remote items.
     *
     * When redacting a previous reaction, the redaction reason is not set.
     *
     * Ensures that only one reaction is sent at a time to avoid race
     * conditions and spamming the homeserver with requests.
     *
     * Returns `true` if the reaction was added, `false` if it was removed.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `toggleReaction`(`itemId`: EventOrTransactionId, `key`: kotlin.String) : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_toggle_reaction(
                thisPtr,
                FfiConverterTypeEventOrTransactionId.lower(`itemId`),FfiConverterString.lower(`key`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * Adds a new pinned event by sending an updated `m.room.pinned_events`
     * event without the event id we want to remove.
     *
     * Returns `true` if we sent the request, `false` if the event wasn't
     * pinned
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `unpinEvent`(`eventId`: kotlin.String) : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timeline_unpin_event(
                thisPtr,
                FfiConverterString.lower(`eventId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    

    
    
    companion object
    
}

public object FfiConverterTypeTimeline: FfiConverter<Timeline, Pointer> {

    override fun lower(value: Timeline): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): Timeline {
        return Timeline(value)
    }

    override fun read(buf: ByteBuffer): Timeline {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Timeline) = 8UL

    override fun write(value: Timeline, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface TimelineEventInterface {
    
    fun `eventId`(): kotlin.String
    
    fun `eventType`(): TimelineEventType
    
    fun `senderId`(): kotlin.String
    
    /**
     * Returns the thread root event id for the event, if it's part of a
     * thread.
     */
    fun `threadRootEventId`(): kotlin.String?
    
    fun `timestamp`(): Timestamp
    
    companion object
}

open class TimelineEvent: Disposable, AutoCloseable, TimelineEventInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_timelineevent(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_timelineevent(pointer!!, status)
        }
    }

    override fun `eventId`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timelineevent_event_id(
        it, _status)
}
    }
    )
    }
    

    
    @Throws(ClientException::class)override fun `eventType`(): TimelineEventType {
            return FfiConverterTypeTimelineEventType.lift(
    callWithPointer {
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timelineevent_event_type(
        it, _status)
}
    }
    )
    }
    

    override fun `senderId`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timelineevent_sender_id(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Returns the thread root event id for the event, if it's part of a
     * thread.
     */override fun `threadRootEventId`(): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timelineevent_thread_root_event_id(
        it, _status)
}
    }
    )
    }
    

    override fun `timestamp`(): Timestamp {
            return FfiConverterTypeTimestamp.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timelineevent_timestamp(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

public object FfiConverterTypeTimelineEvent: FfiConverter<TimelineEvent, Pointer> {

    override fun lower(value: TimelineEvent): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): TimelineEvent {
        return TimelineEvent(value)
    }

    override fun read(buf: ByteBuffer): TimelineEvent {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: TimelineEvent) = 8UL

    override fun write(value: TimelineEvent, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface TimelineEventTypeFilterInterface {
    
    companion object
}

open class TimelineEventTypeFilter: Disposable, AutoCloseable, TimelineEventTypeFilterInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_timelineeventtypefilter(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_timelineeventtypefilter(pointer!!, status)
        }
    }

    

    
    companion object {
         fun `exclude`(`eventTypes`: List<FilterTimelineEventType>): TimelineEventTypeFilter {
            return FfiConverterTypeTimelineEventTypeFilter.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_constructor_timelineeventtypefilter_exclude(
        FfiConverterSequenceTypeFilterTimelineEventType.lower(`eventTypes`),_status)
}
    )
    }
    

         fun `include`(`eventTypes`: List<FilterTimelineEventType>): TimelineEventTypeFilter {
            return FfiConverterTypeTimelineEventTypeFilter.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_constructor_timelineeventtypefilter_include(
        FfiConverterSequenceTypeFilterTimelineEventType.lower(`eventTypes`),_status)
}
    )
    }
    

        
    }
    
}

public object FfiConverterTypeTimelineEventTypeFilter: FfiConverter<TimelineEventTypeFilter, Pointer> {

    override fun lower(value: TimelineEventTypeFilter): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): TimelineEventTypeFilter {
        return TimelineEventTypeFilter(value)
    }

    override fun read(buf: ByteBuffer): TimelineEventTypeFilter {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: TimelineEventTypeFilter) = 8UL

    override fun write(value: TimelineEventTypeFilter, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface TimelineItemInterface {
    
    fun `asEvent`(): EventTimelineItem?
    
    fun `asVirtual`(): VirtualTimelineItem?
    
    fun `fmtDebug`(): kotlin.String
    
    /**
     * An opaque unique identifier for this timeline item.
     */
    fun `uniqueId`(): TimelineUniqueId
    
    companion object
}

open class TimelineItem: Disposable, AutoCloseable, TimelineItemInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_timelineitem(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_timelineitem(pointer!!, status)
        }
    }

    override fun `asEvent`(): EventTimelineItem? {
            return FfiConverterOptionalTypeEventTimelineItem.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_event(
        it, _status)
}
    }
    )
    }
    

    override fun `asVirtual`(): VirtualTimelineItem? {
            return FfiConverterOptionalTypeVirtualTimelineItem.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_virtual(
        it, _status)
}
    }
    )
    }
    

    override fun `fmtDebug`(): kotlin.String {
            return FfiConverterString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timelineitem_fmt_debug(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * An opaque unique identifier for this timeline item.
     */override fun `uniqueId`(): TimelineUniqueId {
            return FfiConverterTypeTimelineUniqueId.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_timelineitem_unique_id(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

public object FfiConverterTypeTimelineItem: FfiConverter<TimelineItem, Pointer> {

    override fun lower(value: TimelineItem): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): TimelineItem {
        return TimelineItem(value)
    }

    override fun read(buf: ByteBuffer): TimelineItem {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: TimelineItem) = 8UL

    override fun write(value: TimelineItem, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface UnreadNotificationsCountInterface {
    
    fun `hasNotifications`(): kotlin.Boolean
    
    fun `highlightCount`(): kotlin.UInt
    
    fun `notificationCount`(): kotlin.UInt
    
    companion object
}

open class UnreadNotificationsCount: Disposable, AutoCloseable, UnreadNotificationsCountInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_unreadnotificationscount(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_unreadnotificationscount(pointer!!, status)
        }
    }

    override fun `hasNotifications`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_has_notifications(
        it, _status)
}
    }
    )
    }
    

    override fun `highlightCount`(): kotlin.UInt {
            return FfiConverterUInt.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_highlight_count(
        it, _status)
}
    }
    )
    }
    

    override fun `notificationCount`(): kotlin.UInt {
            return FfiConverterUInt.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_notification_count(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}

public object FfiConverterTypeUnreadNotificationsCount: FfiConverter<UnreadNotificationsCount, Pointer> {

    override fun lower(value: UnreadNotificationsCount): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): UnreadNotificationsCount {
        return UnreadNotificationsCount(value)
    }

    override fun read(buf: ByteBuffer): UnreadNotificationsCount {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: UnreadNotificationsCount) = 8UL

    override fun write(value: UnreadNotificationsCount, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * The E2EE identity of a user.
 */
public interface UserIdentityInterface {
    
    /**
     * Was this identity previously verified, and is no longer?
     */
    fun `hasVerificationViolation`(): kotlin.Boolean
    
    /**
     * Is the user identity considered to be verified.
     *
     * If the identity belongs to another user, our own user identity needs to
     * be verified as well for the identity to be considered to be verified.
     */
    fun `isVerified`(): kotlin.Boolean
    
    /**
     * Get the public part of the Master key of this user identity.
     *
     * The public part of the Master key is usually used to uniquely identify
     * the identity.
     *
     * Returns None if the master key does not actually contain any keys.
     */
    fun `masterKey`(): kotlin.String?
    
    /**
     * Remember this identity, ensuring it does not result in a pin violation.
     *
     * When we first see a user, we assume their cryptographic identity has not
     * been tampered with by the homeserver or another entity with
     * man-in-the-middle capabilities. We remember this identity and call this
     * action "pinning".
     *
     * If the identity presented for the user changes later on, the newly
     * presented identity is considered to be in "pin violation". This
     * method explicitly accepts the new identity, allowing it to replace
     * the previously pinned one and bringing it out of pin violation.
     *
     * UIs should display a warning to the user when encountering an identity
     * which is not verified and is in pin violation.
     */
    suspend fun `pin`()
    
    /**
     * True if we verified this identity at some point in the past.
     *
     * To reset this latch back to `false`, one must call
     * [`UserIdentity::withdraw_verification()`].
     */
    fun `wasPreviouslyVerified`(): kotlin.Boolean
    
    /**
     * Remove the requirement for this identity to be verified.
     *
     * If an identity was previously verified and is not anymore it will be
     * reported to the user. In order to remove this notice users have to
     * verify again or to withdraw the verification requirement.
     */
    suspend fun `withdrawVerification`()
    
    companion object
}

/**
 * The E2EE identity of a user.
 */
open class UserIdentity: Disposable, AutoCloseable, UserIdentityInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_useridentity(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_useridentity(pointer!!, status)
        }
    }

    
    /**
     * Was this identity previously verified, and is no longer?
     */override fun `hasVerificationViolation`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_useridentity_has_verification_violation(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Is the user identity considered to be verified.
     *
     * If the identity belongs to another user, our own user identity needs to
     * be verified as well for the identity to be considered to be verified.
     */override fun `isVerified`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_useridentity_is_verified(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the public part of the Master key of this user identity.
     *
     * The public part of the Master key is usually used to uniquely identify
     * the identity.
     *
     * Returns None if the master key does not actually contain any keys.
     */override fun `masterKey`(): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_useridentity_master_key(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Remember this identity, ensuring it does not result in a pin violation.
     *
     * When we first see a user, we assume their cryptographic identity has not
     * been tampered with by the homeserver or another entity with
     * man-in-the-middle capabilities. We remember this identity and call this
     * action "pinning".
     *
     * If the identity presented for the user changes later on, the newly
     * presented identity is considered to be in "pin violation". This
     * method explicitly accepts the new identity, allowing it to replace
     * the previously pinned one and bringing it out of pin violation.
     *
     * UIs should display a warning to the user when encountering an identity
     * which is not verified and is in pin violation.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `pin`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_useridentity_pin(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    
    /**
     * True if we verified this identity at some point in the past.
     *
     * To reset this latch back to `false`, one must call
     * [`UserIdentity::withdraw_verification()`].
     */override fun `wasPreviouslyVerified`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithPointer {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_useridentity_was_previously_verified(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Remove the requirement for this identity to be verified.
     *
     * If an identity was previously verified and is not anymore it will be
     * reported to the user. In order to remove this notice users have to
     * verify again or to withdraw the verification requirement.
     */
    @Throws(ClientException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `withdrawVerification`() {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_useridentity_withdraw_verification(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        ClientException.ErrorHandler,
    )
    }

    

    
    
    companion object
    
}

public object FfiConverterTypeUserIdentity: FfiConverter<UserIdentity, Pointer> {

    override fun lower(value: UserIdentity): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): UserIdentity {
        return UserIdentity(value)
    }

    override fun read(buf: ByteBuffer): UserIdentity {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: UserIdentity) = 8UL

    override fun write(value: UserIdentity, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * An object that handles all interactions of a widget living inside a webview
 * or IFrame with the Matrix world.
 */
public interface WidgetDriverInterface {
    
    suspend fun `run`(`room`: Room, `capabilitiesProvider`: WidgetCapabilitiesProvider)
    
    companion object
}

/**
 * An object that handles all interactions of a widget living inside a webview
 * or IFrame with the Matrix world.
 */
open class WidgetDriver: Disposable, AutoCloseable, WidgetDriverInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_widgetdriver(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_widgetdriver(pointer!!, status)
        }
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `run`(`room`: Room, `capabilitiesProvider`: WidgetCapabilitiesProvider) {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_widgetdriver_run(
                thisPtr,
                FfiConverterTypeRoom.lower(`room`),FfiConverterTypeWidgetCapabilitiesProvider.lower(`capabilitiesProvider`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}

public object FfiConverterTypeWidgetDriver: FfiConverter<WidgetDriver, Pointer> {

    override fun lower(value: WidgetDriver): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): WidgetDriver {
        return WidgetDriver(value)
    }

    override fun read(buf: ByteBuffer): WidgetDriver {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: WidgetDriver) = 8UL

    override fun write(value: WidgetDriver, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * A handle that encapsulates the communication between a widget driver and the
 * corresponding widget (inside a webview or IFrame).
 */
public interface WidgetDriverHandleInterface {
    
    /**
     * Receive a message from the widget driver.
     *
     * The message must be passed on to the widget.
     *
     * Returns `None` if the widget driver is no longer running.
     */
    suspend fun `recv`(): kotlin.String?
    
    /**
     *
     * Returns `false` if the widget driver is no longer running.
     */
    suspend fun `send`(`msg`: kotlin.String): kotlin.Boolean
    
    companion object
}

/**
 * A handle that encapsulates the communication between a widget driver and the
 * corresponding widget (inside a webview or IFrame).
 */
open class WidgetDriverHandle: Disposable, AutoCloseable, WidgetDriverHandleInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_free_widgetdriverhandle(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_clone_widgetdriverhandle(pointer!!, status)
        }
    }

    
    /**
     * Receive a message from the widget driver.
     *
     * The message must be passed on to the widget.
     *
     * Returns `None` if the widget driver is no longer running.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `recv`() : kotlin.String? {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_widgetdriverhandle_recv(
                thisPtr,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterOptionalString.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    /**
     *
     * Returns `false` if the widget driver is no longer running.
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `send`(`msg`: kotlin.String) : kotlin.Boolean {
        return uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_method_widgetdriverhandle_send(
                thisPtr,
                FfiConverterString.lower(`msg`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_i8(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_i8(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_i8(future) },
        // lift function
        { FfiConverterBoolean.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    

    
    
    companion object
    
}

public object FfiConverterTypeWidgetDriverHandle: FfiConverter<WidgetDriverHandle, Pointer> {

    override fun lower(value: WidgetDriverHandle): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): WidgetDriverHandle {
        return WidgetDriverHandle(value)
    }

    override fun read(buf: ByteBuffer): WidgetDriverHandle {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: WidgetDriverHandle) = 8UL

    override fun write(value: WidgetDriverHandle, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}



/**
 * Progress of an operation in abstract units.
 *
 * Contrary to [`TransmissionProgress`], this allows tracking the progress
 * of sending or receiving a payload in estimated pseudo units representing a
 * percentage. This is helpful in cases where the exact progress in bytes isn't
 * known, for instance, because encryption (which changes the size) happens on
 * the fly.
 */
data class AbstractProgress (
    /**
     * How many units were already transferred.
     */
    var `current`: kotlin.ULong, 
    /**
     * How many units there are in total.
     */
    var `total`: kotlin.ULong
) {
    
    companion object
}

public object FfiConverterTypeAbstractProgress: FfiConverterRustBuffer<AbstractProgress> {
    override fun read(buf: ByteBuffer): AbstractProgress {
        return AbstractProgress(
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: AbstractProgress) = (
            FfiConverterULong.allocationSize(value.`current`) +
            FfiConverterULong.allocationSize(value.`total`)
    )

    override fun write(value: AbstractProgress, buf: ByteBuffer) {
            FfiConverterULong.write(value.`current`, buf)
            FfiConverterULong.write(value.`total`, buf)
    }
}



data class AudioInfo (
    var `duration`: java.time.Duration?, 
    var `size`: kotlin.ULong?, 
    var `mimetype`: kotlin.String?
) {
    
    companion object
}

public object FfiConverterTypeAudioInfo: FfiConverterRustBuffer<AudioInfo> {
    override fun read(buf: ByteBuffer): AudioInfo {
        return AudioInfo(
            FfiConverterOptionalDuration.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: AudioInfo) = (
            FfiConverterOptionalDuration.allocationSize(value.`duration`) +
            FfiConverterOptionalULong.allocationSize(value.`size`) +
            FfiConverterOptionalString.allocationSize(value.`mimetype`)
    )

    override fun write(value: AudioInfo, buf: ByteBuffer) {
            FfiConverterOptionalDuration.write(value.`duration`, buf)
            FfiConverterOptionalULong.write(value.`size`, buf)
            FfiConverterOptionalString.write(value.`mimetype`, buf)
    }
}



data class AudioMessageContent (
    /**
     * The computed filename, for use in a client.
     */
    var `filename`: kotlin.String, 
    var `caption`: kotlin.String?, 
    var `formattedCaption`: FormattedBody?, 
    var `source`: MediaSource, 
    var `info`: AudioInfo?, 
    var `audio`: UnstableAudioDetailsContent?, 
    var `voice`: UnstableVoiceContent?
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
        Disposable.destroy(this.`filename`)
    
        Disposable.destroy(this.`caption`)
    
        Disposable.destroy(this.`formattedCaption`)
    
        Disposable.destroy(this.`source`)
    
        Disposable.destroy(this.`info`)
    
        Disposable.destroy(this.`audio`)
    
        Disposable.destroy(this.`voice`)
    
    }
    
    companion object
}

public object FfiConverterTypeAudioMessageContent: FfiConverterRustBuffer<AudioMessageContent> {
    override fun read(buf: ByteBuffer): AudioMessageContent {
        return AudioMessageContent(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalTypeFormattedBody.read(buf),
            FfiConverterTypeMediaSource.read(buf),
            FfiConverterOptionalTypeAudioInfo.read(buf),
            FfiConverterOptionalTypeUnstableAudioDetailsContent.read(buf),
            FfiConverterOptionalTypeUnstableVoiceContent.read(buf),
        )
    }

    override fun allocationSize(value: AudioMessageContent) = (
            FfiConverterString.allocationSize(value.`filename`) +
            FfiConverterOptionalString.allocationSize(value.`caption`) +
            FfiConverterOptionalTypeFormattedBody.allocationSize(value.`formattedCaption`) +
            FfiConverterTypeMediaSource.allocationSize(value.`source`) +
            FfiConverterOptionalTypeAudioInfo.allocationSize(value.`info`) +
            FfiConverterOptionalTypeUnstableAudioDetailsContent.allocationSize(value.`audio`) +
            FfiConverterOptionalTypeUnstableVoiceContent.allocationSize(value.`voice`)
    )

    override fun write(value: AudioMessageContent, buf: ByteBuffer) {
            FfiConverterString.write(value.`filename`, buf)
            FfiConverterOptionalString.write(value.`caption`, buf)
            FfiConverterOptionalTypeFormattedBody.write(value.`formattedCaption`, buf)
            FfiConverterTypeMediaSource.write(value.`source`, buf)
            FfiConverterOptionalTypeAudioInfo.write(value.`info`, buf)
            FfiConverterOptionalTypeUnstableAudioDetailsContent.write(value.`audio`, buf)
            FfiConverterOptionalTypeUnstableVoiceContent.write(value.`voice`, buf)
    }
}



data class AuthDataPasswordDetails (
    /**
     * One of the user's identifiers.
     */
    var `identifier`: kotlin.String, 
    /**
     * The plaintext password.
     */
    var `password`: kotlin.String
) {
    
    companion object
}

public object FfiConverterTypeAuthDataPasswordDetails: FfiConverterRustBuffer<AuthDataPasswordDetails> {
    override fun read(buf: ByteBuffer): AuthDataPasswordDetails {
        return AuthDataPasswordDetails(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: AuthDataPasswordDetails) = (
            FfiConverterString.allocationSize(value.`identifier`) +
            FfiConverterString.allocationSize(value.`password`)
    )

    override fun write(value: AuthDataPasswordDetails, buf: ByteBuffer) {
            FfiConverterString.write(value.`identifier`, buf)
            FfiConverterString.write(value.`password`, buf)
    }
}



data class ClientProperties (
    /**
     * The client_id provides the widget with the option to behave differently
     * for different clients. e.g org.example.ios.
     */
    var `clientId`: kotlin.String, 
    /**
     * The language tag the client is set to e.g. en-us. (Undefined and invalid
     * becomes: `en-US`)
     */
    var `languageTag`: kotlin.String?, 
    /**
     * A string describing the theme (dark, light) or org.example.dark.
     * (default: `light`)
     */
    var `theme`: kotlin.String?
) {
    
    companion object
}

public object FfiConverterTypeClientProperties: FfiConverterRustBuffer<ClientProperties> {
    override fun read(buf: ByteBuffer): ClientProperties {
        return ClientProperties(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: ClientProperties) = (
            FfiConverterString.allocationSize(value.`clientId`) +
            FfiConverterOptionalString.allocationSize(value.`languageTag`) +
            FfiConverterOptionalString.allocationSize(value.`theme`)
    )

    override fun write(value: ClientProperties, buf: ByteBuffer) {
            FfiConverterString.write(value.`clientId`, buf)
            FfiConverterOptionalString.write(value.`languageTag`, buf)
            FfiConverterOptionalString.write(value.`theme`, buf)
    }
}



/**
 * Current draft of the composer for the room.
 */
data class ComposerDraft (
    /**
     * The draft content in plain text.
     */
    var `plainText`: kotlin.String, 
    /**
     * If the message is formatted in HTML, the HTML representation of the
     * message.
     */
    var `htmlText`: kotlin.String?, 
    /**
     * The type of draft.
     */
    var `draftType`: ComposerDraftType, 
    /**
     * Attachments associated with this draft.
     */
    var `attachments`: List<DraftAttachment>
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
        Disposable.destroy(this.`plainText`)
    
        Disposable.destroy(this.`htmlText`)
    
        Disposable.destroy(this.`draftType`)
    
        Disposable.destroy(this.`attachments`)
    
    }
    
    companion object
}

public object FfiConverterTypeComposerDraft: FfiConverterRustBuffer<ComposerDraft> {
    override fun read(buf: ByteBuffer): ComposerDraft {
        return ComposerDraft(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterTypeComposerDraftType.read(buf),
            FfiConverterSequenceTypeDraftAttachment.read(buf),
        )
    }

    override fun allocationSize(value: ComposerDraft) = (
            FfiConverterString.allocationSize(value.`plainText`) +
            FfiConverterOptionalString.allocationSize(value.`htmlText`) +
            FfiConverterTypeComposerDraftType.allocationSize(value.`draftType`) +
            FfiConverterSequenceTypeDraftAttachment.allocationSize(value.`attachments`)
    )

    override fun write(value: ComposerDraft, buf: ByteBuffer) {
            FfiConverterString.write(value.`plainText`, buf)
            FfiConverterOptionalString.write(value.`htmlText`, buf)
            FfiConverterTypeComposerDraftType.write(value.`draftType`, buf)
            FfiConverterSequenceTypeDraftAttachment.write(value.`attachments`, buf)
    }
}



/**
 * Like [`SimplePushRule`], but with an additional `conditions` field.
 */
data class ConditionalPushRule (
    /**
     * Actions to determine if and how a notification is delivered for events
     * matching this rule.
     */
    var `actions`: List<Action>, 
    /**
     * Whether this is a default rule, or has been set explicitly.
     */
    var `default`: kotlin.Boolean, 
    /**
     * Whether the push rule is enabled or not.
     */
    var `enabled`: kotlin.Boolean, 
    /**
     * The ID of this rule.
     */
    var `ruleId`: kotlin.String, 
    /**
     * The conditions that must hold true for an event in order for a rule to
     * be applied to an event.
     *
     * A rule with no conditions always matches.
     */
    var `conditions`: List<PushCondition>
) {
    
    companion object
}

public object FfiConverterTypeConditionalPushRule: FfiConverterRustBuffer<ConditionalPushRule> {
    override fun read(buf: ByteBuffer): ConditionalPushRule {
        return ConditionalPushRule(
            FfiConverterSequenceTypeAction.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterString.read(buf),
            FfiConverterSequenceTypePushCondition.read(buf),
        )
    }

    override fun allocationSize(value: ConditionalPushRule) = (
            FfiConverterSequenceTypeAction.allocationSize(value.`actions`) +
            FfiConverterBoolean.allocationSize(value.`default`) +
            FfiConverterBoolean.allocationSize(value.`enabled`) +
            FfiConverterString.allocationSize(value.`ruleId`) +
            FfiConverterSequenceTypePushCondition.allocationSize(value.`conditions`)
    )

    override fun write(value: ConditionalPushRule, buf: ByteBuffer) {
            FfiConverterSequenceTypeAction.write(value.`actions`, buf)
            FfiConverterBoolean.write(value.`default`, buf)
            FfiConverterBoolean.write(value.`enabled`, buf)
            FfiConverterString.write(value.`ruleId`, buf)
            FfiConverterSequenceTypePushCondition.write(value.`conditions`, buf)
    }
}



data class CreateRoomParameters (
    var `name`: kotlin.String?, 
    var `topic`: kotlin.String? = null, 
    var `isEncrypted`: kotlin.Boolean, 
    var `isDirect`: kotlin.Boolean = false, 
    var `visibility`: RoomVisibility, 
    var `preset`: RoomPreset, 
    var `invite`: List<kotlin.String>? = null, 
    var `avatar`: kotlin.String? = null, 
    var `powerLevelContentOverride`: PowerLevels? = null, 
    var `joinRuleOverride`: JoinRule? = null, 
    var `historyVisibilityOverride`: RoomHistoryVisibility? = null, 
    var `canonicalAlias`: kotlin.String? = null
) {
    
    companion object
}

public object FfiConverterTypeCreateRoomParameters: FfiConverterRustBuffer<CreateRoomParameters> {
    override fun read(buf: ByteBuffer): CreateRoomParameters {
        return CreateRoomParameters(
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterTypeRoomVisibility.read(buf),
            FfiConverterTypeRoomPreset.read(buf),
            FfiConverterOptionalSequenceString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalTypePowerLevels.read(buf),
            FfiConverterOptionalTypeJoinRule.read(buf),
            FfiConverterOptionalTypeRoomHistoryVisibility.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: CreateRoomParameters) = (
            FfiConverterOptionalString.allocationSize(value.`name`) +
            FfiConverterOptionalString.allocationSize(value.`topic`) +
            FfiConverterBoolean.allocationSize(value.`isEncrypted`) +
            FfiConverterBoolean.allocationSize(value.`isDirect`) +
            FfiConverterTypeRoomVisibility.allocationSize(value.`visibility`) +
            FfiConverterTypeRoomPreset.allocationSize(value.`preset`) +
            FfiConverterOptionalSequenceString.allocationSize(value.`invite`) +
            FfiConverterOptionalString.allocationSize(value.`avatar`) +
            FfiConverterOptionalTypePowerLevels.allocationSize(value.`powerLevelContentOverride`) +
            FfiConverterOptionalTypeJoinRule.allocationSize(value.`joinRuleOverride`) +
            FfiConverterOptionalTypeRoomHistoryVisibility.allocationSize(value.`historyVisibilityOverride`) +
            FfiConverterOptionalString.allocationSize(value.`canonicalAlias`)
    )

    override fun write(value: CreateRoomParameters, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`name`, buf)
            FfiConverterOptionalString.write(value.`topic`, buf)
            FfiConverterBoolean.write(value.`isEncrypted`, buf)
            FfiConverterBoolean.write(value.`isDirect`, buf)
            FfiConverterTypeRoomVisibility.write(value.`visibility`, buf)
            FfiConverterTypeRoomPreset.write(value.`preset`, buf)
            FfiConverterOptionalSequenceString.write(value.`invite`, buf)
            FfiConverterOptionalString.write(value.`avatar`, buf)
            FfiConverterOptionalTypePowerLevels.write(value.`powerLevelContentOverride`, buf)
            FfiConverterOptionalTypeJoinRule.write(value.`joinRuleOverride`, buf)
            FfiConverterOptionalTypeRoomHistoryVisibility.write(value.`historyVisibilityOverride`, buf)
            FfiConverterOptionalString.write(value.`canonicalAlias`, buf)
    }
}



data class EmoteMessageContent (
    var `body`: kotlin.String, 
    var `formatted`: FormattedBody?
) {
    
    companion object
}

public object FfiConverterTypeEmoteMessageContent: FfiConverterRustBuffer<EmoteMessageContent> {
    override fun read(buf: ByteBuffer): EmoteMessageContent {
        return EmoteMessageContent(
            FfiConverterString.read(buf),
            FfiConverterOptionalTypeFormattedBody.read(buf),
        )
    }

    override fun allocationSize(value: EmoteMessageContent) = (
            FfiConverterString.allocationSize(value.`body`) +
            FfiConverterOptionalTypeFormattedBody.allocationSize(value.`formatted`)
    )

    override fun write(value: EmoteMessageContent, buf: ByteBuffer) {
            FfiConverterString.write(value.`body`, buf)
            FfiConverterOptionalTypeFormattedBody.write(value.`formatted`, buf)
    }
}



data class EventTimelineItem (
    /**
     * Indicates that an event is remote.
     */
    var `isRemote`: kotlin.Boolean, 
    var `eventOrTransactionId`: EventOrTransactionId, 
    var `sender`: kotlin.String, 
    var `senderProfile`: ProfileDetails, 
    var `isOwn`: kotlin.Boolean, 
    var `isEditable`: kotlin.Boolean, 
    var `content`: TimelineItemContent, 
    var `timestamp`: Timestamp, 
    var `localSendState`: EventSendState?, 
    var `localCreatedAt`: kotlin.ULong?, 
    var `readReceipts`: Map<kotlin.String, Receipt>, 
    var `origin`: EventItemOrigin?, 
    var `canBeRepliedTo`: kotlin.Boolean, 
    var `lazyProvider`: LazyTimelineItemProvider
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
        Disposable.destroy(this.`isRemote`)
    
        Disposable.destroy(this.`eventOrTransactionId`)
    
        Disposable.destroy(this.`sender`)
    
        Disposable.destroy(this.`senderProfile`)
    
        Disposable.destroy(this.`isOwn`)
    
        Disposable.destroy(this.`isEditable`)
    
        Disposable.destroy(this.`content`)
    
        Disposable.destroy(this.`timestamp`)
    
        Disposable.destroy(this.`localSendState`)
    
        Disposable.destroy(this.`localCreatedAt`)
    
        Disposable.destroy(this.`readReceipts`)
    
        Disposable.destroy(this.`origin`)
    
        Disposable.destroy(this.`canBeRepliedTo`)
    
        Disposable.destroy(this.`lazyProvider`)
    
    }
    
    companion object
}

public object FfiConverterTypeEventTimelineItem: FfiConverterRustBuffer<EventTimelineItem> {
    override fun read(buf: ByteBuffer): EventTimelineItem {
        return EventTimelineItem(
            FfiConverterBoolean.read(buf),
            FfiConverterTypeEventOrTransactionId.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeProfileDetails.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterTypeTimelineItemContent.read(buf),
            FfiConverterTypeTimestamp.read(buf),
            FfiConverterOptionalTypeEventSendState.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterMapStringTypeReceipt.read(buf),
            FfiConverterOptionalTypeEventItemOrigin.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterTypeLazyTimelineItemProvider.read(buf),
        )
    }

    override fun allocationSize(value: EventTimelineItem) = (
            FfiConverterBoolean.allocationSize(value.`isRemote`) +
            FfiConverterTypeEventOrTransactionId.allocationSize(value.`eventOrTransactionId`) +
            FfiConverterString.allocationSize(value.`sender`) +
            FfiConverterTypeProfileDetails.allocationSize(value.`senderProfile`) +
            FfiConverterBoolean.allocationSize(value.`isOwn`) +
            FfiConverterBoolean.allocationSize(value.`isEditable`) +
            FfiConverterTypeTimelineItemContent.allocationSize(value.`content`) +
            FfiConverterTypeTimestamp.allocationSize(value.`timestamp`) +
            FfiConverterOptionalTypeEventSendState.allocationSize(value.`localSendState`) +
            FfiConverterOptionalULong.allocationSize(value.`localCreatedAt`) +
            FfiConverterMapStringTypeReceipt.allocationSize(value.`readReceipts`) +
            FfiConverterOptionalTypeEventItemOrigin.allocationSize(value.`origin`) +
            FfiConverterBoolean.allocationSize(value.`canBeRepliedTo`) +
            FfiConverterTypeLazyTimelineItemProvider.allocationSize(value.`lazyProvider`)
    )

    override fun write(value: EventTimelineItem, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`isRemote`, buf)
            FfiConverterTypeEventOrTransactionId.write(value.`eventOrTransactionId`, buf)
            FfiConverterString.write(value.`sender`, buf)
            FfiConverterTypeProfileDetails.write(value.`senderProfile`, buf)
            FfiConverterBoolean.write(value.`isOwn`, buf)
            FfiConverterBoolean.write(value.`isEditable`, buf)
            FfiConverterTypeTimelineItemContent.write(value.`content`, buf)
            FfiConverterTypeTimestamp.write(value.`timestamp`, buf)
            FfiConverterOptionalTypeEventSendState.write(value.`localSendState`, buf)
            FfiConverterOptionalULong.write(value.`localCreatedAt`, buf)
            FfiConverterMapStringTypeReceipt.write(value.`readReceipts`, buf)
            FfiConverterOptionalTypeEventItemOrigin.write(value.`origin`, buf)
            FfiConverterBoolean.write(value.`canBeRepliedTo`, buf)
            FfiConverterTypeLazyTimelineItemProvider.write(value.`lazyProvider`, buf)
    }
}



data class EventTimelineItemDebugInfo (
    var `model`: kotlin.String, 
    var `originalJson`: kotlin.String?, 
    var `latestEditJson`: kotlin.String?
) {
    
    companion object
}

public object FfiConverterTypeEventTimelineItemDebugInfo: FfiConverterRustBuffer<EventTimelineItemDebugInfo> {
    override fun read(buf: ByteBuffer): EventTimelineItemDebugInfo {
        return EventTimelineItemDebugInfo(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: EventTimelineItemDebugInfo) = (
            FfiConverterString.allocationSize(value.`model`) +
            FfiConverterOptionalString.allocationSize(value.`originalJson`) +
            FfiConverterOptionalString.allocationSize(value.`latestEditJson`)
    )

    override fun write(value: EventTimelineItemDebugInfo, buf: ByteBuffer) {
            FfiConverterString.write(value.`model`, buf)
            FfiConverterOptionalString.write(value.`originalJson`, buf)
            FfiConverterOptionalString.write(value.`latestEditJson`, buf)
    }
}



data class FileInfo (
    var `mimetype`: kotlin.String?, 
    var `size`: kotlin.ULong?, 
    var `thumbnailInfo`: ThumbnailInfo?, 
    var `thumbnailSource`: MediaSource?
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
        Disposable.destroy(this.`mimetype`)
    
        Disposable.destroy(this.`size`)
    
        Disposable.destroy(this.`thumbnailInfo`)
    
        Disposable.destroy(this.`thumbnailSource`)
    
    }
    
    companion object
}

public object FfiConverterTypeFileInfo: FfiConverterRustBuffer<FileInfo> {
    override fun read(buf: ByteBuffer): FileInfo {
        return FileInfo(
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalTypeThumbnailInfo.read(buf),
            FfiConverterOptionalTypeMediaSource.read(buf),
        )
    }

    override fun allocationSize(value: FileInfo) = (
            FfiConverterOptionalString.allocationSize(value.`mimetype`) +
            FfiConverterOptionalULong.allocationSize(value.`size`) +
            FfiConverterOptionalTypeThumbnailInfo.allocationSize(value.`thumbnailInfo`) +
            FfiConverterOptionalTypeMediaSource.allocationSize(value.`thumbnailSource`)
    )

    override fun write(value: FileInfo, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`mimetype`, buf)
            FfiConverterOptionalULong.write(value.`size`, buf)
            FfiConverterOptionalTypeThumbnailInfo.write(value.`thumbnailInfo`, buf)
            FfiConverterOptionalTypeMediaSource.write(value.`thumbnailSource`, buf)
    }
}



data class FileMessageContent (
    /**
     * The computed filename, for use in a client.
     */
    var `filename`: kotlin.String, 
    var `caption`: kotlin.String?, 
    var `formattedCaption`: FormattedBody?, 
    var `source`: MediaSource, 
    var `info`: FileInfo?
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
        Disposable.destroy(this.`filename`)
    
        Disposable.destroy(this.`caption`)
    
        Disposable.destroy(this.`formattedCaption`)
    
        Disposable.destroy(this.`source`)
    
        Disposable.destroy(this.`info`)
    
    }
    
    companion object
}

public object FfiConverterTypeFileMessageContent: FfiConverterRustBuffer<FileMessageContent> {
    override fun read(buf: ByteBuffer): FileMessageContent {
        return FileMessageContent(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalTypeFormattedBody.read(buf),
            FfiConverterTypeMediaSource.read(buf),
            FfiConverterOptionalTypeFileInfo.read(buf),
        )
    }

    override fun allocationSize(value: FileMessageContent) = (
            FfiConverterString.allocationSize(value.`filename`) +
            FfiConverterOptionalString.allocationSize(value.`caption`) +
            FfiConverterOptionalTypeFormattedBody.allocationSize(value.`formattedCaption`) +
            FfiConverterTypeMediaSource.allocationSize(value.`source`) +
            FfiConverterOptionalTypeFileInfo.allocationSize(value.`info`)
    )

    override fun write(value: FileMessageContent, buf: ByteBuffer) {
            FfiConverterString.write(value.`filename`, buf)
            FfiConverterOptionalString.write(value.`caption`, buf)
            FfiConverterOptionalTypeFormattedBody.write(value.`formattedCaption`, buf)
            FfiConverterTypeMediaSource.write(value.`source`, buf)
            FfiConverterOptionalTypeFileInfo.write(value.`info`, buf)
    }
}



data class FormattedBody (
    var `format`: MessageFormat, 
    var `body`: kotlin.String
) {
    
    companion object
}

public object FfiConverterTypeFormattedBody: FfiConverterRustBuffer<FormattedBody> {
    override fun read(buf: ByteBuffer): FormattedBody {
        return FormattedBody(
            FfiConverterTypeMessageFormat.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: FormattedBody) = (
            FfiConverterTypeMessageFormat.allocationSize(value.`format`) +
            FfiConverterString.allocationSize(value.`body`)
    )

    override fun write(value: FormattedBody, buf: ByteBuffer) {
            FfiConverterTypeMessageFormat.write(value.`format`, buf)
            FfiConverterString.write(value.`body`, buf)
    }
}



data class GalleryMessageContent (
    var `body`: kotlin.String, 
    var `formatted`: FormattedBody?, 
    var `itemtypes`: List<GalleryItemType>
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
        Disposable.destroy(this.`body`)
    
        Disposable.destroy(this.`formatted`)
    
        Disposable.destroy(this.`itemtypes`)
    
    }
    
    companion object
}

public object FfiConverterTypeGalleryMessageContent: FfiConverterRustBuffer<GalleryMessageContent> {
    override fun read(buf: ByteBuffer): GalleryMessageContent {
        return GalleryMessageContent(
            FfiConverterString.read(buf),
            FfiConverterOptionalTypeFormattedBody.read(buf),
            FfiConverterSequenceTypeGalleryItemType.read(buf),
        )
    }

    override fun allocationSize(value: GalleryMessageContent) = (
            FfiConverterString.allocationSize(value.`body`) +
            FfiConverterOptionalTypeFormattedBody.allocationSize(value.`formatted`) +
            FfiConverterSequenceTypeGalleryItemType.allocationSize(value.`itemtypes`)
    )

    override fun write(value: GalleryMessageContent, buf: ByteBuffer) {
            FfiConverterString.write(value.`body`, buf)
            FfiConverterOptionalTypeFormattedBody.write(value.`formatted`, buf)
            FfiConverterSequenceTypeGalleryItemType.write(value.`itemtypes`, buf)
    }
}



data class GalleryUploadParameters (
    /**
     * Optional non-formatted caption, for clients that support it.
     */
    var `caption`: kotlin.String?, 
    /**
     * Optional HTML-formatted caption, for clients that support it.
     */
    var `formattedCaption`: FormattedBody?, 
    /**
     * Optional intentional mentions to be sent with the gallery.
     */
    var `mentions`: Mentions?, 
    /**
     * Optional Event ID to reply to.
     */
    var `inReplyTo`: kotlin.String?
) {
    
    companion object
}

public object FfiConverterTypeGalleryUploadParameters: FfiConverterRustBuffer<GalleryUploadParameters> {
    override fun read(buf: ByteBuffer): GalleryUploadParameters {
        return GalleryUploadParameters(
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalTypeFormattedBody.read(buf),
            FfiConverterOptionalTypeMentions.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: GalleryUploadParameters) = (
            FfiConverterOptionalString.allocationSize(value.`caption`) +
            FfiConverterOptionalTypeFormattedBody.allocationSize(value.`formattedCaption`) +
            FfiConverterOptionalTypeMentions.allocationSize(value.`mentions`) +
            FfiConverterOptionalString.allocationSize(value.`inReplyTo`)
    )

    override fun write(value: GalleryUploadParameters, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`caption`, buf)
            FfiConverterOptionalTypeFormattedBody.write(value.`formattedCaption`, buf)
            FfiConverterOptionalTypeMentions.write(value.`mentions`, buf)
            FfiConverterOptionalString.write(value.`inReplyTo`, buf)
    }
}



data class HttpPusherData (
    var `url`: kotlin.String, 
    var `format`: PushFormat?, 
    var `defaultPayload`: kotlin.String?
) {
    
    companion object
}

public object FfiConverterTypeHttpPusherData: FfiConverterRustBuffer<HttpPusherData> {
    override fun read(buf: ByteBuffer): HttpPusherData {
        return HttpPusherData(
            FfiConverterString.read(buf),
            FfiConverterOptionalTypePushFormat.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: HttpPusherData) = (
            FfiConverterString.allocationSize(value.`url`) +
            FfiConverterOptionalTypePushFormat.allocationSize(value.`format`) +
            FfiConverterOptionalString.allocationSize(value.`defaultPayload`)
    )

    override fun write(value: HttpPusherData, buf: ByteBuffer) {
            FfiConverterString.write(value.`url`, buf)
            FfiConverterOptionalTypePushFormat.write(value.`format`, buf)
            FfiConverterOptionalString.write(value.`defaultPayload`, buf)
    }
}



data class IdentityStatusChange (
    /**
     * The user ID of the user whose identity status changed
     */
    var `userId`: kotlin.String, 
    /**
     * The new state of the identity of the user.
     */
    var `changedTo`: IdentityState
) {
    
    companion object
}

public object FfiConverterTypeIdentityStatusChange: FfiConverterRustBuffer<IdentityStatusChange> {
    override fun read(buf: ByteBuffer): IdentityStatusChange {
        return IdentityStatusChange(
            FfiConverterString.read(buf),
            FfiConverterTypeIdentityState.read(buf),
        )
    }

    override fun allocationSize(value: IdentityStatusChange) = (
            FfiConverterString.allocationSize(value.`userId`) +
            FfiConverterTypeIdentityState.allocationSize(value.`changedTo`)
    )

    override fun write(value: IdentityStatusChange, buf: ByteBuffer) {
            FfiConverterString.write(value.`userId`, buf)
            FfiConverterTypeIdentityState.write(value.`changedTo`, buf)
    }
}



/**
 * Details about an ignored user.
 *
 * This is currently empty.
 */
class IgnoredUser {
    override fun equals(other: Any?): Boolean {
        return other is IgnoredUser
    }

    override fun hashCode(): Int {
        return javaClass.hashCode()
    }

    companion object
}

public object FfiConverterTypeIgnoredUser: FfiConverterRustBuffer<IgnoredUser> {
    override fun read(buf: ByteBuffer): IgnoredUser {
        return IgnoredUser()
    }

    override fun allocationSize(value: IgnoredUser) = 0UL

    override fun write(value: IgnoredUser, buf: ByteBuffer) {
    }
}



data class ImageInfo (
    var `height`: kotlin.ULong?, 
    var `width`: kotlin.ULong?, 
    var `mimetype`: kotlin.String?, 
    var `size`: kotlin.ULong?, 
    var `thumbnailInfo`: ThumbnailInfo?, 
    var `thumbnailSource`: MediaSource?, 
    var `blurhash`: kotlin.String?, 
    var `isAnimated`: kotlin.Boolean?
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
        Disposable.destroy(this.`height`)
    
        Disposable.destroy(this.`width`)
    
        Disposable.destroy(this.`mimetype`)
    
        Disposable.destroy(this.`size`)
    
        Disposable.destroy(this.`thumbnailInfo`)
    
        Disposable.destroy(this.`thumbnailSource`)
    
        Disposable.destroy(this.`blurhash`)
    
        Disposable.destroy(this.`isAnimated`)
    
    }
    
    companion object
}

public object FfiConverterTypeImageInfo: FfiConverterRustBuffer<ImageInfo> {
    override fun read(buf: ByteBuffer): ImageInfo {
        return ImageInfo(
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalTypeThumbnailInfo.read(buf),
            FfiConverterOptionalTypeMediaSource.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalBoolean.read(buf),
        )
    }

    override fun allocationSize(value: ImageInfo) = (
            FfiConverterOptionalULong.allocationSize(value.`height`) +
            FfiConverterOptionalULong.allocationSize(value.`width`) +
            FfiConverterOptionalString.allocationSize(value.`mimetype`) +
            FfiConverterOptionalULong.allocationSize(value.`size`) +
            FfiConverterOptionalTypeThumbnailInfo.allocationSize(value.`thumbnailInfo`) +
            FfiConverterOptionalTypeMediaSource.allocationSize(value.`thumbnailSource`) +
            FfiConverterOptionalString.allocationSize(value.`blurhash`) +
            FfiConverterOptionalBoolean.allocationSize(value.`isAnimated`)
    )

    override fun write(value: ImageInfo, buf: ByteBuffer) {
            FfiConverterOptionalULong.write(value.`height`, buf)
            FfiConverterOptionalULong.write(value.`width`, buf)
            FfiConverterOptionalString.write(value.`mimetype`, buf)
            FfiConverterOptionalULong.write(value.`size`, buf)
            FfiConverterOptionalTypeThumbnailInfo.write(value.`thumbnailInfo`, buf)
            FfiConverterOptionalTypeMediaSource.write(value.`thumbnailSource`, buf)
            FfiConverterOptionalString.write(value.`blurhash`, buf)
            FfiConverterOptionalBoolean.write(value.`isAnimated`, buf)
    }
}



data class ImageMessageContent (
    /**
     * The computed filename, for use in a client.
     */
    var `filename`: kotlin.String, 
    var `caption`: kotlin.String?, 
    var `formattedCaption`: FormattedBody?, 
    var `source`: MediaSource, 
    var `info`: ImageInfo?
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
        Disposable.destroy(this.`filename`)
    
        Disposable.destroy(this.`caption`)
    
        Disposable.destroy(this.`formattedCaption`)
    
        Disposable.destroy(this.`source`)
    
        Disposable.destroy(this.`info`)
    
    }
    
    companion object
}

public object FfiConverterTypeImageMessageContent: FfiConverterRustBuffer<ImageMessageContent> {
    override fun read(buf: ByteBuffer): ImageMessageContent {
        return ImageMessageContent(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalTypeFormattedBody.read(buf),
            FfiConverterTypeMediaSource.read(buf),
            FfiConverterOptionalTypeImageInfo.read(buf),
        )
    }

    override fun allocationSize(value: ImageMessageContent) = (
            FfiConverterString.allocationSize(value.`filename`) +
            FfiConverterOptionalString.allocationSize(value.`caption`) +
            FfiConverterOptionalTypeFormattedBody.allocationSize(value.`formattedCaption`) +
            FfiConverterTypeMediaSource.allocationSize(value.`source`) +
            FfiConverterOptionalTypeImageInfo.allocationSize(value.`info`)
    )

    override fun write(value: ImageMessageContent, buf: ByteBuffer) {
            FfiConverterString.write(value.`filename`, buf)
            FfiConverterOptionalString.write(value.`caption`, buf)
            FfiConverterOptionalTypeFormattedBody.write(value.`formattedCaption`, buf)
            FfiConverterTypeMediaSource.write(value.`source`, buf)
            FfiConverterOptionalTypeImageInfo.write(value.`info`, buf)
    }
}



/**
 * An FFI representation of a request to join a room.
 */
data class KnockRequest (
    /**
     * The event id of the event that contains the `knock` membership change.
     */
    var `eventId`: kotlin.String, 
    /**
     * The user id of the user who's requesting to join the room.
     */
    var `userId`: kotlin.String, 
    /**
     * The room id of the room whose access was requested.
     */
    var `roomId`: kotlin.String, 
    /**
     * The optional display name of the user who's requesting to join the room.
     */
    var `displayName`: kotlin.String?, 
    /**
     * The optional avatar url of the user who's requesting to join the room.
     */
    var `avatarUrl`: kotlin.String?, 
    /**
     * An optional reason why the user wants join the room.
     */
    var `reason`: kotlin.String?, 
    /**
     * The timestamp when this request was created.
     */
    var `timestamp`: kotlin.ULong?, 
    /**
     * Whether the knock request has been marked as `seen` so it can be
     * filtered by the client.
     */
    var `isSeen`: kotlin.Boolean, 
    /**
     * A set of actions to perform for this knock request.
     */
    var `actions`: KnockRequestActions
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
        Disposable.destroy(this.`eventId`)
    
        Disposable.destroy(this.`userId`)
    
        Disposable.destroy(this.`roomId`)
    
        Disposable.destroy(this.`displayName`)
    
        Disposable.destroy(this.`avatarUrl`)
    
        Disposable.destroy(this.`reason`)
    
        Disposable.destroy(this.`timestamp`)
    
        Disposable.destroy(this.`isSeen`)
    
        Disposable.destroy(this.`actions`)
    
    }
    
    companion object
}

public object FfiConverterTypeKnockRequest: FfiConverterRustBuffer<KnockRequest> {
    override fun read(buf: ByteBuffer): KnockRequest {
        return KnockRequest(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterTypeKnockRequestActions.read(buf),
        )
    }

    override fun allocationSize(value: KnockRequest) = (
            FfiConverterString.allocationSize(value.`eventId`) +
            FfiConverterString.allocationSize(value.`userId`) +
            FfiConverterString.allocationSize(value.`roomId`) +
            FfiConverterOptionalString.allocationSize(value.`displayName`) +
            FfiConverterOptionalString.allocationSize(value.`avatarUrl`) +
            FfiConverterOptionalString.allocationSize(value.`reason`) +
            FfiConverterOptionalULong.allocationSize(value.`timestamp`) +
            FfiConverterBoolean.allocationSize(value.`isSeen`) +
            FfiConverterTypeKnockRequestActions.allocationSize(value.`actions`)
    )

    override fun write(value: KnockRequest, buf: ByteBuffer) {
            FfiConverterString.write(value.`eventId`, buf)
            FfiConverterString.write(value.`userId`, buf)
            FfiConverterString.write(value.`roomId`, buf)
            FfiConverterOptionalString.write(value.`displayName`, buf)
            FfiConverterOptionalString.write(value.`avatarUrl`, buf)
            FfiConverterOptionalString.write(value.`reason`, buf)
            FfiConverterOptionalULong.write(value.`timestamp`, buf)
            FfiConverterBoolean.write(value.`isSeen`, buf)
            FfiConverterTypeKnockRequestActions.write(value.`actions`, buf)
    }
}



data class LastLocation (
    /**
     * The most recent location content of the user.
     */
    var `location`: LocationContent, 
    /**
     * A timestamp in milliseconds since Unix Epoch on that day in local
     * time.
     */
    var `ts`: kotlin.ULong
) {
    
    companion object
}

public object FfiConverterTypeLastLocation: FfiConverterRustBuffer<LastLocation> {
    override fun read(buf: ByteBuffer): LastLocation {
        return LastLocation(
            FfiConverterTypeLocationContent.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: LastLocation) = (
            FfiConverterTypeLocationContent.allocationSize(value.`location`) +
            FfiConverterULong.allocationSize(value.`ts`)
    )

    override fun write(value: LastLocation, buf: ByteBuffer) {
            FfiConverterTypeLocationContent.write(value.`location`, buf)
            FfiConverterULong.write(value.`ts`, buf)
    }
}



/**
 * Space leaving specific room that groups normal [`SpaceRoom`] details with
 * information about the leaving user's role.
 */
data class LeaveSpaceRoom (
    /**
     * The underlying [`SpaceRoom`]
     */
    var `spaceRoom`: SpaceRoom, 
    /**
     * Whether the user is the last admin in the room. This helps clients
     * better inform the user about the consequences of leaving the room.
     */
    var `isLastAdmin`: kotlin.Boolean
) {
    
    companion object
}

public object FfiConverterTypeLeaveSpaceRoom: FfiConverterRustBuffer<LeaveSpaceRoom> {
    override fun read(buf: ByteBuffer): LeaveSpaceRoom {
        return LeaveSpaceRoom(
            FfiConverterTypeSpaceRoom.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: LeaveSpaceRoom) = (
            FfiConverterTypeSpaceRoom.allocationSize(value.`spaceRoom`) +
            FfiConverterBoolean.allocationSize(value.`isLastAdmin`)
    )

    override fun write(value: LeaveSpaceRoom, buf: ByteBuffer) {
            FfiConverterTypeSpaceRoom.write(value.`spaceRoom`, buf)
            FfiConverterBoolean.write(value.`isLastAdmin`, buf)
    }
}



/**
 * Details of a users live location share.
 */
data class LiveLocationShare (
    /**
     * The user's last known location.
     */
    var `lastLocation`: LastLocation, 
    /**
     * The live status of the live location share.
     */
    var `isLive`: kotlin.Boolean, 
    /**
     * The user ID of the person sharing their live location.
     */
    var `userId`: kotlin.String
) {
    
    companion object
}

public object FfiConverterTypeLiveLocationShare: FfiConverterRustBuffer<LiveLocationShare> {
    override fun read(buf: ByteBuffer): LiveLocationShare {
        return LiveLocationShare(
            FfiConverterTypeLastLocation.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: LiveLocationShare) = (
            FfiConverterTypeLastLocation.allocationSize(value.`lastLocation`) +
            FfiConverterBoolean.allocationSize(value.`isLive`) +
            FfiConverterString.allocationSize(value.`userId`)
    )

    override fun write(value: LiveLocationShare, buf: ByteBuffer) {
            FfiConverterTypeLastLocation.write(value.`lastLocation`, buf)
            FfiConverterBoolean.write(value.`isLive`, buf)
            FfiConverterString.write(value.`userId`, buf)
    }
}



data class LocationContent (
    var `body`: kotlin.String, 
    var `geoUri`: kotlin.String, 
    var `description`: kotlin.String?, 
    var `zoomLevel`: kotlin.UByte?, 
    var `asset`: AssetType?
) {
    
    companion object
}

public object FfiConverterTypeLocationContent: FfiConverterRustBuffer<LocationContent> {
    override fun read(buf: ByteBuffer): LocationContent {
        return LocationContent(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalUByte.read(buf),
            FfiConverterOptionalTypeAssetType.read(buf),
        )
    }

    override fun allocationSize(value: LocationContent) = (
            FfiConverterString.allocationSize(value.`body`) +
            FfiConverterString.allocationSize(value.`geoUri`) +
            FfiConverterOptionalString.allocationSize(value.`description`) +
            FfiConverterOptionalUByte.allocationSize(value.`zoomLevel`) +
            FfiConverterOptionalTypeAssetType.allocationSize(value.`asset`)
    )

    override fun write(value: LocationContent, buf: ByteBuffer) {
            FfiConverterString.write(value.`body`, buf)
            FfiConverterString.write(value.`geoUri`, buf)
            FfiConverterOptionalString.write(value.`description`, buf)
            FfiConverterOptionalUByte.write(value.`zoomLevel`, buf)
            FfiConverterOptionalTypeAssetType.write(value.`asset`, buf)
    }
}



/**
 * A Matrix entity that can be a room, room alias, user, or event, and a list
 * of via servers.
 */
data class MatrixEntity (
    var `id`: MatrixId, 
    var `via`: List<kotlin.String>
) {
    
    companion object
}

public object FfiConverterTypeMatrixEntity: FfiConverterRustBuffer<MatrixEntity> {
    override fun read(buf: ByteBuffer): MatrixEntity {
        return MatrixEntity(
            FfiConverterTypeMatrixId.read(buf),
            FfiConverterSequenceString.read(buf),
        )
    }

    override fun allocationSize(value: MatrixEntity) = (
            FfiConverterTypeMatrixId.allocationSize(value.`id`) +
            FfiConverterSequenceString.allocationSize(value.`via`)
    )

    override fun write(value: MatrixEntity, buf: ByteBuffer) {
            FfiConverterTypeMatrixId.write(value.`id`, buf)
            FfiConverterSequenceString.write(value.`via`, buf)
    }
}



/**
 * The content of an `m.media_preview_config` event.
 *
 * Is also the content of the unstable
 * `io.element.msc4278.media_preview_config`.
 */
data class MediaPreviewConfig (
    /**
     * The media previews setting for the user.
     */
    var `mediaPreviews`: MediaPreviews?, 
    /**
     * The invite avatars setting for the user.
     */
    var `inviteAvatars`: InviteAvatars?
) {
    
    companion object
}

public object FfiConverterTypeMediaPreviewConfig: FfiConverterRustBuffer<MediaPreviewConfig> {
    override fun read(buf: ByteBuffer): MediaPreviewConfig {
        return MediaPreviewConfig(
            FfiConverterOptionalTypeMediaPreviews.read(buf),
            FfiConverterOptionalTypeInviteAvatars.read(buf),
        )
    }

    override fun allocationSize(value: MediaPreviewConfig) = (
            FfiConverterOptionalTypeMediaPreviews.allocationSize(value.`mediaPreviews`) +
            FfiConverterOptionalTypeInviteAvatars.allocationSize(value.`inviteAvatars`)
    )

    override fun write(value: MediaPreviewConfig, buf: ByteBuffer) {
            FfiConverterOptionalTypeMediaPreviews.write(value.`mediaPreviews`, buf)
            FfiConverterOptionalTypeInviteAvatars.write(value.`inviteAvatars`, buf)
    }
}



/**
 * This type represents the progress of a media (consisting of a file and
 * possibly a thumbnail) being uploaded.
 */
data class MediaUploadProgress (
    /**
     * The index of the media within the transaction. A file and its
     * thumbnail share the same index. Will always be 0 for non-gallery
     * media uploads.
     */
    var `index`: kotlin.ULong, 
    /**
     * The current combined upload progress for both the file and,
     * if it exists, its thumbnail.
     */
    var `progress`: AbstractProgress
) {
    
    companion object
}

public object FfiConverterTypeMediaUploadProgress: FfiConverterRustBuffer<MediaUploadProgress> {
    override fun read(buf: ByteBuffer): MediaUploadProgress {
        return MediaUploadProgress(
            FfiConverterULong.read(buf),
            FfiConverterTypeAbstractProgress.read(buf),
        )
    }

    override fun allocationSize(value: MediaUploadProgress) = (
            FfiConverterULong.allocationSize(value.`index`) +
            FfiConverterTypeAbstractProgress.allocationSize(value.`progress`)
    )

    override fun write(value: MediaUploadProgress, buf: ByteBuffer) {
            FfiConverterULong.write(value.`index`, buf)
            FfiConverterTypeAbstractProgress.write(value.`progress`, buf)
    }
}



data class Mentions (
    var `userIds`: List<kotlin.String>, 
    var `room`: kotlin.Boolean
) {
    
    companion object
}

public object FfiConverterTypeMentions: FfiConverterRustBuffer<Mentions> {
    override fun read(buf: ByteBuffer): Mentions {
        return Mentions(
            FfiConverterSequenceString.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: Mentions) = (
            FfiConverterSequenceString.allocationSize(value.`userIds`) +
            FfiConverterBoolean.allocationSize(value.`room`)
    )

    override fun write(value: Mentions, buf: ByteBuffer) {
            FfiConverterSequenceString.write(value.`userIds`, buf)
            FfiConverterBoolean.write(value.`room`, buf)
    }
}



data class MessageContent (
    var `msgType`: MessageType, 
    var `body`: kotlin.String, 
    var `isEdited`: kotlin.Boolean, 
    var `mentions`: Mentions?
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
        Disposable.destroy(this.`msgType`)
    
        Disposable.destroy(this.`body`)
    
        Disposable.destroy(this.`isEdited`)
    
        Disposable.destroy(this.`mentions`)
    
    }
    
    companion object
}

public object FfiConverterTypeMessageContent: FfiConverterRustBuffer<MessageContent> {
    override fun read(buf: ByteBuffer): MessageContent {
        return MessageContent(
            FfiConverterTypeMessageType.read(buf),
            FfiConverterString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalTypeMentions.read(buf),
        )
    }

    override fun allocationSize(value: MessageContent) = (
            FfiConverterTypeMessageType.allocationSize(value.`msgType`) +
            FfiConverterString.allocationSize(value.`body`) +
            FfiConverterBoolean.allocationSize(value.`isEdited`) +
            FfiConverterOptionalTypeMentions.allocationSize(value.`mentions`)
    )

    override fun write(value: MessageContent, buf: ByteBuffer) {
            FfiConverterTypeMessageType.write(value.`msgType`, buf)
            FfiConverterString.write(value.`body`, buf)
            FfiConverterBoolean.write(value.`isEdited`, buf)
            FfiConverterOptionalTypeMentions.write(value.`mentions`, buf)
    }
}



/**
 * A special kind of [`super::TimelineItemContent`] that groups together
 * different room message types with their respective reactions and thread
 * information.
 */
data class MsgLikeContent (
    var `kind`: MsgLikeKind, 
    var `reactions`: List<Reaction>, 
    /**
     * The event this message is replying to, if any.
     */
    var `inReplyTo`: InReplyToDetails?, 
    /**
     * Event ID of the thread root, if this is a message in a thread.
     */
    var `threadRoot`: kotlin.String?, 
    /**
     * Details about the thread this message is the root of.
     */
    var `threadSummary`: ThreadSummary?
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
        Disposable.destroy(this.`kind`)
    
        Disposable.destroy(this.`reactions`)
    
        Disposable.destroy(this.`inReplyTo`)
    
        Disposable.destroy(this.`threadRoot`)
    
        Disposable.destroy(this.`threadSummary`)
    
    }
    
    companion object
}

public object FfiConverterTypeMsgLikeContent: FfiConverterRustBuffer<MsgLikeContent> {
    override fun read(buf: ByteBuffer): MsgLikeContent {
        return MsgLikeContent(
            FfiConverterTypeMsgLikeKind.read(buf),
            FfiConverterSequenceTypeReaction.read(buf),
            FfiConverterOptionalTypeInReplyToDetails.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalTypeThreadSummary.read(buf),
        )
    }

    override fun allocationSize(value: MsgLikeContent) = (
            FfiConverterTypeMsgLikeKind.allocationSize(value.`kind`) +
            FfiConverterSequenceTypeReaction.allocationSize(value.`reactions`) +
            FfiConverterOptionalTypeInReplyToDetails.allocationSize(value.`inReplyTo`) +
            FfiConverterOptionalString.allocationSize(value.`threadRoot`) +
            FfiConverterOptionalTypeThreadSummary.allocationSize(value.`threadSummary`)
    )

    override fun write(value: MsgLikeContent, buf: ByteBuffer) {
            FfiConverterTypeMsgLikeKind.write(value.`kind`, buf)
            FfiConverterSequenceTypeReaction.write(value.`reactions`, buf)
            FfiConverterOptionalTypeInReplyToDetails.write(value.`inReplyTo`, buf)
            FfiConverterOptionalString.write(value.`threadRoot`, buf)
            FfiConverterOptionalTypeThreadSummary.write(value.`threadSummary`, buf)
    }
}



data class NoticeMessageContent (
    var `body`: kotlin.String, 
    var `formatted`: FormattedBody?
) {
    
    companion object
}

public object FfiConverterTypeNoticeMessageContent: FfiConverterRustBuffer<NoticeMessageContent> {
    override fun read(buf: ByteBuffer): NoticeMessageContent {
        return NoticeMessageContent(
            FfiConverterString.read(buf),
            FfiConverterOptionalTypeFormattedBody.read(buf),
        )
    }

    override fun allocationSize(value: NoticeMessageContent) = (
            FfiConverterString.allocationSize(value.`body`) +
            FfiConverterOptionalTypeFormattedBody.allocationSize(value.`formatted`)
    )

    override fun write(value: NoticeMessageContent, buf: ByteBuffer) {
            FfiConverterString.write(value.`body`, buf)
            FfiConverterOptionalTypeFormattedBody.write(value.`formatted`, buf)
    }
}



data class NotificationItem (
    var `event`: NotificationEvent, 
    var `senderInfo`: NotificationSenderInfo, 
    var `roomInfo`: NotificationRoomInfo, 
    /**
     * Is the notification supposed to be at the "noisy" level?
     * Can be `None` if we couldn't determine this, because we lacked
     * information to create a push context.
     */
    var `isNoisy`: kotlin.Boolean?, 
    var `hasMention`: kotlin.Boolean?, 
    var `threadId`: kotlin.String?
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
        Disposable.destroy(this.`event`)
    
        Disposable.destroy(this.`senderInfo`)
    
        Disposable.destroy(this.`roomInfo`)
    
        Disposable.destroy(this.`isNoisy`)
    
        Disposable.destroy(this.`hasMention`)
    
        Disposable.destroy(this.`threadId`)
    
    }
    
    companion object
}

public object FfiConverterTypeNotificationItem: FfiConverterRustBuffer<NotificationItem> {
    override fun read(buf: ByteBuffer): NotificationItem {
        return NotificationItem(
            FfiConverterTypeNotificationEvent.read(buf),
            FfiConverterTypeNotificationSenderInfo.read(buf),
            FfiConverterTypeNotificationRoomInfo.read(buf),
            FfiConverterOptionalBoolean.read(buf),
            FfiConverterOptionalBoolean.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: NotificationItem) = (
            FfiConverterTypeNotificationEvent.allocationSize(value.`event`) +
            FfiConverterTypeNotificationSenderInfo.allocationSize(value.`senderInfo`) +
            FfiConverterTypeNotificationRoomInfo.allocationSize(value.`roomInfo`) +
            FfiConverterOptionalBoolean.allocationSize(value.`isNoisy`) +
            FfiConverterOptionalBoolean.allocationSize(value.`hasMention`) +
            FfiConverterOptionalString.allocationSize(value.`threadId`)
    )

    override fun write(value: NotificationItem, buf: ByteBuffer) {
            FfiConverterTypeNotificationEvent.write(value.`event`, buf)
            FfiConverterTypeNotificationSenderInfo.write(value.`senderInfo`, buf)
            FfiConverterTypeNotificationRoomInfo.write(value.`roomInfo`, buf)
            FfiConverterOptionalBoolean.write(value.`isNoisy`, buf)
            FfiConverterOptionalBoolean.write(value.`hasMention`, buf)
            FfiConverterOptionalString.write(value.`threadId`, buf)
    }
}



/**
 * A request for notification items grouped by their room.
 */
data class NotificationItemsRequest (
    var `roomId`: kotlin.String, 
    var `eventIds`: List<kotlin.String>
) {
    
    companion object
}

public object FfiConverterTypeNotificationItemsRequest: FfiConverterRustBuffer<NotificationItemsRequest> {
    override fun read(buf: ByteBuffer): NotificationItemsRequest {
        return NotificationItemsRequest(
            FfiConverterString.read(buf),
            FfiConverterSequenceString.read(buf),
        )
    }

    override fun allocationSize(value: NotificationItemsRequest) = (
            FfiConverterString.allocationSize(value.`roomId`) +
            FfiConverterSequenceString.allocationSize(value.`eventIds`)
    )

    override fun write(value: NotificationItemsRequest, buf: ByteBuffer) {
            FfiConverterString.write(value.`roomId`, buf)
            FfiConverterSequenceString.write(value.`eventIds`, buf)
    }
}



data class NotificationPowerLevels (
    var `room`: kotlin.Int
) {
    
    companion object
}

public object FfiConverterTypeNotificationPowerLevels: FfiConverterRustBuffer<NotificationPowerLevels> {
    override fun read(buf: ByteBuffer): NotificationPowerLevels {
        return NotificationPowerLevels(
            FfiConverterInt.read(buf),
        )
    }

    override fun allocationSize(value: NotificationPowerLevels) = (
            FfiConverterInt.allocationSize(value.`room`)
    )

    override fun write(value: NotificationPowerLevels, buf: ByteBuffer) {
            FfiConverterInt.write(value.`room`, buf)
    }
}



data class NotificationRoomInfo (
    var `displayName`: kotlin.String, 
    var `avatarUrl`: kotlin.String?, 
    var `canonicalAlias`: kotlin.String?, 
    var `topic`: kotlin.String?, 
    var `joinRule`: JoinRule?, 
    var `joinedMembersCount`: kotlin.ULong, 
    var `isEncrypted`: kotlin.Boolean?, 
    var `isDirect`: kotlin.Boolean
) {
    
    companion object
}

public object FfiConverterTypeNotificationRoomInfo: FfiConverterRustBuffer<NotificationRoomInfo> {
    override fun read(buf: ByteBuffer): NotificationRoomInfo {
        return NotificationRoomInfo(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalTypeJoinRule.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterOptionalBoolean.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: NotificationRoomInfo) = (
            FfiConverterString.allocationSize(value.`displayName`) +
            FfiConverterOptionalString.allocationSize(value.`avatarUrl`) +
            FfiConverterOptionalString.allocationSize(value.`canonicalAlias`) +
            FfiConverterOptionalString.allocationSize(value.`topic`) +
            FfiConverterOptionalTypeJoinRule.allocationSize(value.`joinRule`) +
            FfiConverterULong.allocationSize(value.`joinedMembersCount`) +
            FfiConverterOptionalBoolean.allocationSize(value.`isEncrypted`) +
            FfiConverterBoolean.allocationSize(value.`isDirect`)
    )

    override fun write(value: NotificationRoomInfo, buf: ByteBuffer) {
            FfiConverterString.write(value.`displayName`, buf)
            FfiConverterOptionalString.write(value.`avatarUrl`, buf)
            FfiConverterOptionalString.write(value.`canonicalAlias`, buf)
            FfiConverterOptionalString.write(value.`topic`, buf)
            FfiConverterOptionalTypeJoinRule.write(value.`joinRule`, buf)
            FfiConverterULong.write(value.`joinedMembersCount`, buf)
            FfiConverterOptionalBoolean.write(value.`isEncrypted`, buf)
            FfiConverterBoolean.write(value.`isDirect`, buf)
    }
}



data class NotificationSenderInfo (
    var `displayName`: kotlin.String?, 
    var `avatarUrl`: kotlin.String?, 
    var `isNameAmbiguous`: kotlin.Boolean
) {
    
    companion object
}

public object FfiConverterTypeNotificationSenderInfo: FfiConverterRustBuffer<NotificationSenderInfo> {
    override fun read(buf: ByteBuffer): NotificationSenderInfo {
        return NotificationSenderInfo(
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: NotificationSenderInfo) = (
            FfiConverterOptionalString.allocationSize(value.`displayName`) +
            FfiConverterOptionalString.allocationSize(value.`avatarUrl`) +
            FfiConverterBoolean.allocationSize(value.`isNameAmbiguous`)
    )

    override fun write(value: NotificationSenderInfo, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`displayName`, buf)
            FfiConverterOptionalString.write(value.`avatarUrl`, buf)
            FfiConverterBoolean.write(value.`isNameAmbiguous`, buf)
    }
}



/**
 * The configuration to use when authenticating with OIDC.
 */
data class OidcConfiguration (
    /**
     * The name of the client that will be shown during OIDC authentication.
     */
    var `clientName`: kotlin.String?, 
    /**
     * The redirect URI that will be used when OIDC authentication is
     * successful.
     */
    var `redirectUri`: kotlin.String, 
    /**
     * A URI that contains information about the client.
     */
    var `clientUri`: kotlin.String, 
    /**
     * A URI that contains the client's logo.
     */
    var `logoUri`: kotlin.String?, 
    /**
     * A URI that contains the client's terms of service.
     */
    var `tosUri`: kotlin.String?, 
    /**
     * A URI that contains the client's privacy policy.
     */
    var `policyUri`: kotlin.String?, 
    /**
     * Pre-configured registrations for use with homeservers that don't support
     * dynamic client registration.
     *
     * The keys of the map should be the URLs of the homeservers, but keys
     * using `issuer` URLs are also supported.
     */
    var `staticRegistrations`: Map<kotlin.String, kotlin.String>
) {
    
    companion object
}

public object FfiConverterTypeOidcConfiguration: FfiConverterRustBuffer<OidcConfiguration> {
    override fun read(buf: ByteBuffer): OidcConfiguration {
        return OidcConfiguration(
            FfiConverterOptionalString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterMapStringString.read(buf),
        )
    }

    override fun allocationSize(value: OidcConfiguration) = (
            FfiConverterOptionalString.allocationSize(value.`clientName`) +
            FfiConverterString.allocationSize(value.`redirectUri`) +
            FfiConverterString.allocationSize(value.`clientUri`) +
            FfiConverterOptionalString.allocationSize(value.`logoUri`) +
            FfiConverterOptionalString.allocationSize(value.`tosUri`) +
            FfiConverterOptionalString.allocationSize(value.`policyUri`) +
            FfiConverterMapStringString.allocationSize(value.`staticRegistrations`)
    )

    override fun write(value: OidcConfiguration, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`clientName`, buf)
            FfiConverterString.write(value.`redirectUri`, buf)
            FfiConverterString.write(value.`clientUri`, buf)
            FfiConverterOptionalString.write(value.`logoUri`, buf)
            FfiConverterOptionalString.write(value.`tosUri`, buf)
            FfiConverterOptionalString.write(value.`policyUri`, buf)
            FfiConverterMapStringString.write(value.`staticRegistrations`, buf)
    }
}



data class OidcCrossSigningResetInfo (
    /**
     * The URL where the user can approve the reset of the cross-signing keys.
     */
    var `approvalUrl`: kotlin.String
) {
    
    companion object
}

public object FfiConverterTypeOidcCrossSigningResetInfo: FfiConverterRustBuffer<OidcCrossSigningResetInfo> {
    override fun read(buf: ByteBuffer): OidcCrossSigningResetInfo {
        return OidcCrossSigningResetInfo(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: OidcCrossSigningResetInfo) = (
            FfiConverterString.allocationSize(value.`approvalUrl`)
    )

    override fun write(value: OidcCrossSigningResetInfo, buf: ByteBuffer) {
            FfiConverterString.write(value.`approvalUrl`, buf)
    }
}



/**
 * A passphrase from which a key is to be derived.
 */
data class PassPhrase (
    /**
     * The algorithm to use to generate the key from the passphrase.
     *
     * Must be `m.pbkdf2`.
     */
    var `algorithm`: KeyDerivationAlgorithm, 
    /**
     * The salt used in PBKDF2.
     */
    var `salt`: kotlin.String, 
    /**
     * The number of iterations to use in PBKDF2.
     */
    var `iterations`: kotlin.ULong, 
    /**
     * The number of bits to generate for the key.
     *
     * Defaults to 256
     */
    var `bits`: kotlin.ULong
) {
    
    companion object
}

public object FfiConverterTypePassPhrase: FfiConverterRustBuffer<PassPhrase> {
    override fun read(buf: ByteBuffer): PassPhrase {
        return PassPhrase(
            FfiConverterTypeKeyDerivationAlgorithm.read(buf),
            FfiConverterString.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: PassPhrase) = (
            FfiConverterTypeKeyDerivationAlgorithm.allocationSize(value.`algorithm`) +
            FfiConverterString.allocationSize(value.`salt`) +
            FfiConverterULong.allocationSize(value.`iterations`) +
            FfiConverterULong.allocationSize(value.`bits`)
    )

    override fun write(value: PassPhrase, buf: ByteBuffer) {
            FfiConverterTypeKeyDerivationAlgorithm.write(value.`algorithm`, buf)
            FfiConverterString.write(value.`salt`, buf)
            FfiConverterULong.write(value.`iterations`, buf)
            FfiConverterULong.write(value.`bits`, buf)
    }
}



/**
 * Like [`SimplePushRule`], but with an additional `pattern`` field.
 */
data class PatternedPushRule (
    /**
     * Actions to determine if and how a notification is delivered for events
     * matching this rule.
     */
    var `actions`: List<Action>, 
    /**
     * Whether this is a default rule, or has been set explicitly.
     */
    var `default`: kotlin.Boolean, 
    /**
     * Whether the push rule is enabled or not.
     */
    var `enabled`: kotlin.Boolean, 
    /**
     * The ID of this rule.
     */
    var `ruleId`: kotlin.String, 
    /**
     * The glob-style pattern to match against.
     */
    var `pattern`: kotlin.String
) {
    
    companion object
}

public object FfiConverterTypePatternedPushRule: FfiConverterRustBuffer<PatternedPushRule> {
    override fun read(buf: ByteBuffer): PatternedPushRule {
        return PatternedPushRule(
            FfiConverterSequenceTypeAction.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: PatternedPushRule) = (
            FfiConverterSequenceTypeAction.allocationSize(value.`actions`) +
            FfiConverterBoolean.allocationSize(value.`default`) +
            FfiConverterBoolean.allocationSize(value.`enabled`) +
            FfiConverterString.allocationSize(value.`ruleId`) +
            FfiConverterString.allocationSize(value.`pattern`)
    )

    override fun write(value: PatternedPushRule, buf: ByteBuffer) {
            FfiConverterSequenceTypeAction.write(value.`actions`, buf)
            FfiConverterBoolean.write(value.`default`, buf)
            FfiConverterBoolean.write(value.`enabled`, buf)
            FfiConverterString.write(value.`ruleId`, buf)
            FfiConverterString.write(value.`pattern`, buf)
    }
}



data class PollAnswer (
    var `id`: kotlin.String, 
    var `text`: kotlin.String
) {
    
    companion object
}

public object FfiConverterTypePollAnswer: FfiConverterRustBuffer<PollAnswer> {
    override fun read(buf: ByteBuffer): PollAnswer {
        return PollAnswer(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: PollAnswer) = (
            FfiConverterString.allocationSize(value.`id`) +
            FfiConverterString.allocationSize(value.`text`)
    )

    override fun write(value: PollAnswer, buf: ByteBuffer) {
            FfiConverterString.write(value.`id`, buf)
            FfiConverterString.write(value.`text`, buf)
    }
}



data class PollData (
    var `question`: kotlin.String, 
    var `answers`: List<kotlin.String>, 
    var `maxSelections`: kotlin.UByte, 
    var `pollKind`: PollKind
) {
    
    companion object
}

public object FfiConverterTypePollData: FfiConverterRustBuffer<PollData> {
    override fun read(buf: ByteBuffer): PollData {
        return PollData(
            FfiConverterString.read(buf),
            FfiConverterSequenceString.read(buf),
            FfiConverterUByte.read(buf),
            FfiConverterTypePollKind.read(buf),
        )
    }

    override fun allocationSize(value: PollData) = (
            FfiConverterString.allocationSize(value.`question`) +
            FfiConverterSequenceString.allocationSize(value.`answers`) +
            FfiConverterUByte.allocationSize(value.`maxSelections`) +
            FfiConverterTypePollKind.allocationSize(value.`pollKind`)
    )

    override fun write(value: PollData, buf: ByteBuffer) {
            FfiConverterString.write(value.`question`, buf)
            FfiConverterSequenceString.write(value.`answers`, buf)
            FfiConverterUByte.write(value.`maxSelections`, buf)
            FfiConverterTypePollKind.write(value.`pollKind`, buf)
    }
}



data class PowerLevels (
    var `usersDefault`: kotlin.Int?, 
    var `eventsDefault`: kotlin.Int?, 
    var `stateDefault`: kotlin.Int?, 
    var `ban`: kotlin.Int?, 
    var `kick`: kotlin.Int?, 
    var `redact`: kotlin.Int?, 
    var `invite`: kotlin.Int?, 
    var `notifications`: NotificationPowerLevels?, 
    var `users`: Map<kotlin.String, kotlin.Int>, 
    var `events`: Map<kotlin.String, kotlin.Int>
) {
    
    companion object
}

public object FfiConverterTypePowerLevels: FfiConverterRustBuffer<PowerLevels> {
    override fun read(buf: ByteBuffer): PowerLevels {
        return PowerLevels(
            FfiConverterOptionalInt.read(buf),
            FfiConverterOptionalInt.read(buf),
            FfiConverterOptionalInt.read(buf),
            FfiConverterOptionalInt.read(buf),
            FfiConverterOptionalInt.read(buf),
            FfiConverterOptionalInt.read(buf),
            FfiConverterOptionalInt.read(buf),
            FfiConverterOptionalTypeNotificationPowerLevels.read(buf),
            FfiConverterMapStringInt.read(buf),
            FfiConverterMapStringInt.read(buf),
        )
    }

    override fun allocationSize(value: PowerLevels) = (
            FfiConverterOptionalInt.allocationSize(value.`usersDefault`) +
            FfiConverterOptionalInt.allocationSize(value.`eventsDefault`) +
            FfiConverterOptionalInt.allocationSize(value.`stateDefault`) +
            FfiConverterOptionalInt.allocationSize(value.`ban`) +
            FfiConverterOptionalInt.allocationSize(value.`kick`) +
            FfiConverterOptionalInt.allocationSize(value.`redact`) +
            FfiConverterOptionalInt.allocationSize(value.`invite`) +
            FfiConverterOptionalTypeNotificationPowerLevels.allocationSize(value.`notifications`) +
            FfiConverterMapStringInt.allocationSize(value.`users`) +
            FfiConverterMapStringInt.allocationSize(value.`events`)
    )

    override fun write(value: PowerLevels, buf: ByteBuffer) {
            FfiConverterOptionalInt.write(value.`usersDefault`, buf)
            FfiConverterOptionalInt.write(value.`eventsDefault`, buf)
            FfiConverterOptionalInt.write(value.`stateDefault`, buf)
            FfiConverterOptionalInt.write(value.`ban`, buf)
            FfiConverterOptionalInt.write(value.`kick`, buf)
            FfiConverterOptionalInt.write(value.`redact`, buf)
            FfiConverterOptionalInt.write(value.`invite`, buf)
            FfiConverterOptionalTypeNotificationPowerLevels.write(value.`notifications`, buf)
            FfiConverterMapStringInt.write(value.`users`, buf)
            FfiConverterMapStringInt.write(value.`events`, buf)
    }
}



/**
 * When a room A is tombstoned, it is replaced by a room B. The room A is the
 * predecessor of B, and B is the successor of A. This type holds information
 * about the predecessor room. See [`Room::predecessor_room`].
 *
 * To know the predecessor of a room, the [`m.room.create`] state event must
 * have been received.
 *
 * [`m.room.create`]: https://spec.matrix.org/v1.14/client-server-api/#mroomcreate
 */
data class PredecessorRoom (
    /**
     * The ID of the replacement room.
     */
    var `roomId`: kotlin.String
) {
    
    companion object
}

public object FfiConverterTypePredecessorRoom: FfiConverterRustBuffer<PredecessorRoom> {
    override fun read(buf: ByteBuffer): PredecessorRoom {
        return PredecessorRoom(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: PredecessorRoom) = (
            FfiConverterString.allocationSize(value.`roomId`)
    )

    override fun write(value: PredecessorRoom, buf: ByteBuffer) {
            FfiConverterString.write(value.`roomId`, buf)
    }
}



data class PusherIdentifiers (
    var `pushkey`: kotlin.String, 
    var `appId`: kotlin.String
) {
    
    companion object
}

public object FfiConverterTypePusherIdentifiers: FfiConverterRustBuffer<PusherIdentifiers> {
    override fun read(buf: ByteBuffer): PusherIdentifiers {
        return PusherIdentifiers(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: PusherIdentifiers) = (
            FfiConverterString.allocationSize(value.`pushkey`) +
            FfiConverterString.allocationSize(value.`appId`)
    )

    override fun write(value: PusherIdentifiers, buf: ByteBuffer) {
            FfiConverterString.write(value.`pushkey`, buf)
            FfiConverterString.write(value.`appId`, buf)
    }
}



data class Reaction (
    var `key`: kotlin.String, 
    var `senders`: List<ReactionSenderData>
) {
    
    companion object
}

public object FfiConverterTypeReaction: FfiConverterRustBuffer<Reaction> {
    override fun read(buf: ByteBuffer): Reaction {
        return Reaction(
            FfiConverterString.read(buf),
            FfiConverterSequenceTypeReactionSenderData.read(buf),
        )
    }

    override fun allocationSize(value: Reaction) = (
            FfiConverterString.allocationSize(value.`key`) +
            FfiConverterSequenceTypeReactionSenderData.allocationSize(value.`senders`)
    )

    override fun write(value: Reaction, buf: ByteBuffer) {
            FfiConverterString.write(value.`key`, buf)
            FfiConverterSequenceTypeReactionSenderData.write(value.`senders`, buf)
    }
}



data class ReactionSenderData (
    var `senderId`: kotlin.String, 
    var `timestamp`: Timestamp
) {
    
    companion object
}

public object FfiConverterTypeReactionSenderData: FfiConverterRustBuffer<ReactionSenderData> {
    override fun read(buf: ByteBuffer): ReactionSenderData {
        return ReactionSenderData(
            FfiConverterString.read(buf),
            FfiConverterTypeTimestamp.read(buf),
        )
    }

    override fun allocationSize(value: ReactionSenderData) = (
            FfiConverterString.allocationSize(value.`senderId`) +
            FfiConverterTypeTimestamp.allocationSize(value.`timestamp`)
    )

    override fun write(value: ReactionSenderData, buf: ByteBuffer) {
            FfiConverterString.write(value.`senderId`, buf)
            FfiConverterTypeTimestamp.write(value.`timestamp`, buf)
    }
}



data class Receipt (
    var `timestamp`: Timestamp?
) {
    
    companion object
}

public object FfiConverterTypeReceipt: FfiConverterRustBuffer<Receipt> {
    override fun read(buf: ByteBuffer): Receipt {
        return Receipt(
            FfiConverterOptionalTypeTimestamp.read(buf),
        )
    }

    override fun allocationSize(value: Receipt) = (
            FfiConverterOptionalTypeTimestamp.allocationSize(value.`timestamp`)
    )

    override fun write(value: Receipt, buf: ByteBuffer) {
            FfiConverterOptionalTypeTimestamp.write(value.`timestamp`, buf)
    }
}



/**
 * Represents an emoji recently used for reactions.
 */
data class RecentEmoji (
    /**
     * The actual emoji text representation.
     */
    var `emoji`: kotlin.String, 
    /**
     * The number of times this emoji has been used for reactions.
     */
    var `count`: kotlin.ULong
) {
    
    companion object
}

public object FfiConverterTypeRecentEmoji: FfiConverterRustBuffer<RecentEmoji> {
    override fun read(buf: ByteBuffer): RecentEmoji {
        return RecentEmoji(
            FfiConverterString.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: RecentEmoji) = (
            FfiConverterString.allocationSize(value.`emoji`) +
            FfiConverterULong.allocationSize(value.`count`)
    )

    override fun write(value: RecentEmoji, buf: ByteBuffer) {
            FfiConverterString.write(value.`emoji`, buf)
            FfiConverterULong.write(value.`count`, buf)
    }
}



/**
 * The config to use for HTTP requests by default in this client.
 */
data class RequestConfig (
    /**
     * Max number of retries.
     */
    var `retryLimit`: kotlin.ULong?, 
    /**
     * Timeout for a request in milliseconds.
     */
    var `timeout`: kotlin.ULong?, 
    /**
     * Max number of concurrent requests. No value means no limits.
     */
    var `maxConcurrentRequests`: kotlin.ULong?, 
    /**
     * Base delay between retries.
     */
    var `maxRetryTime`: kotlin.ULong?
) {
    
    companion object
}

public object FfiConverterTypeRequestConfig: FfiConverterRustBuffer<RequestConfig> {
    override fun read(buf: ByteBuffer): RequestConfig {
        return RequestConfig(
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalULong.read(buf),
        )
    }

    override fun allocationSize(value: RequestConfig) = (
            FfiConverterOptionalULong.allocationSize(value.`retryLimit`) +
            FfiConverterOptionalULong.allocationSize(value.`timeout`) +
            FfiConverterOptionalULong.allocationSize(value.`maxConcurrentRequests`) +
            FfiConverterOptionalULong.allocationSize(value.`maxRetryTime`)
    )

    override fun write(value: RequestConfig, buf: ByteBuffer) {
            FfiConverterOptionalULong.write(value.`retryLimit`, buf)
            FfiConverterOptionalULong.write(value.`timeout`, buf)
            FfiConverterOptionalULong.write(value.`maxConcurrentRequests`, buf)
            FfiConverterOptionalULong.write(value.`maxRetryTime`, buf)
    }
}



/**
 * Information about a room, that was resolved from a room alias.
 */
data class ResolvedRoomAlias (
    /**
     * The room ID that the alias resolved to.
     */
    var `roomId`: kotlin.String, 
    /**
     * A list of servers that can be used to find the room by its room ID.
     */
    var `servers`: List<kotlin.String>
) {
    
    companion object
}

public object FfiConverterTypeResolvedRoomAlias: FfiConverterRustBuffer<ResolvedRoomAlias> {
    override fun read(buf: ByteBuffer): ResolvedRoomAlias {
        return ResolvedRoomAlias(
            FfiConverterString.read(buf),
            FfiConverterSequenceString.read(buf),
        )
    }

    override fun allocationSize(value: ResolvedRoomAlias) = (
            FfiConverterString.allocationSize(value.`roomId`) +
            FfiConverterSequenceString.allocationSize(value.`servers`)
    )

    override fun write(value: ResolvedRoomAlias, buf: ByteBuffer) {
            FfiConverterString.write(value.`roomId`, buf)
            FfiConverterSequenceString.write(value.`servers`, buf)
    }
}



data class RoomDescription (
    var `roomId`: kotlin.String, 
    var `name`: kotlin.String?, 
    var `topic`: kotlin.String?, 
    var `alias`: kotlin.String?, 
    var `avatarUrl`: kotlin.String?, 
    var `joinRule`: PublicRoomJoinRule?, 
    var `isWorldReadable`: kotlin.Boolean, 
    var `joinedMembers`: kotlin.ULong
) {
    
    companion object
}

public object FfiConverterTypeRoomDescription: FfiConverterRustBuffer<RoomDescription> {
    override fun read(buf: ByteBuffer): RoomDescription {
        return RoomDescription(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalTypePublicRoomJoinRule.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: RoomDescription) = (
            FfiConverterString.allocationSize(value.`roomId`) +
            FfiConverterOptionalString.allocationSize(value.`name`) +
            FfiConverterOptionalString.allocationSize(value.`topic`) +
            FfiConverterOptionalString.allocationSize(value.`alias`) +
            FfiConverterOptionalString.allocationSize(value.`avatarUrl`) +
            FfiConverterOptionalTypePublicRoomJoinRule.allocationSize(value.`joinRule`) +
            FfiConverterBoolean.allocationSize(value.`isWorldReadable`) +
            FfiConverterULong.allocationSize(value.`joinedMembers`)
    )

    override fun write(value: RoomDescription, buf: ByteBuffer) {
            FfiConverterString.write(value.`roomId`, buf)
            FfiConverterOptionalString.write(value.`name`, buf)
            FfiConverterOptionalString.write(value.`topic`, buf)
            FfiConverterOptionalString.write(value.`alias`, buf)
            FfiConverterOptionalString.write(value.`avatarUrl`, buf)
            FfiConverterOptionalTypePublicRoomJoinRule.write(value.`joinRule`, buf)
            FfiConverterBoolean.write(value.`isWorldReadable`, buf)
            FfiConverterULong.write(value.`joinedMembers`, buf)
    }
}



/**
 * Information about a member considered to be a room hero.
 */
data class RoomHero (
    /**
     * The user ID of the hero.
     */
    var `userId`: kotlin.String, 
    /**
     * The display name of the hero.
     */
    var `displayName`: kotlin.String?, 
    /**
     * The avatar URL of the hero.
     */
    var `avatarUrl`: kotlin.String?
) {
    
    companion object
}

public object FfiConverterTypeRoomHero: FfiConverterRustBuffer<RoomHero> {
    override fun read(buf: ByteBuffer): RoomHero {
        return RoomHero(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: RoomHero) = (
            FfiConverterString.allocationSize(value.`userId`) +
            FfiConverterOptionalString.allocationSize(value.`displayName`) +
            FfiConverterOptionalString.allocationSize(value.`avatarUrl`)
    )

    override fun write(value: RoomHero, buf: ByteBuffer) {
            FfiConverterString.write(value.`userId`, buf)
            FfiConverterOptionalString.write(value.`displayName`, buf)
            FfiConverterOptionalString.write(value.`avatarUrl`, buf)
    }
}



data class RoomInfo (
    var `id`: kotlin.String, 
    var `encryptionState`: EncryptionState, 
    var `creators`: List<kotlin.String>?, 
    /**
     * The room's name from the room state event if received from sync, or one
     * that's been computed otherwise.
     */
    var `displayName`: kotlin.String?, 
    /**
     * Room name as defined by the room state event only.
     */
    var `rawName`: kotlin.String?, 
    var `topic`: kotlin.String?, 
    var `avatarUrl`: kotlin.String?, 
    var `isDirect`: kotlin.Boolean, 
    /**
     * Whether the room is public or not, based on the join rules.
     *
     * Can be `None` if the join rules state event is not available for this
     * room.
     */
    var `isPublic`: kotlin.Boolean?, 
    var `isSpace`: kotlin.Boolean, 
    /**
     * If present, it means the room has been archived/upgraded.
     */
    var `successorRoom`: SuccessorRoom?, 
    var `isFavourite`: kotlin.Boolean, 
    var `canonicalAlias`: kotlin.String?, 
    var `alternativeAliases`: List<kotlin.String>, 
    var `membership`: Membership, 
    /**
     * Member who invited the current user to a room that's in the invited
     * state.
     *
     * Can be missing if the room membership invite event is missing from the
     * store.
     */
    var `inviter`: RoomMember?, 
    var `heroes`: List<RoomHero>, 
    var `activeMembersCount`: kotlin.ULong, 
    var `invitedMembersCount`: kotlin.ULong, 
    var `joinedMembersCount`: kotlin.ULong, 
    var `highlightCount`: kotlin.ULong, 
    var `notificationCount`: kotlin.ULong, 
    var `cachedUserDefinedNotificationMode`: RoomNotificationMode?, 
    var `hasRoomCall`: kotlin.Boolean, 
    var `activeRoomCallParticipants`: List<kotlin.String>, 
    /**
     * Whether this room has been explicitly marked as unread
     */
    var `isMarkedUnread`: kotlin.Boolean, 
    /**
     * "Interesting" messages received in that room, independently of the
     * notification settings.
     */
    var `numUnreadMessages`: kotlin.ULong, 
    /**
     * Events that will notify the user, according to their
     * notification settings.
     */
    var `numUnreadNotifications`: kotlin.ULong, 
    /**
     * Events causing mentions/highlights for the user, according to their
     * notification settings.
     */
    var `numUnreadMentions`: kotlin.ULong, 
    /**
     * The currently pinned event ids.
     */
    var `pinnedEventIds`: List<kotlin.String>, 
    /**
     * The join rule for this room, if known.
     */
    var `joinRule`: JoinRule?, 
    /**
     * The history visibility for this room, if known.
     */
    var `historyVisibility`: RoomHistoryVisibility, 
    /**
     * This room's current power levels.
     *
     * Can be missing if the room power levels event is missing from the store.
     */
    var `powerLevels`: RoomPowerLevels?, 
    /**
     * This room's version.
     */
    var `roomVersion`: kotlin.String?, 
    /**
     * Whether creators are privileged over every other user (have infinite
     * power level).
     */
    var `privilegedCreatorsRole`: kotlin.Boolean
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
        Disposable.destroy(this.`id`)
    
        Disposable.destroy(this.`encryptionState`)
    
        Disposable.destroy(this.`creators`)
    
        Disposable.destroy(this.`displayName`)
    
        Disposable.destroy(this.`rawName`)
    
        Disposable.destroy(this.`topic`)
    
        Disposable.destroy(this.`avatarUrl`)
    
        Disposable.destroy(this.`isDirect`)
    
        Disposable.destroy(this.`isPublic`)
    
        Disposable.destroy(this.`isSpace`)
    
        Disposable.destroy(this.`successorRoom`)
    
        Disposable.destroy(this.`isFavourite`)
    
        Disposable.destroy(this.`canonicalAlias`)
    
        Disposable.destroy(this.`alternativeAliases`)
    
        Disposable.destroy(this.`membership`)
    
        Disposable.destroy(this.`inviter`)
    
        Disposable.destroy(this.`heroes`)
    
        Disposable.destroy(this.`activeMembersCount`)
    
        Disposable.destroy(this.`invitedMembersCount`)
    
        Disposable.destroy(this.`joinedMembersCount`)
    
        Disposable.destroy(this.`highlightCount`)
    
        Disposable.destroy(this.`notificationCount`)
    
        Disposable.destroy(this.`cachedUserDefinedNotificationMode`)
    
        Disposable.destroy(this.`hasRoomCall`)
    
        Disposable.destroy(this.`activeRoomCallParticipants`)
    
        Disposable.destroy(this.`isMarkedUnread`)
    
        Disposable.destroy(this.`numUnreadMessages`)
    
        Disposable.destroy(this.`numUnreadNotifications`)
    
        Disposable.destroy(this.`numUnreadMentions`)
    
        Disposable.destroy(this.`pinnedEventIds`)
    
        Disposable.destroy(this.`joinRule`)
    
        Disposable.destroy(this.`historyVisibility`)
    
        Disposable.destroy(this.`powerLevels`)
    
        Disposable.destroy(this.`roomVersion`)
    
        Disposable.destroy(this.`privilegedCreatorsRole`)
    
    }
    
    companion object
}

public object FfiConverterTypeRoomInfo: FfiConverterRustBuffer<RoomInfo> {
    override fun read(buf: ByteBuffer): RoomInfo {
        return RoomInfo(
            FfiConverterString.read(buf),
            FfiConverterTypeEncryptionState.read(buf),
            FfiConverterOptionalSequenceString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalTypeSuccessorRoom.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterSequenceString.read(buf),
            FfiConverterTypeMembership.read(buf),
            FfiConverterOptionalTypeRoomMember.read(buf),
            FfiConverterSequenceTypeRoomHero.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterOptionalTypeRoomNotificationMode.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterSequenceString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterSequenceString.read(buf),
            FfiConverterOptionalTypeJoinRule.read(buf),
            FfiConverterTypeRoomHistoryVisibility.read(buf),
            FfiConverterOptionalTypeRoomPowerLevels.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: RoomInfo) = (
            FfiConverterString.allocationSize(value.`id`) +
            FfiConverterTypeEncryptionState.allocationSize(value.`encryptionState`) +
            FfiConverterOptionalSequenceString.allocationSize(value.`creators`) +
            FfiConverterOptionalString.allocationSize(value.`displayName`) +
            FfiConverterOptionalString.allocationSize(value.`rawName`) +
            FfiConverterOptionalString.allocationSize(value.`topic`) +
            FfiConverterOptionalString.allocationSize(value.`avatarUrl`) +
            FfiConverterBoolean.allocationSize(value.`isDirect`) +
            FfiConverterOptionalBoolean.allocationSize(value.`isPublic`) +
            FfiConverterBoolean.allocationSize(value.`isSpace`) +
            FfiConverterOptionalTypeSuccessorRoom.allocationSize(value.`successorRoom`) +
            FfiConverterBoolean.allocationSize(value.`isFavourite`) +
            FfiConverterOptionalString.allocationSize(value.`canonicalAlias`) +
            FfiConverterSequenceString.allocationSize(value.`alternativeAliases`) +
            FfiConverterTypeMembership.allocationSize(value.`membership`) +
            FfiConverterOptionalTypeRoomMember.allocationSize(value.`inviter`) +
            FfiConverterSequenceTypeRoomHero.allocationSize(value.`heroes`) +
            FfiConverterULong.allocationSize(value.`activeMembersCount`) +
            FfiConverterULong.allocationSize(value.`invitedMembersCount`) +
            FfiConverterULong.allocationSize(value.`joinedMembersCount`) +
            FfiConverterULong.allocationSize(value.`highlightCount`) +
            FfiConverterULong.allocationSize(value.`notificationCount`) +
            FfiConverterOptionalTypeRoomNotificationMode.allocationSize(value.`cachedUserDefinedNotificationMode`) +
            FfiConverterBoolean.allocationSize(value.`hasRoomCall`) +
            FfiConverterSequenceString.allocationSize(value.`activeRoomCallParticipants`) +
            FfiConverterBoolean.allocationSize(value.`isMarkedUnread`) +
            FfiConverterULong.allocationSize(value.`numUnreadMessages`) +
            FfiConverterULong.allocationSize(value.`numUnreadNotifications`) +
            FfiConverterULong.allocationSize(value.`numUnreadMentions`) +
            FfiConverterSequenceString.allocationSize(value.`pinnedEventIds`) +
            FfiConverterOptionalTypeJoinRule.allocationSize(value.`joinRule`) +
            FfiConverterTypeRoomHistoryVisibility.allocationSize(value.`historyVisibility`) +
            FfiConverterOptionalTypeRoomPowerLevels.allocationSize(value.`powerLevels`) +
            FfiConverterOptionalString.allocationSize(value.`roomVersion`) +
            FfiConverterBoolean.allocationSize(value.`privilegedCreatorsRole`)
    )

    override fun write(value: RoomInfo, buf: ByteBuffer) {
            FfiConverterString.write(value.`id`, buf)
            FfiConverterTypeEncryptionState.write(value.`encryptionState`, buf)
            FfiConverterOptionalSequenceString.write(value.`creators`, buf)
            FfiConverterOptionalString.write(value.`displayName`, buf)
            FfiConverterOptionalString.write(value.`rawName`, buf)
            FfiConverterOptionalString.write(value.`topic`, buf)
            FfiConverterOptionalString.write(value.`avatarUrl`, buf)
            FfiConverterBoolean.write(value.`isDirect`, buf)
            FfiConverterOptionalBoolean.write(value.`isPublic`, buf)
            FfiConverterBoolean.write(value.`isSpace`, buf)
            FfiConverterOptionalTypeSuccessorRoom.write(value.`successorRoom`, buf)
            FfiConverterBoolean.write(value.`isFavourite`, buf)
            FfiConverterOptionalString.write(value.`canonicalAlias`, buf)
            FfiConverterSequenceString.write(value.`alternativeAliases`, buf)
            FfiConverterTypeMembership.write(value.`membership`, buf)
            FfiConverterOptionalTypeRoomMember.write(value.`inviter`, buf)
            FfiConverterSequenceTypeRoomHero.write(value.`heroes`, buf)
            FfiConverterULong.write(value.`activeMembersCount`, buf)
            FfiConverterULong.write(value.`invitedMembersCount`, buf)
            FfiConverterULong.write(value.`joinedMembersCount`, buf)
            FfiConverterULong.write(value.`highlightCount`, buf)
            FfiConverterULong.write(value.`notificationCount`, buf)
            FfiConverterOptionalTypeRoomNotificationMode.write(value.`cachedUserDefinedNotificationMode`, buf)
            FfiConverterBoolean.write(value.`hasRoomCall`, buf)
            FfiConverterSequenceString.write(value.`activeRoomCallParticipants`, buf)
            FfiConverterBoolean.write(value.`isMarkedUnread`, buf)
            FfiConverterULong.write(value.`numUnreadMessages`, buf)
            FfiConverterULong.write(value.`numUnreadNotifications`, buf)
            FfiConverterULong.write(value.`numUnreadMentions`, buf)
            FfiConverterSequenceString.write(value.`pinnedEventIds`, buf)
            FfiConverterOptionalTypeJoinRule.write(value.`joinRule`, buf)
            FfiConverterTypeRoomHistoryVisibility.write(value.`historyVisibility`, buf)
            FfiConverterOptionalTypeRoomPowerLevels.write(value.`powerLevels`, buf)
            FfiConverterOptionalString.write(value.`roomVersion`, buf)
            FfiConverterBoolean.write(value.`privilegedCreatorsRole`, buf)
    }
}



data class RoomListLoadingStateResult (
    var `state`: RoomListLoadingState, 
    var `stateStream`: TaskHandle
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
        Disposable.destroy(this.`state`)
    
        Disposable.destroy(this.`stateStream`)
    
    }
    
    companion object
}

public object FfiConverterTypeRoomListLoadingStateResult: FfiConverterRustBuffer<RoomListLoadingStateResult> {
    override fun read(buf: ByteBuffer): RoomListLoadingStateResult {
        return RoomListLoadingStateResult(
            FfiConverterTypeRoomListLoadingState.read(buf),
            FfiConverterTypeTaskHandle.read(buf),
        )
    }

    override fun allocationSize(value: RoomListLoadingStateResult) = (
            FfiConverterTypeRoomListLoadingState.allocationSize(value.`state`) +
            FfiConverterTypeTaskHandle.allocationSize(value.`stateStream`)
    )

    override fun write(value: RoomListLoadingStateResult, buf: ByteBuffer) {
            FfiConverterTypeRoomListLoadingState.write(value.`state`, buf)
            FfiConverterTypeTaskHandle.write(value.`stateStream`, buf)
    }
}



data class RoomMember (
    var `userId`: kotlin.String, 
    var `displayName`: kotlin.String?, 
    var `avatarUrl`: kotlin.String?, 
    var `membership`: MembershipState, 
    var `isNameAmbiguous`: kotlin.Boolean, 
    var `powerLevel`: PowerLevel, 
    var `isIgnored`: kotlin.Boolean, 
    var `suggestedRoleForPowerLevel`: RoomMemberRole, 
    var `membershipChangeReason`: kotlin.String?
) {
    
    companion object
}

public object FfiConverterTypeRoomMember: FfiConverterRustBuffer<RoomMember> {
    override fun read(buf: ByteBuffer): RoomMember {
        return RoomMember(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterTypeMembershipState.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterTypePowerLevel.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterTypeRoomMemberRole.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: RoomMember) = (
            FfiConverterString.allocationSize(value.`userId`) +
            FfiConverterOptionalString.allocationSize(value.`displayName`) +
            FfiConverterOptionalString.allocationSize(value.`avatarUrl`) +
            FfiConverterTypeMembershipState.allocationSize(value.`membership`) +
            FfiConverterBoolean.allocationSize(value.`isNameAmbiguous`) +
            FfiConverterTypePowerLevel.allocationSize(value.`powerLevel`) +
            FfiConverterBoolean.allocationSize(value.`isIgnored`) +
            FfiConverterTypeRoomMemberRole.allocationSize(value.`suggestedRoleForPowerLevel`) +
            FfiConverterOptionalString.allocationSize(value.`membershipChangeReason`)
    )

    override fun write(value: RoomMember, buf: ByteBuffer) {
            FfiConverterString.write(value.`userId`, buf)
            FfiConverterOptionalString.write(value.`displayName`, buf)
            FfiConverterOptionalString.write(value.`avatarUrl`, buf)
            FfiConverterTypeMembershipState.write(value.`membership`, buf)
            FfiConverterBoolean.write(value.`isNameAmbiguous`, buf)
            FfiConverterTypePowerLevel.write(value.`powerLevel`, buf)
            FfiConverterBoolean.write(value.`isIgnored`, buf)
            FfiConverterTypeRoomMemberRole.write(value.`suggestedRoleForPowerLevel`, buf)
            FfiConverterOptionalString.write(value.`membershipChangeReason`, buf)
    }
}



/**
 * Contains the current user's room member info and the optional room member
 * info of the sender of the `m.room.member` event that this info represents.
 */
data class RoomMemberWithSenderInfo (
    /**
     * The room member.
     */
    var `roomMember`: RoomMember, 
    /**
     * The info of the sender of the event `room_member` is based on, if
     * available.
     */
    var `senderInfo`: RoomMember?
) {
    
    companion object
}

public object FfiConverterTypeRoomMemberWithSenderInfo: FfiConverterRustBuffer<RoomMemberWithSenderInfo> {
    override fun read(buf: ByteBuffer): RoomMemberWithSenderInfo {
        return RoomMemberWithSenderInfo(
            FfiConverterTypeRoomMember.read(buf),
            FfiConverterOptionalTypeRoomMember.read(buf),
        )
    }

    override fun allocationSize(value: RoomMemberWithSenderInfo) = (
            FfiConverterTypeRoomMember.allocationSize(value.`roomMember`) +
            FfiConverterOptionalTypeRoomMember.allocationSize(value.`senderInfo`)
    )

    override fun write(value: RoomMemberWithSenderInfo, buf: ByteBuffer) {
            FfiConverterTypeRoomMember.write(value.`roomMember`, buf)
            FfiConverterOptionalTypeRoomMember.write(value.`senderInfo`, buf)
    }
}



/**
 * `RoomNotificationSettings` represents the current settings for a `Room`
 */
data class RoomNotificationSettings (
    /**
     * The room notification mode
     */
    var `mode`: RoomNotificationMode, 
    /**
     * Whether the mode is the default one
     */
    var `isDefault`: kotlin.Boolean
) {
    
    companion object
}

public object FfiConverterTypeRoomNotificationSettings: FfiConverterRustBuffer<RoomNotificationSettings> {
    override fun read(buf: ByteBuffer): RoomNotificationSettings {
        return RoomNotificationSettings(
            FfiConverterTypeRoomNotificationMode.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: RoomNotificationSettings) = (
            FfiConverterTypeRoomNotificationMode.allocationSize(value.`mode`) +
            FfiConverterBoolean.allocationSize(value.`isDefault`)
    )

    override fun write(value: RoomNotificationSettings, buf: ByteBuffer) {
            FfiConverterTypeRoomNotificationMode.write(value.`mode`, buf)
            FfiConverterBoolean.write(value.`isDefault`, buf)
    }
}



/**
 * This intermediary struct is used to expose the power levels values through
 * FFI and work around it not exposing public exported object fields.
 */
data class RoomPowerLevelsValues (
    /**
     * The level required to ban a user.
     */
    var `ban`: kotlin.Long, 
    /**
     * The level required to invite a user.
     */
    var `invite`: kotlin.Long, 
    /**
     * The level required to kick a user.
     */
    var `kick`: kotlin.Long, 
    /**
     * The level required to redact an event.
     */
    var `redact`: kotlin.Long, 
    /**
     * The default level required to send message events.
     */
    var `eventsDefault`: kotlin.Long, 
    /**
     * The default level required to send state events.
     */
    var `stateDefault`: kotlin.Long, 
    /**
     * The default power level for every user in the room.
     */
    var `usersDefault`: kotlin.Long, 
    /**
     * The level required to change the room's name.
     */
    var `roomName`: kotlin.Long, 
    /**
     * The level required to change the room's avatar.
     */
    var `roomAvatar`: kotlin.Long, 
    /**
     * The level required to change the room's topic.
     */
    var `roomTopic`: kotlin.Long
) {
    
    companion object
}

public object FfiConverterTypeRoomPowerLevelsValues: FfiConverterRustBuffer<RoomPowerLevelsValues> {
    override fun read(buf: ByteBuffer): RoomPowerLevelsValues {
        return RoomPowerLevelsValues(
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterLong.read(buf),
        )
    }

    override fun allocationSize(value: RoomPowerLevelsValues) = (
            FfiConverterLong.allocationSize(value.`ban`) +
            FfiConverterLong.allocationSize(value.`invite`) +
            FfiConverterLong.allocationSize(value.`kick`) +
            FfiConverterLong.allocationSize(value.`redact`) +
            FfiConverterLong.allocationSize(value.`eventsDefault`) +
            FfiConverterLong.allocationSize(value.`stateDefault`) +
            FfiConverterLong.allocationSize(value.`usersDefault`) +
            FfiConverterLong.allocationSize(value.`roomName`) +
            FfiConverterLong.allocationSize(value.`roomAvatar`) +
            FfiConverterLong.allocationSize(value.`roomTopic`)
    )

    override fun write(value: RoomPowerLevelsValues, buf: ByteBuffer) {
            FfiConverterLong.write(value.`ban`, buf)
            FfiConverterLong.write(value.`invite`, buf)
            FfiConverterLong.write(value.`kick`, buf)
            FfiConverterLong.write(value.`redact`, buf)
            FfiConverterLong.write(value.`eventsDefault`, buf)
            FfiConverterLong.write(value.`stateDefault`, buf)
            FfiConverterLong.write(value.`usersDefault`, buf)
            FfiConverterLong.write(value.`roomName`, buf)
            FfiConverterLong.write(value.`roomAvatar`, buf)
            FfiConverterLong.write(value.`roomTopic`, buf)
    }
}



/**
 * The preview of a room, be it invited/joined/left, or not.
 */
data class RoomPreviewInfo (
    /**
     * The room id for this room.
     */
    var `roomId`: kotlin.String, 
    /**
     * The canonical alias for the room.
     */
    var `canonicalAlias`: kotlin.String?, 
    /**
     * The room's name, if set.
     */
    var `name`: kotlin.String?, 
    /**
     * The room's topic, if set.
     */
    var `topic`: kotlin.String?, 
    /**
     * The MXC URI to the room's avatar, if set.
     */
    var `avatarUrl`: kotlin.String?, 
    /**
     * The number of joined members.
     */
    var `numJoinedMembers`: kotlin.ULong, 
    /**
     * The number of active members, if known (joined + invited).
     */
    var `numActiveMembers`: kotlin.ULong?, 
    /**
     * The room type (space, custom) or nothing, if it's a regular room.
     */
    var `roomType`: RoomType, 
    /**
     * Is the history world-readable for this room?
     */
    var `isHistoryWorldReadable`: kotlin.Boolean?, 
    /**
     * The membership state for the current user, if known.
     */
    var `membership`: Membership?, 
    /**
     * The join rule for this room (private, public, knock, etc.).
     */
    var `joinRule`: JoinRule?, 
    /**
     * Whether the room is direct or not, if known.
     */
    var `isDirect`: kotlin.Boolean?, 
    /**
     * Room heroes.
     */
    var `heroes`: List<RoomHero>?
) {
    
    companion object
}

public object FfiConverterTypeRoomPreviewInfo: FfiConverterRustBuffer<RoomPreviewInfo> {
    override fun read(buf: ByteBuffer): RoomPreviewInfo {
        return RoomPreviewInfo(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterTypeRoomType.read(buf),
            FfiConverterOptionalBoolean.read(buf),
            FfiConverterOptionalTypeMembership.read(buf),
            FfiConverterOptionalTypeJoinRule.read(buf),
            FfiConverterOptionalBoolean.read(buf),
            FfiConverterOptionalSequenceTypeRoomHero.read(buf),
        )
    }

    override fun allocationSize(value: RoomPreviewInfo) = (
            FfiConverterString.allocationSize(value.`roomId`) +
            FfiConverterOptionalString.allocationSize(value.`canonicalAlias`) +
            FfiConverterOptionalString.allocationSize(value.`name`) +
            FfiConverterOptionalString.allocationSize(value.`topic`) +
            FfiConverterOptionalString.allocationSize(value.`avatarUrl`) +
            FfiConverterULong.allocationSize(value.`numJoinedMembers`) +
            FfiConverterOptionalULong.allocationSize(value.`numActiveMembers`) +
            FfiConverterTypeRoomType.allocationSize(value.`roomType`) +
            FfiConverterOptionalBoolean.allocationSize(value.`isHistoryWorldReadable`) +
            FfiConverterOptionalTypeMembership.allocationSize(value.`membership`) +
            FfiConverterOptionalTypeJoinRule.allocationSize(value.`joinRule`) +
            FfiConverterOptionalBoolean.allocationSize(value.`isDirect`) +
            FfiConverterOptionalSequenceTypeRoomHero.allocationSize(value.`heroes`)
    )

    override fun write(value: RoomPreviewInfo, buf: ByteBuffer) {
            FfiConverterString.write(value.`roomId`, buf)
            FfiConverterOptionalString.write(value.`canonicalAlias`, buf)
            FfiConverterOptionalString.write(value.`name`, buf)
            FfiConverterOptionalString.write(value.`topic`, buf)
            FfiConverterOptionalString.write(value.`avatarUrl`, buf)
            FfiConverterULong.write(value.`numJoinedMembers`, buf)
            FfiConverterOptionalULong.write(value.`numActiveMembers`, buf)
            FfiConverterTypeRoomType.write(value.`roomType`, buf)
            FfiConverterOptionalBoolean.write(value.`isHistoryWorldReadable`, buf)
            FfiConverterOptionalTypeMembership.write(value.`membership`, buf)
            FfiConverterOptionalTypeJoinRule.write(value.`joinRule`, buf)
            FfiConverterOptionalBoolean.write(value.`isDirect`, buf)
            FfiConverterOptionalSequenceTypeRoomHero.write(value.`heroes`, buf)
    }
}



/**
 * A push ruleset scopes a set of rules according to some criteria.
 */
data class Ruleset (
    /**
     * These rules configure behavior for (unencrypted) messages that match
     * certain patterns.
     */
    var `content`: List<PatternedPushRule>, 
    /**
     * These user-configured rules are given the highest priority.
     *
     * This field is named `override_` instead of `override` because the latter
     * is a reserved keyword in Rust.
     */
    var `override`: List<ConditionalPushRule>, 
    /**
     * These rules change the behavior of all messages for a given room.
     */
    var `room`: List<SimplePushRule>, 
    /**
     * These rules configure notification behavior for messages from a specific
     * Matrix user ID.
     */
    var `sender`: List<SimplePushRule>, 
    /**
     * These rules are identical to override rules, but have a lower priority
     * than `content`, `room` and `sender` rules.
     */
    var `underride`: List<ConditionalPushRule>
) {
    
    companion object
}

public object FfiConverterTypeRuleset: FfiConverterRustBuffer<Ruleset> {
    override fun read(buf: ByteBuffer): Ruleset {
        return Ruleset(
            FfiConverterSequenceTypePatternedPushRule.read(buf),
            FfiConverterSequenceTypeConditionalPushRule.read(buf),
            FfiConverterSequenceTypeSimplePushRule.read(buf),
            FfiConverterSequenceTypeSimplePushRule.read(buf),
            FfiConverterSequenceTypeConditionalPushRule.read(buf),
        )
    }

    override fun allocationSize(value: Ruleset) = (
            FfiConverterSequenceTypePatternedPushRule.allocationSize(value.`content`) +
            FfiConverterSequenceTypeConditionalPushRule.allocationSize(value.`override`) +
            FfiConverterSequenceTypeSimplePushRule.allocationSize(value.`room`) +
            FfiConverterSequenceTypeSimplePushRule.allocationSize(value.`sender`) +
            FfiConverterSequenceTypeConditionalPushRule.allocationSize(value.`underride`)
    )

    override fun write(value: Ruleset, buf: ByteBuffer) {
            FfiConverterSequenceTypePatternedPushRule.write(value.`content`, buf)
            FfiConverterSequenceTypeConditionalPushRule.write(value.`override`, buf)
            FfiConverterSequenceTypeSimplePushRule.write(value.`room`, buf)
            FfiConverterSequenceTypeSimplePushRule.write(value.`sender`, buf)
            FfiConverterSequenceTypeConditionalPushRule.write(value.`underride`, buf)
    }
}



data class SearchUsersResults (
    var `results`: List<UserProfile>, 
    var `limited`: kotlin.Boolean
) {
    
    companion object
}

public object FfiConverterTypeSearchUsersResults: FfiConverterRustBuffer<SearchUsersResults> {
    override fun read(buf: ByteBuffer): SearchUsersResults {
        return SearchUsersResults(
            FfiConverterSequenceTypeUserProfile.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: SearchUsersResults) = (
            FfiConverterSequenceTypeUserProfile.allocationSize(value.`results`) +
            FfiConverterBoolean.allocationSize(value.`limited`)
    )

    override fun write(value: SearchUsersResults, buf: ByteBuffer) {
            FfiConverterSequenceTypeUserProfile.write(value.`results`, buf)
            FfiConverterBoolean.write(value.`limited`, buf)
    }
}



/**
 * The key properties for the `m.secret_storage.v1.aes-hmac-sha2`` algorithm.
 */
data class SecretStorageV1AesHmacSha2Properties (
    /**
     * The 16-byte initialization vector, encoded as base64.
     */
    var `iv`: kotlin.String?, 
    /**
     * The MAC, encoded as base64.
     */
    var `mac`: kotlin.String?
) {
    
    companion object
}

public object FfiConverterTypeSecretStorageV1AesHmacSha2Properties: FfiConverterRustBuffer<SecretStorageV1AesHmacSha2Properties> {
    override fun read(buf: ByteBuffer): SecretStorageV1AesHmacSha2Properties {
        return SecretStorageV1AesHmacSha2Properties(
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: SecretStorageV1AesHmacSha2Properties) = (
            FfiConverterOptionalString.allocationSize(value.`iv`) +
            FfiConverterOptionalString.allocationSize(value.`mac`)
    )

    override fun write(value: SecretStorageV1AesHmacSha2Properties, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`iv`, buf)
            FfiConverterOptionalString.write(value.`mac`, buf)
    }
}



data class Session (
    /**
     * The access token used for this session.
     */
    var `accessToken`: kotlin.String, 
    /**
     * The token used for [refreshing the access token], if any.
     *
     * [refreshing the access token]: https://spec.matrix.org/v1.3/client-server-api/#refreshing-access-tokens
     */
    var `refreshToken`: kotlin.String?, 
    /**
     * The user the access token was issued for.
     */
    var `userId`: kotlin.String, 
    /**
     * The ID of the client device.
     */
    var `deviceId`: kotlin.String, 
    /**
     * The URL for the homeserver used for this session.
     */
    var `homeserverUrl`: kotlin.String, 
    /**
     * Additional data for this session if OpenID Connect was used for
     * authentication.
     */
    var `oidcData`: kotlin.String?, 
    /**
     * The sliding sync version used for this session.
     */
    var `slidingSyncVersion`: SlidingSyncVersion
) {
    
    companion object
}

public object FfiConverterTypeSession: FfiConverterRustBuffer<Session> {
    override fun read(buf: ByteBuffer): Session {
        return Session(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterTypeSlidingSyncVersion.read(buf),
        )
    }

    override fun allocationSize(value: Session) = (
            FfiConverterString.allocationSize(value.`accessToken`) +
            FfiConverterOptionalString.allocationSize(value.`refreshToken`) +
            FfiConverterString.allocationSize(value.`userId`) +
            FfiConverterString.allocationSize(value.`deviceId`) +
            FfiConverterString.allocationSize(value.`homeserverUrl`) +
            FfiConverterOptionalString.allocationSize(value.`oidcData`) +
            FfiConverterTypeSlidingSyncVersion.allocationSize(value.`slidingSyncVersion`)
    )

    override fun write(value: Session, buf: ByteBuffer) {
            FfiConverterString.write(value.`accessToken`, buf)
            FfiConverterOptionalString.write(value.`refreshToken`, buf)
            FfiConverterString.write(value.`userId`, buf)
            FfiConverterString.write(value.`deviceId`, buf)
            FfiConverterString.write(value.`homeserverUrl`, buf)
            FfiConverterOptionalString.write(value.`oidcData`, buf)
            FfiConverterTypeSlidingSyncVersion.write(value.`slidingSyncVersion`, buf)
    }
}



/**
 * Details about the incoming verification request
 */
data class SessionVerificationRequestDetails (
    var `senderProfile`: UserProfile, 
    var `flowId`: kotlin.String, 
    var `deviceId`: kotlin.String, 
    var `deviceDisplayName`: kotlin.String?, 
    /**
     * First time this device was seen in milliseconds since epoch.
     */
    var `firstSeenTimestamp`: Timestamp
) {
    
    companion object
}

public object FfiConverterTypeSessionVerificationRequestDetails: FfiConverterRustBuffer<SessionVerificationRequestDetails> {
    override fun read(buf: ByteBuffer): SessionVerificationRequestDetails {
        return SessionVerificationRequestDetails(
            FfiConverterTypeUserProfile.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterTypeTimestamp.read(buf),
        )
    }

    override fun allocationSize(value: SessionVerificationRequestDetails) = (
            FfiConverterTypeUserProfile.allocationSize(value.`senderProfile`) +
            FfiConverterString.allocationSize(value.`flowId`) +
            FfiConverterString.allocationSize(value.`deviceId`) +
            FfiConverterOptionalString.allocationSize(value.`deviceDisplayName`) +
            FfiConverterTypeTimestamp.allocationSize(value.`firstSeenTimestamp`)
    )

    override fun write(value: SessionVerificationRequestDetails, buf: ByteBuffer) {
            FfiConverterTypeUserProfile.write(value.`senderProfile`, buf)
            FfiConverterString.write(value.`flowId`, buf)
            FfiConverterString.write(value.`deviceId`, buf)
            FfiConverterOptionalString.write(value.`deviceDisplayName`, buf)
            FfiConverterTypeTimestamp.write(value.`firstSeenTimestamp`, buf)
    }
}



/**
 * A push rule is a single rule that states under what conditions an event
 * should be passed onto a push gateway and how the notification should be
 * presented.
 */
data class SimplePushRule (
    /**
     * Actions to determine if and how a notification is delivered for events
     * matching this rule.
     */
    var `actions`: List<Action>, 
    /**
     * Whether this is a default rule, or has been set explicitly.
     */
    var `default`: kotlin.Boolean, 
    /**
     * Whether the push rule is enabled or not.
     */
    var `enabled`: kotlin.Boolean, 
    /**
     * The ID of this rule.
     *
     * This is generally the Matrix ID of the entity that it applies to.
     */
    var `ruleId`: kotlin.String
) {
    
    companion object
}

public object FfiConverterTypeSimplePushRule: FfiConverterRustBuffer<SimplePushRule> {
    override fun read(buf: ByteBuffer): SimplePushRule {
        return SimplePushRule(
            FfiConverterSequenceTypeAction.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: SimplePushRule) = (
            FfiConverterSequenceTypeAction.allocationSize(value.`actions`) +
            FfiConverterBoolean.allocationSize(value.`default`) +
            FfiConverterBoolean.allocationSize(value.`enabled`) +
            FfiConverterString.allocationSize(value.`ruleId`)
    )

    override fun write(value: SimplePushRule, buf: ByteBuffer) {
            FfiConverterSequenceTypeAction.write(value.`actions`, buf)
            FfiConverterBoolean.write(value.`default`, buf)
            FfiConverterBoolean.write(value.`enabled`, buf)
            FfiConverterString.write(value.`ruleId`, buf)
    }
}



/**
 * Structure representing a room in a space and aggregated information
 * relevant to the UI layer.
 */
data class SpaceRoom (
    /**
     * The ID of the room.
     */
    var `roomId`: kotlin.String, 
    /**
     * The canonical alias of the room, if any.
     */
    var `canonicalAlias`: kotlin.String?, 
    /**
     * The room's name from the room state event if received from sync, or one
     * that's been computed otherwise.
     */
    var `displayName`: kotlin.String, 
    /**
     * Room name as defined by the room state event only.
     */
    var `rawName`: kotlin.String?, 
    /**
     * The topic of the room, if any.
     */
    var `topic`: kotlin.String?, 
    /**
     * The URL for the room's avatar, if one is set.
     */
    var `avatarUrl`: kotlin.String?, 
    /**
     * The type of room from `m.room.create`, if any.
     */
    var `roomType`: RoomType, 
    /**
     * The number of members joined to the room.
     */
    var `numJoinedMembers`: kotlin.ULong, 
    /**
     * The join rule of the room.
     */
    var `joinRule`: JoinRule?, 
    /**
     * Whether the room may be viewed by users without joining.
     */
    var `worldReadable`: kotlin.Boolean?, 
    /**
     * Whether guest users may join the room and participate in it.
     */
    var `guestCanJoin`: kotlin.Boolean, 
    /**
     * Whether this room is a direct room.
     *
     * Only set if the room is known to the client otherwise we
     * assume DMs shouldn't be exposed publicly in spaces.
     */
    var `isDirect`: kotlin.Boolean?, 
    /**
     * The number of children room this has, if a space.
     */
    var `childrenCount`: kotlin.ULong, 
    /**
     * Whether this room is joined, left etc.
     */
    var `state`: Membership?, 
    /**
     * A list of room members considered to be heroes.
     */
    var `heroes`: List<RoomHero>?, 
    /**
     * The via parameters of the room.
     */
    var `via`: List<kotlin.String>
) {
    
    companion object
}

public object FfiConverterTypeSpaceRoom: FfiConverterRustBuffer<SpaceRoom> {
    override fun read(buf: ByteBuffer): SpaceRoom {
        return SpaceRoom(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterTypeRoomType.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterOptionalTypeJoinRule.read(buf),
            FfiConverterOptionalBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalBoolean.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterOptionalTypeMembership.read(buf),
            FfiConverterOptionalSequenceTypeRoomHero.read(buf),
            FfiConverterSequenceString.read(buf),
        )
    }

    override fun allocationSize(value: SpaceRoom) = (
            FfiConverterString.allocationSize(value.`roomId`) +
            FfiConverterOptionalString.allocationSize(value.`canonicalAlias`) +
            FfiConverterString.allocationSize(value.`displayName`) +
            FfiConverterOptionalString.allocationSize(value.`rawName`) +
            FfiConverterOptionalString.allocationSize(value.`topic`) +
            FfiConverterOptionalString.allocationSize(value.`avatarUrl`) +
            FfiConverterTypeRoomType.allocationSize(value.`roomType`) +
            FfiConverterULong.allocationSize(value.`numJoinedMembers`) +
            FfiConverterOptionalTypeJoinRule.allocationSize(value.`joinRule`) +
            FfiConverterOptionalBoolean.allocationSize(value.`worldReadable`) +
            FfiConverterBoolean.allocationSize(value.`guestCanJoin`) +
            FfiConverterOptionalBoolean.allocationSize(value.`isDirect`) +
            FfiConverterULong.allocationSize(value.`childrenCount`) +
            FfiConverterOptionalTypeMembership.allocationSize(value.`state`) +
            FfiConverterOptionalSequenceTypeRoomHero.allocationSize(value.`heroes`) +
            FfiConverterSequenceString.allocationSize(value.`via`)
    )

    override fun write(value: SpaceRoom, buf: ByteBuffer) {
            FfiConverterString.write(value.`roomId`, buf)
            FfiConverterOptionalString.write(value.`canonicalAlias`, buf)
            FfiConverterString.write(value.`displayName`, buf)
            FfiConverterOptionalString.write(value.`rawName`, buf)
            FfiConverterOptionalString.write(value.`topic`, buf)
            FfiConverterOptionalString.write(value.`avatarUrl`, buf)
            FfiConverterTypeRoomType.write(value.`roomType`, buf)
            FfiConverterULong.write(value.`numJoinedMembers`, buf)
            FfiConverterOptionalTypeJoinRule.write(value.`joinRule`, buf)
            FfiConverterOptionalBoolean.write(value.`worldReadable`, buf)
            FfiConverterBoolean.write(value.`guestCanJoin`, buf)
            FfiConverterOptionalBoolean.write(value.`isDirect`, buf)
            FfiConverterULong.write(value.`childrenCount`, buf)
            FfiConverterOptionalTypeMembership.write(value.`state`, buf)
            FfiConverterOptionalSequenceTypeRoomHero.write(value.`heroes`, buf)
            FfiConverterSequenceString.write(value.`via`, buf)
    }
}



/**
 * When a room A is tombstoned, it is replaced by a room B. The room A is the
 * predecessor of B, and B is the successor of A. This type holds information
 * about the successor room. See [`Room::successor_room`].
 *
 * A room is tombstoned if it has received a [`m.room.tombstone`] state event.
 *
 * [`m.room.tombstone`]: https://spec.matrix.org/v1.14/client-server-api/#mroomtombstone
 */
data class SuccessorRoom (
    /**
     * The ID of the replacement room.
     */
    var `roomId`: kotlin.String, 
    /**
     * The message explaining why the room has been tombstoned.
     */
    var `reason`: kotlin.String?
) {
    
    companion object
}

public object FfiConverterTypeSuccessorRoom: FfiConverterRustBuffer<SuccessorRoom> {
    override fun read(buf: ByteBuffer): SuccessorRoom {
        return SuccessorRoom(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: SuccessorRoom) = (
            FfiConverterString.allocationSize(value.`roomId`) +
            FfiConverterOptionalString.allocationSize(value.`reason`)
    )

    override fun write(value: SuccessorRoom, buf: ByteBuffer) {
            FfiConverterString.write(value.`roomId`, buf)
            FfiConverterOptionalString.write(value.`reason`, buf)
    }
}



/**
 * Information about a tag.
 */
data class TagInfo (
    /**
     * Value to use for lexicographically ordering rooms with this tag.
     */
    var `order`: kotlin.Double?
) {
    
    companion object
}

public object FfiConverterTypeTagInfo: FfiConverterRustBuffer<TagInfo> {
    override fun read(buf: ByteBuffer): TagInfo {
        return TagInfo(
            FfiConverterOptionalDouble.read(buf),
        )
    }

    override fun allocationSize(value: TagInfo) = (
            FfiConverterOptionalDouble.allocationSize(value.`order`)
    )

    override fun write(value: TagInfo, buf: ByteBuffer) {
            FfiConverterOptionalDouble.write(value.`order`, buf)
    }
}



data class TextMessageContent (
    var `body`: kotlin.String, 
    var `formatted`: FormattedBody?
) {
    
    companion object
}

public object FfiConverterTypeTextMessageContent: FfiConverterRustBuffer<TextMessageContent> {
    override fun read(buf: ByteBuffer): TextMessageContent {
        return TextMessageContent(
            FfiConverterString.read(buf),
            FfiConverterOptionalTypeFormattedBody.read(buf),
        )
    }

    override fun allocationSize(value: TextMessageContent) = (
            FfiConverterString.allocationSize(value.`body`) +
            FfiConverterOptionalTypeFormattedBody.allocationSize(value.`formatted`)
    )

    override fun write(value: TextMessageContent, buf: ByteBuffer) {
            FfiConverterString.write(value.`body`, buf)
            FfiConverterOptionalTypeFormattedBody.write(value.`formatted`, buf)
    }
}



/**
 * A thread subscription (MSC4306).
 */
data class ThreadSubscription (
    /**
     * Whether the thread subscription happened automatically (e.g. after a
     * mention) or if it was manually requested by the user.
     */
    var `automatic`: kotlin.Boolean
) {
    
    companion object
}

public object FfiConverterTypeThreadSubscription: FfiConverterRustBuffer<ThreadSubscription> {
    override fun read(buf: ByteBuffer): ThreadSubscription {
        return ThreadSubscription(
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: ThreadSubscription) = (
            FfiConverterBoolean.allocationSize(value.`automatic`)
    )

    override fun write(value: ThreadSubscription, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`automatic`, buf)
    }
}



data class ThumbnailInfo (
    var `height`: kotlin.ULong?, 
    var `width`: kotlin.ULong?, 
    var `mimetype`: kotlin.String?, 
    var `size`: kotlin.ULong?
) {
    
    companion object
}

public object FfiConverterTypeThumbnailInfo: FfiConverterRustBuffer<ThumbnailInfo> {
    override fun read(buf: ByteBuffer): ThumbnailInfo {
        return ThumbnailInfo(
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalULong.read(buf),
        )
    }

    override fun allocationSize(value: ThumbnailInfo) = (
            FfiConverterOptionalULong.allocationSize(value.`height`) +
            FfiConverterOptionalULong.allocationSize(value.`width`) +
            FfiConverterOptionalString.allocationSize(value.`mimetype`) +
            FfiConverterOptionalULong.allocationSize(value.`size`)
    )

    override fun write(value: ThumbnailInfo, buf: ByteBuffer) {
            FfiConverterOptionalULong.write(value.`height`, buf)
            FfiConverterOptionalULong.write(value.`width`, buf)
            FfiConverterOptionalString.write(value.`mimetype`, buf)
            FfiConverterOptionalULong.write(value.`size`, buf)
    }
}



/**
 * Various options used to configure the timeline's behavior.
 */
data class TimelineConfiguration (
    /**
     * What should the timeline focus on?
     */
    var `focus`: TimelineFocus, 
    /**
     * How should we filter out events from the timeline?
     */
    var `filter`: TimelineFilter, 
    /**
     * An optional String that will be prepended to
     * all the timeline item's internal IDs, making it possible to
     * distinguish different timeline instances from each other.
     */
    var `internalIdPrefix`: kotlin.String?, 
    /**
     * How often to insert date dividers
     */
    var `dateDividerMode`: DateDividerMode, 
    /**
     * Should the read receipts and read markers be tracked for the timeline
     * items in this instance?
     *
     * As this has a non negligible performance impact, make sure to enable it
     * only when you need it.
     */
    var `trackReadReceipts`: kotlin.Boolean, 
    /**
     * Whether this timeline instance should report UTDs through the client's
     * delegate.
     */
    var `reportUtds`: kotlin.Boolean
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
        Disposable.destroy(this.`focus`)
    
        Disposable.destroy(this.`filter`)
    
        Disposable.destroy(this.`internalIdPrefix`)
    
        Disposable.destroy(this.`dateDividerMode`)
    
        Disposable.destroy(this.`trackReadReceipts`)
    
        Disposable.destroy(this.`reportUtds`)
    
    }
    
    companion object
}

public object FfiConverterTypeTimelineConfiguration: FfiConverterRustBuffer<TimelineConfiguration> {
    override fun read(buf: ByteBuffer): TimelineConfiguration {
        return TimelineConfiguration(
            FfiConverterTypeTimelineFocus.read(buf),
            FfiConverterTypeTimelineFilter.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterTypeDateDividerMode.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: TimelineConfiguration) = (
            FfiConverterTypeTimelineFocus.allocationSize(value.`focus`) +
            FfiConverterTypeTimelineFilter.allocationSize(value.`filter`) +
            FfiConverterOptionalString.allocationSize(value.`internalIdPrefix`) +
            FfiConverterTypeDateDividerMode.allocationSize(value.`dateDividerMode`) +
            FfiConverterBoolean.allocationSize(value.`trackReadReceipts`) +
            FfiConverterBoolean.allocationSize(value.`reportUtds`)
    )

    override fun write(value: TimelineConfiguration, buf: ByteBuffer) {
            FfiConverterTypeTimelineFocus.write(value.`focus`, buf)
            FfiConverterTypeTimelineFilter.write(value.`filter`, buf)
            FfiConverterOptionalString.write(value.`internalIdPrefix`, buf)
            FfiConverterTypeDateDividerMode.write(value.`dateDividerMode`, buf)
            FfiConverterBoolean.write(value.`trackReadReceipts`, buf)
            FfiConverterBoolean.write(value.`reportUtds`, buf)
    }
}



data class TimelineUniqueId (
    var `id`: kotlin.String
) {
    
    companion object
}

public object FfiConverterTypeTimelineUniqueId: FfiConverterRustBuffer<TimelineUniqueId> {
    override fun read(buf: ByteBuffer): TimelineUniqueId {
        return TimelineUniqueId(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: TimelineUniqueId) = (
            FfiConverterString.allocationSize(value.`id`)
    )

    override fun write(value: TimelineUniqueId, buf: ByteBuffer) {
            FfiConverterString.write(value.`id`, buf)
    }
}



data class TracingConfiguration (
    /**
     * The desired log level.
     */
    var `logLevel`: LogLevel, 
    /**
     * All the log packs, that will be set to `TRACE` when they're enabled.
     */
    var `traceLogPacks`: List<TraceLogPacks>, 
    /**
     * Additional targets that the FFI client would like to use.
     *
     * This can include, for instance, the target names for created
     * [`crate::tracing::Span`]. These targets will use the global log level by
     * default.
     */
    var `extraTargets`: List<kotlin.String>, 
    /**
     * Whether to log to stdout, or in the logcat on Android.
     */
    var `writeToStdoutOrSystem`: kotlin.Boolean, 
    /**
     * If set, configures rotated log files where to write additional logs.
     */
    var `writeToFiles`: TracingFileConfiguration?, 
    /**
     * If set, the Sentry DSN to use for error reporting.
     */
    var `sentryDsn`: kotlin.String?
) {
    
    companion object
}

public object FfiConverterTypeTracingConfiguration: FfiConverterRustBuffer<TracingConfiguration> {
    override fun read(buf: ByteBuffer): TracingConfiguration {
        return TracingConfiguration(
            FfiConverterTypeLogLevel.read(buf),
            FfiConverterSequenceTypeTraceLogPacks.read(buf),
            FfiConverterSequenceString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterOptionalTypeTracingFileConfiguration.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: TracingConfiguration) = (
            FfiConverterTypeLogLevel.allocationSize(value.`logLevel`) +
            FfiConverterSequenceTypeTraceLogPacks.allocationSize(value.`traceLogPacks`) +
            FfiConverterSequenceString.allocationSize(value.`extraTargets`) +
            FfiConverterBoolean.allocationSize(value.`writeToStdoutOrSystem`) +
            FfiConverterOptionalTypeTracingFileConfiguration.allocationSize(value.`writeToFiles`) +
            FfiConverterOptionalString.allocationSize(value.`sentryDsn`)
    )

    override fun write(value: TracingConfiguration, buf: ByteBuffer) {
            FfiConverterTypeLogLevel.write(value.`logLevel`, buf)
            FfiConverterSequenceTypeTraceLogPacks.write(value.`traceLogPacks`, buf)
            FfiConverterSequenceString.write(value.`extraTargets`, buf)
            FfiConverterBoolean.write(value.`writeToStdoutOrSystem`, buf)
            FfiConverterOptionalTypeTracingFileConfiguration.write(value.`writeToFiles`, buf)
            FfiConverterOptionalString.write(value.`sentryDsn`, buf)
    }
}



/**
 * Configuration to save logs to (rotated) log-files.
 */
data class TracingFileConfiguration (
    /**
     * Base location for all the log files.
     */
    var `path`: kotlin.String, 
    /**
     * Prefix for the log files' names.
     */
    var `filePrefix`: kotlin.String, 
    /**
     * Optional suffix for the log file's names.
     */
    var `fileSuffix`: kotlin.String?, 
    /**
     * Maximum number of rotated files.
     *
     * If not set, there's no max limit, i.e. the number of log files is
     * unlimited.
     */
    var `maxFiles`: kotlin.ULong?
) {
    
    companion object
}

public object FfiConverterTypeTracingFileConfiguration: FfiConverterRustBuffer<TracingFileConfiguration> {
    override fun read(buf: ByteBuffer): TracingFileConfiguration {
        return TracingFileConfiguration(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalULong.read(buf),
        )
    }

    override fun allocationSize(value: TracingFileConfiguration) = (
            FfiConverterString.allocationSize(value.`path`) +
            FfiConverterString.allocationSize(value.`filePrefix`) +
            FfiConverterOptionalString.allocationSize(value.`fileSuffix`) +
            FfiConverterOptionalULong.allocationSize(value.`maxFiles`)
    )

    override fun write(value: TracingFileConfiguration, buf: ByteBuffer) {
            FfiConverterString.write(value.`path`, buf)
            FfiConverterString.write(value.`filePrefix`, buf)
            FfiConverterOptionalString.write(value.`fileSuffix`, buf)
            FfiConverterOptionalULong.write(value.`maxFiles`, buf)
    }
}



data class TransmissionProgress (
    var `current`: kotlin.ULong, 
    var `total`: kotlin.ULong
) {
    
    companion object
}

public object FfiConverterTypeTransmissionProgress: FfiConverterRustBuffer<TransmissionProgress> {
    override fun read(buf: ByteBuffer): TransmissionProgress {
        return TransmissionProgress(
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: TransmissionProgress) = (
            FfiConverterULong.allocationSize(value.`current`) +
            FfiConverterULong.allocationSize(value.`total`)
    )

    override fun write(value: TransmissionProgress, buf: ByteBuffer) {
            FfiConverterULong.write(value.`current`, buf)
            FfiConverterULong.write(value.`total`, buf)
    }
}



data class UnableToDecryptInfo (
    /**
     * The identifier of the event that couldn't get decrypted.
     */
    var `eventId`: kotlin.String, 
    /**
     * If the event could be decrypted late (that is, the event was encrypted
     * at first, but could be decrypted later on), then this indicates the
     * time it took to decrypt the event. If it is not set, this is
     * considered a definite UTD.
     *
     * If set, this is in milliseconds.
     */
    var `timeToDecryptMs`: kotlin.ULong?, 
    /**
     * What we know about what caused this UTD. E.g. was this event sent when
     * we were not a member of this room?
     */
    var `cause`: UtdCause, 
    /**
     * The difference between the event creation time (`origin_server_ts`) and
     * the time our device was created. If negative, this event was sent
     * *before* our device was created.
     */
    var `eventLocalAgeMillis`: kotlin.Long, 
    /**
     * Whether the user had verified their own identity at the point they
     * received the UTD event.
     */
    var `userTrustsOwnIdentity`: kotlin.Boolean, 
    /**
     * The homeserver of the user that sent the undecryptable event.
     */
    var `senderHomeserver`: kotlin.String, 
    /**
     * Our local user's own homeserver, or `None` if the client is not logged
     * in.
     */
    var `ownHomeserver`: kotlin.String?
) {
    
    companion object
}

public object FfiConverterTypeUnableToDecryptInfo: FfiConverterRustBuffer<UnableToDecryptInfo> {
    override fun read(buf: ByteBuffer): UnableToDecryptInfo {
        return UnableToDecryptInfo(
            FfiConverterString.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterTypeUtdCause.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: UnableToDecryptInfo) = (
            FfiConverterString.allocationSize(value.`eventId`) +
            FfiConverterOptionalULong.allocationSize(value.`timeToDecryptMs`) +
            FfiConverterTypeUtdCause.allocationSize(value.`cause`) +
            FfiConverterLong.allocationSize(value.`eventLocalAgeMillis`) +
            FfiConverterBoolean.allocationSize(value.`userTrustsOwnIdentity`) +
            FfiConverterString.allocationSize(value.`senderHomeserver`) +
            FfiConverterOptionalString.allocationSize(value.`ownHomeserver`)
    )

    override fun write(value: UnableToDecryptInfo, buf: ByteBuffer) {
            FfiConverterString.write(value.`eventId`, buf)
            FfiConverterOptionalULong.write(value.`timeToDecryptMs`, buf)
            FfiConverterTypeUtdCause.write(value.`cause`, buf)
            FfiConverterLong.write(value.`eventLocalAgeMillis`, buf)
            FfiConverterBoolean.write(value.`userTrustsOwnIdentity`, buf)
            FfiConverterString.write(value.`senderHomeserver`, buf)
            FfiConverterOptionalString.write(value.`ownHomeserver`, buf)
    }
}



data class UnstableAudioDetailsContent (
    var `duration`: java.time.Duration, 
    var `waveform`: List<kotlin.UShort>
) {
    
    companion object
}

public object FfiConverterTypeUnstableAudioDetailsContent: FfiConverterRustBuffer<UnstableAudioDetailsContent> {
    override fun read(buf: ByteBuffer): UnstableAudioDetailsContent {
        return UnstableAudioDetailsContent(
            FfiConverterDuration.read(buf),
            FfiConverterSequenceUShort.read(buf),
        )
    }

    override fun allocationSize(value: UnstableAudioDetailsContent) = (
            FfiConverterDuration.allocationSize(value.`duration`) +
            FfiConverterSequenceUShort.allocationSize(value.`waveform`)
    )

    override fun write(value: UnstableAudioDetailsContent, buf: ByteBuffer) {
            FfiConverterDuration.write(value.`duration`, buf)
            FfiConverterSequenceUShort.write(value.`waveform`, buf)
    }
}



class UnstableVoiceContent {
    override fun equals(other: Any?): Boolean {
        return other is UnstableVoiceContent
    }

    override fun hashCode(): Int {
        return javaClass.hashCode()
    }

    companion object
}

public object FfiConverterTypeUnstableVoiceContent: FfiConverterRustBuffer<UnstableVoiceContent> {
    override fun read(buf: ByteBuffer): UnstableVoiceContent {
        return UnstableVoiceContent()
    }

    override fun allocationSize(value: UnstableVoiceContent) = 0UL

    override fun write(value: UnstableVoiceContent, buf: ByteBuffer) {
    }
}



data class UploadParameters (
    /**
     * Source from which to upload data
     */
    var `source`: UploadSource, 
    /**
     * Optional non-formatted caption, for clients that support it.
     */
    var `caption`: kotlin.String?, 
    /**
     * Optional HTML-formatted caption, for clients that support it.
     */
    var `formattedCaption`: FormattedBody?, 
    /**
     * Optional intentional mentions to be sent with the media.
     */
    var `mentions`: Mentions?, 
    /**
     * Optional Event ID to reply to.
     */
    var `inReplyTo`: kotlin.String?
) {
    
    companion object
}

public object FfiConverterTypeUploadParameters: FfiConverterRustBuffer<UploadParameters> {
    override fun read(buf: ByteBuffer): UploadParameters {
        return UploadParameters(
            FfiConverterTypeUploadSource.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalTypeFormattedBody.read(buf),
            FfiConverterOptionalTypeMentions.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: UploadParameters) = (
            FfiConverterTypeUploadSource.allocationSize(value.`source`) +
            FfiConverterOptionalString.allocationSize(value.`caption`) +
            FfiConverterOptionalTypeFormattedBody.allocationSize(value.`formattedCaption`) +
            FfiConverterOptionalTypeMentions.allocationSize(value.`mentions`) +
            FfiConverterOptionalString.allocationSize(value.`inReplyTo`)
    )

    override fun write(value: UploadParameters, buf: ByteBuffer) {
            FfiConverterTypeUploadSource.write(value.`source`, buf)
            FfiConverterOptionalString.write(value.`caption`, buf)
            FfiConverterOptionalTypeFormattedBody.write(value.`formattedCaption`, buf)
            FfiConverterOptionalTypeMentions.write(value.`mentions`, buf)
            FfiConverterOptionalString.write(value.`inReplyTo`, buf)
    }
}



/**
 * An update for a particular user's power level within the room.
 */
data class UserPowerLevelUpdate (
    /**
     * The user ID of the user to update.
     */
    var `userId`: kotlin.String, 
    /**
     * The power level to assign to the user.
     */
    var `powerLevel`: kotlin.Long
) {
    
    companion object
}

public object FfiConverterTypeUserPowerLevelUpdate: FfiConverterRustBuffer<UserPowerLevelUpdate> {
    override fun read(buf: ByteBuffer): UserPowerLevelUpdate {
        return UserPowerLevelUpdate(
            FfiConverterString.read(buf),
            FfiConverterLong.read(buf),
        )
    }

    override fun allocationSize(value: UserPowerLevelUpdate) = (
            FfiConverterString.allocationSize(value.`userId`) +
            FfiConverterLong.allocationSize(value.`powerLevel`)
    )

    override fun write(value: UserPowerLevelUpdate, buf: ByteBuffer) {
            FfiConverterString.write(value.`userId`, buf)
            FfiConverterLong.write(value.`powerLevel`, buf)
    }
}



data class UserProfile (
    var `userId`: kotlin.String, 
    var `displayName`: kotlin.String?, 
    var `avatarUrl`: kotlin.String?
) {
    
    companion object
}

public object FfiConverterTypeUserProfile: FfiConverterRustBuffer<UserProfile> {
    override fun read(buf: ByteBuffer): UserProfile {
        return UserProfile(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: UserProfile) = (
            FfiConverterString.allocationSize(value.`userId`) +
            FfiConverterOptionalString.allocationSize(value.`displayName`) +
            FfiConverterOptionalString.allocationSize(value.`avatarUrl`)
    )

    override fun write(value: UserProfile, buf: ByteBuffer) {
            FfiConverterString.write(value.`userId`, buf)
            FfiConverterOptionalString.write(value.`displayName`, buf)
            FfiConverterOptionalString.write(value.`avatarUrl`, buf)
    }
}



/**
 * A user-defined tag name.
 */
data class UserTagName (
    var `name`: kotlin.String
) {
    
    companion object
}

public object FfiConverterTypeUserTagName: FfiConverterRustBuffer<UserTagName> {
    override fun read(buf: ByteBuffer): UserTagName {
        return UserTagName(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: UserTagName) = (
            FfiConverterString.allocationSize(value.`name`)
    )

    override fun write(value: UserTagName, buf: ByteBuffer) {
            FfiConverterString.write(value.`name`, buf)
    }
}



data class VideoInfo (
    var `duration`: java.time.Duration?, 
    var `height`: kotlin.ULong?, 
    var `width`: kotlin.ULong?, 
    var `mimetype`: kotlin.String?, 
    var `size`: kotlin.ULong?, 
    var `thumbnailInfo`: ThumbnailInfo?, 
    var `thumbnailSource`: MediaSource?, 
    var `blurhash`: kotlin.String?
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
        Disposable.destroy(this.`duration`)
    
        Disposable.destroy(this.`height`)
    
        Disposable.destroy(this.`width`)
    
        Disposable.destroy(this.`mimetype`)
    
        Disposable.destroy(this.`size`)
    
        Disposable.destroy(this.`thumbnailInfo`)
    
        Disposable.destroy(this.`thumbnailSource`)
    
        Disposable.destroy(this.`blurhash`)
    
    }
    
    companion object
}

public object FfiConverterTypeVideoInfo: FfiConverterRustBuffer<VideoInfo> {
    override fun read(buf: ByteBuffer): VideoInfo {
        return VideoInfo(
            FfiConverterOptionalDuration.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterOptionalTypeThumbnailInfo.read(buf),
            FfiConverterOptionalTypeMediaSource.read(buf),
            FfiConverterOptionalString.read(buf),
        )
    }

    override fun allocationSize(value: VideoInfo) = (
            FfiConverterOptionalDuration.allocationSize(value.`duration`) +
            FfiConverterOptionalULong.allocationSize(value.`height`) +
            FfiConverterOptionalULong.allocationSize(value.`width`) +
            FfiConverterOptionalString.allocationSize(value.`mimetype`) +
            FfiConverterOptionalULong.allocationSize(value.`size`) +
            FfiConverterOptionalTypeThumbnailInfo.allocationSize(value.`thumbnailInfo`) +
            FfiConverterOptionalTypeMediaSource.allocationSize(value.`thumbnailSource`) +
            FfiConverterOptionalString.allocationSize(value.`blurhash`)
    )

    override fun write(value: VideoInfo, buf: ByteBuffer) {
            FfiConverterOptionalDuration.write(value.`duration`, buf)
            FfiConverterOptionalULong.write(value.`height`, buf)
            FfiConverterOptionalULong.write(value.`width`, buf)
            FfiConverterOptionalString.write(value.`mimetype`, buf)
            FfiConverterOptionalULong.write(value.`size`, buf)
            FfiConverterOptionalTypeThumbnailInfo.write(value.`thumbnailInfo`, buf)
            FfiConverterOptionalTypeMediaSource.write(value.`thumbnailSource`, buf)
            FfiConverterOptionalString.write(value.`blurhash`, buf)
    }
}



data class VideoMessageContent (
    /**
     * The computed filename, for use in a client.
     */
    var `filename`: kotlin.String, 
    var `caption`: kotlin.String?, 
    var `formattedCaption`: FormattedBody?, 
    var `source`: MediaSource, 
    var `info`: VideoInfo?
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
        Disposable.destroy(this.`filename`)
    
        Disposable.destroy(this.`caption`)
    
        Disposable.destroy(this.`formattedCaption`)
    
        Disposable.destroy(this.`source`)
    
        Disposable.destroy(this.`info`)
    
    }
    
    companion object
}

public object FfiConverterTypeVideoMessageContent: FfiConverterRustBuffer<VideoMessageContent> {
    override fun read(buf: ByteBuffer): VideoMessageContent {
        return VideoMessageContent(
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalTypeFormattedBody.read(buf),
            FfiConverterTypeMediaSource.read(buf),
            FfiConverterOptionalTypeVideoInfo.read(buf),
        )
    }

    override fun allocationSize(value: VideoMessageContent) = (
            FfiConverterString.allocationSize(value.`filename`) +
            FfiConverterOptionalString.allocationSize(value.`caption`) +
            FfiConverterOptionalTypeFormattedBody.allocationSize(value.`formattedCaption`) +
            FfiConverterTypeMediaSource.allocationSize(value.`source`) +
            FfiConverterOptionalTypeVideoInfo.allocationSize(value.`info`)
    )

    override fun write(value: VideoMessageContent, buf: ByteBuffer) {
            FfiConverterString.write(value.`filename`, buf)
            FfiConverterOptionalString.write(value.`caption`, buf)
            FfiConverterOptionalTypeFormattedBody.write(value.`formattedCaption`, buf)
            FfiConverterTypeMediaSource.write(value.`source`, buf)
            FfiConverterOptionalTypeVideoInfo.write(value.`info`, buf)
    }
}



/**
 * Capabilities that a widget can request from a client.
 */
data class WidgetCapabilities (
    /**
     * Types of the messages that a widget wants to be able to fetch.
     */
    var `read`: List<WidgetEventFilter>, 
    /**
     * Types of the messages that a widget wants to be able to send.
     */
    var `send`: List<WidgetEventFilter>, 
    /**
     * If this capability is requested by the widget, it can not operate
     * separately from the Matrix client.
     *
     * This means clients should not offer to open the widget in a separate
     * browser/tab/webview that is not connected to the postmessage widget-api.
     */
    var `requiresClient`: kotlin.Boolean, 
    /**
     * This allows the widget to ask the client to update delayed events.
     */
    var `updateDelayedEvent`: kotlin.Boolean, 
    /**
     * This allows the widget to send events with a delay.
     */
    var `sendDelayedEvent`: kotlin.Boolean
) {
    
    companion object
}

public object FfiConverterTypeWidgetCapabilities: FfiConverterRustBuffer<WidgetCapabilities> {
    override fun read(buf: ByteBuffer): WidgetCapabilities {
        return WidgetCapabilities(
            FfiConverterSequenceTypeWidgetEventFilter.read(buf),
            FfiConverterSequenceTypeWidgetEventFilter.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: WidgetCapabilities) = (
            FfiConverterSequenceTypeWidgetEventFilter.allocationSize(value.`read`) +
            FfiConverterSequenceTypeWidgetEventFilter.allocationSize(value.`send`) +
            FfiConverterBoolean.allocationSize(value.`requiresClient`) +
            FfiConverterBoolean.allocationSize(value.`updateDelayedEvent`) +
            FfiConverterBoolean.allocationSize(value.`sendDelayedEvent`)
    )

    override fun write(value: WidgetCapabilities, buf: ByteBuffer) {
            FfiConverterSequenceTypeWidgetEventFilter.write(value.`read`, buf)
            FfiConverterSequenceTypeWidgetEventFilter.write(value.`send`, buf)
            FfiConverterBoolean.write(value.`requiresClient`, buf)
            FfiConverterBoolean.write(value.`updateDelayedEvent`, buf)
            FfiConverterBoolean.write(value.`sendDelayedEvent`, buf)
    }
}



data class WidgetDriverAndHandle (
    var `driver`: WidgetDriver, 
    var `handle`: WidgetDriverHandle
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
        Disposable.destroy(this.`driver`)
    
        Disposable.destroy(this.`handle`)
    
    }
    
    companion object
}

public object FfiConverterTypeWidgetDriverAndHandle: FfiConverterRustBuffer<WidgetDriverAndHandle> {
    override fun read(buf: ByteBuffer): WidgetDriverAndHandle {
        return WidgetDriverAndHandle(
            FfiConverterTypeWidgetDriver.read(buf),
            FfiConverterTypeWidgetDriverHandle.read(buf),
        )
    }

    override fun allocationSize(value: WidgetDriverAndHandle) = (
            FfiConverterTypeWidgetDriver.allocationSize(value.`driver`) +
            FfiConverterTypeWidgetDriverHandle.allocationSize(value.`handle`)
    )

    override fun write(value: WidgetDriverAndHandle, buf: ByteBuffer) {
            FfiConverterTypeWidgetDriver.write(value.`driver`, buf)
            FfiConverterTypeWidgetDriverHandle.write(value.`handle`, buf)
    }
}



/**
 * Information about a widget.
 */
data class WidgetSettings (
    /**
     * Widget's unique identifier.
     */
    var `widgetId`: kotlin.String, 
    /**
     * Whether or not the widget should be initialized on load message
     * (`ContentLoad` message), or upon creation/attaching of the widget to
     * the SDK's state machine that drives the API.
     */
    var `initAfterContentLoad`: kotlin.Boolean, 
    /**
     * This contains the url from the widget state event.
     * In this url placeholders can be used to pass information from the client
     * to the widget. Possible values are: `$widgetId`, `$parentUrl`,
     * `$userId`, `$lang`, `$fontScale`, `$analyticsID`.
     *
     * # Examples
     *
     * e.g `http://widget.domain?username=$userId`
     * will become: `http://widget.domain?username=@user_matrix_id:server.domain`.
     */
    var `rawUrl`: kotlin.String
) {
    
    companion object
}

public object FfiConverterTypeWidgetSettings: FfiConverterRustBuffer<WidgetSettings> {
    override fun read(buf: ByteBuffer): WidgetSettings {
        return WidgetSettings(
            FfiConverterString.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: WidgetSettings) = (
            FfiConverterString.allocationSize(value.`widgetId`) +
            FfiConverterBoolean.allocationSize(value.`initAfterContentLoad`) +
            FfiConverterString.allocationSize(value.`rawUrl`)
    )

    override fun write(value: WidgetSettings, buf: ByteBuffer) {
            FfiConverterString.write(value.`widgetId`, buf)
            FfiConverterBoolean.write(value.`initAfterContentLoad`, buf)
            FfiConverterString.write(value.`rawUrl`, buf)
    }
}



/**
 * Global account data events.
 */
sealed class AccountDataEvent {
    
    /**
     * m.direct
     */
    data class Direct(
        /**
         * The mapping of user ID to a list of room IDs of the direct rooms
         * for that user ID.
         */
        val `map`: Map<kotlin.String, List<kotlin.String>>) : AccountDataEvent() {
        companion object
    }
    
    /**
     * m.identity_server
     */
    data class IdentityServer(
        /**
         * The base URL for the identity server for client-server connections.
         */
        val `baseUrl`: kotlin.String?) : AccountDataEvent() {
        companion object
    }
    
    /**
     * m.ignored_user_list
     */
    data class IgnoredUserList(
        /**
         * The map of users to ignore. This is a mapping of user ID to empty
         * object.
         */
        val `ignoredUsers`: Map<kotlin.String, IgnoredUser>) : AccountDataEvent() {
        companion object
    }
    
    /**
     * m.push_rules
     */
    data class PushRules(
        /**
         * The global ruleset.
         */
        val `global`: Ruleset) : AccountDataEvent() {
        companion object
    }
    
    /**
     * m.secret_storage.default_key
     */
    data class SecretStorageDefaultKey(
        /**
         * The ID of the default key.
         */
        val `keyId`: kotlin.String) : AccountDataEvent() {
        companion object
    }
    
    /**
     * m.secret_storage.key.*
     */
    data class SecretStorageKey(
        /**
         * The ID of the key.
         */
        val `keyId`: kotlin.String, 
        /**
         * The name of the key.
         */
        val `name`: kotlin.String?, 
        /**
         * The encryption algorithm used for this key.
         *
         * Currently, only `m.secret_storage.v1.aes-hmac-sha2` is supported.
         */
        val `algorithm`: SecretStorageEncryptionAlgorithm, 
        /**
         * The passphrase from which to generate the key.
         */
        val `passphrase`: PassPhrase?) : AccountDataEvent() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeAccountDataEvent : FfiConverterRustBuffer<AccountDataEvent>{
    override fun read(buf: ByteBuffer): AccountDataEvent {
        return when(buf.getInt()) {
            1 -> AccountDataEvent.Direct(
                FfiConverterMapStringSequenceString.read(buf),
                )
            2 -> AccountDataEvent.IdentityServer(
                FfiConverterOptionalString.read(buf),
                )
            3 -> AccountDataEvent.IgnoredUserList(
                FfiConverterMapStringTypeIgnoredUser.read(buf),
                )
            4 -> AccountDataEvent.PushRules(
                FfiConverterTypeRuleset.read(buf),
                )
            5 -> AccountDataEvent.SecretStorageDefaultKey(
                FfiConverterString.read(buf),
                )
            6 -> AccountDataEvent.SecretStorageKey(
                FfiConverterString.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterTypeSecretStorageEncryptionAlgorithm.read(buf),
                FfiConverterOptionalTypePassPhrase.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AccountDataEvent) = when(value) {
        is AccountDataEvent.Direct -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterMapStringSequenceString.allocationSize(value.`map`)
            )
        }
        is AccountDataEvent.IdentityServer -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalString.allocationSize(value.`baseUrl`)
            )
        }
        is AccountDataEvent.IgnoredUserList -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterMapStringTypeIgnoredUser.allocationSize(value.`ignoredUsers`)
            )
        }
        is AccountDataEvent.PushRules -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeRuleset.allocationSize(value.`global`)
            )
        }
        is AccountDataEvent.SecretStorageDefaultKey -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`keyId`)
            )
        }
        is AccountDataEvent.SecretStorageKey -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`keyId`)
                + FfiConverterOptionalString.allocationSize(value.`name`)
                + FfiConverterTypeSecretStorageEncryptionAlgorithm.allocationSize(value.`algorithm`)
                + FfiConverterOptionalTypePassPhrase.allocationSize(value.`passphrase`)
            )
        }
    }

    override fun write(value: AccountDataEvent, buf: ByteBuffer) {
        when(value) {
            is AccountDataEvent.Direct -> {
                buf.putInt(1)
                FfiConverterMapStringSequenceString.write(value.`map`, buf)
                Unit
            }
            is AccountDataEvent.IdentityServer -> {
                buf.putInt(2)
                FfiConverterOptionalString.write(value.`baseUrl`, buf)
                Unit
            }
            is AccountDataEvent.IgnoredUserList -> {
                buf.putInt(3)
                FfiConverterMapStringTypeIgnoredUser.write(value.`ignoredUsers`, buf)
                Unit
            }
            is AccountDataEvent.PushRules -> {
                buf.putInt(4)
                FfiConverterTypeRuleset.write(value.`global`, buf)
                Unit
            }
            is AccountDataEvent.SecretStorageDefaultKey -> {
                buf.putInt(5)
                FfiConverterString.write(value.`keyId`, buf)
                Unit
            }
            is AccountDataEvent.SecretStorageKey -> {
                buf.putInt(6)
                FfiConverterString.write(value.`keyId`, buf)
                FfiConverterOptionalString.write(value.`name`, buf)
                FfiConverterTypeSecretStorageEncryptionAlgorithm.write(value.`algorithm`, buf)
                FfiConverterOptionalTypePassPhrase.write(value.`passphrase`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Types of global account data events.
 */
sealed class AccountDataEventType {
    
    /**
     * m.direct
     */
    object Direct : AccountDataEventType()
    
    
    /**
     * m.identity_server
     */
    object IdentityServer : AccountDataEventType()
    
    
    /**
     * m.ignored_user_list
     */
    object IgnoredUserList : AccountDataEventType()
    
    
    /**
     * m.push_rules
     */
    object PushRules : AccountDataEventType()
    
    
    /**
     * m.secret_storage.default_key
     */
    object SecretStorageDefaultKey : AccountDataEventType()
    
    
    /**
     * m.secret_storage.key.*
     */
    data class SecretStorageKey(
        val `keyId`: kotlin.String) : AccountDataEventType() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeAccountDataEventType : FfiConverterRustBuffer<AccountDataEventType>{
    override fun read(buf: ByteBuffer): AccountDataEventType {
        return when(buf.getInt()) {
            1 -> AccountDataEventType.Direct
            2 -> AccountDataEventType.IdentityServer
            3 -> AccountDataEventType.IgnoredUserList
            4 -> AccountDataEventType.PushRules
            5 -> AccountDataEventType.SecretStorageDefaultKey
            6 -> AccountDataEventType.SecretStorageKey(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AccountDataEventType) = when(value) {
        is AccountDataEventType.Direct -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AccountDataEventType.IdentityServer -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AccountDataEventType.IgnoredUserList -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AccountDataEventType.PushRules -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AccountDataEventType.SecretStorageDefaultKey -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AccountDataEventType.SecretStorageKey -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`keyId`)
            )
        }
    }

    override fun write(value: AccountDataEventType, buf: ByteBuffer) {
        when(value) {
            is AccountDataEventType.Direct -> {
                buf.putInt(1)
                Unit
            }
            is AccountDataEventType.IdentityServer -> {
                buf.putInt(2)
                Unit
            }
            is AccountDataEventType.IgnoredUserList -> {
                buf.putInt(3)
                Unit
            }
            is AccountDataEventType.PushRules -> {
                buf.putInt(4)
                Unit
            }
            is AccountDataEventType.SecretStorageDefaultKey -> {
                buf.putInt(5)
                Unit
            }
            is AccountDataEventType.SecretStorageKey -> {
                buf.putInt(6)
                FfiConverterString.write(value.`keyId`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class AccountManagementAction {
    
    object Profile : AccountManagementAction()
    
    
    object SessionsList : AccountManagementAction()
    
    
    data class SessionView(
        val `deviceId`: kotlin.String) : AccountManagementAction() {
        companion object
    }
    
    data class SessionEnd(
        val `deviceId`: kotlin.String) : AccountManagementAction() {
        companion object
    }
    
    object AccountDeactivate : AccountManagementAction()
    
    
    object CrossSigningReset : AccountManagementAction()
    
    

    
    companion object
}

public object FfiConverterTypeAccountManagementAction : FfiConverterRustBuffer<AccountManagementAction>{
    override fun read(buf: ByteBuffer): AccountManagementAction {
        return when(buf.getInt()) {
            1 -> AccountManagementAction.Profile
            2 -> AccountManagementAction.SessionsList
            3 -> AccountManagementAction.SessionView(
                FfiConverterString.read(buf),
                )
            4 -> AccountManagementAction.SessionEnd(
                FfiConverterString.read(buf),
                )
            5 -> AccountManagementAction.AccountDeactivate
            6 -> AccountManagementAction.CrossSigningReset
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AccountManagementAction) = when(value) {
        is AccountManagementAction.Profile -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AccountManagementAction.SessionsList -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AccountManagementAction.SessionView -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`deviceId`)
            )
        }
        is AccountManagementAction.SessionEnd -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`deviceId`)
            )
        }
        is AccountManagementAction.AccountDeactivate -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AccountManagementAction.CrossSigningReset -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: AccountManagementAction, buf: ByteBuffer) {
        when(value) {
            is AccountManagementAction.Profile -> {
                buf.putInt(1)
                Unit
            }
            is AccountManagementAction.SessionsList -> {
                buf.putInt(2)
                Unit
            }
            is AccountManagementAction.SessionView -> {
                buf.putInt(3)
                FfiConverterString.write(value.`deviceId`, buf)
                Unit
            }
            is AccountManagementAction.SessionEnd -> {
                buf.putInt(4)
                FfiConverterString.write(value.`deviceId`, buf)
                Unit
            }
            is AccountManagementAction.AccountDeactivate -> {
                buf.putInt(5)
                Unit
            }
            is AccountManagementAction.CrossSigningReset -> {
                buf.putInt(6)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Enum representing the push notification actions for a rule.
 */
sealed class Action {
    
    /**
     * Causes matching events to generate a notification.
     */
    object Notify : Action()
    
    
    /**
     * Sets an entry in the 'tweaks' dictionary sent to the push gateway.
     */
    data class SetTweak(
        val `value`: Tweak) : Action() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeAction : FfiConverterRustBuffer<Action>{
    override fun read(buf: ByteBuffer): Action {
        return when(buf.getInt()) {
            1 -> Action.Notify
            2 -> Action.SetTweak(
                FfiConverterTypeTweak.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: Action) = when(value) {
        is Action.Notify -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is Action.SetTweak -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTweak.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: Action, buf: ByteBuffer) {
        when(value) {
            is Action.Notify -> {
                buf.putInt(1)
                Unit
            }
            is Action.SetTweak -> {
                buf.putInt(2)
                FfiConverterTypeTweak.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * An allow rule which defines a condition that allows joining a room.
 */
sealed class AllowRule {
    
    /**
     * Only a member of the `room_id` Room can join the one this rule is used
     * in.
     */
    data class RoomMembership(
        val `roomId`: kotlin.String) : AllowRule() {
        companion object
    }
    
    /**
     * A custom allow rule implementation, containing its JSON representation
     * as a `String`.
     */
    data class Custom(
        val `json`: kotlin.String) : AllowRule() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeAllowRule : FfiConverterRustBuffer<AllowRule>{
    override fun read(buf: ByteBuffer): AllowRule {
        return when(buf.getInt()) {
            1 -> AllowRule.RoomMembership(
                FfiConverterString.read(buf),
                )
            2 -> AllowRule.Custom(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AllowRule) = when(value) {
        is AllowRule.RoomMembership -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`roomId`)
            )
        }
        is AllowRule.Custom -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`json`)
            )
        }
    }

    override fun write(value: AllowRule, buf: ByteBuffer) {
        when(value) {
            is AllowRule.RoomMembership -> {
                buf.putInt(1)
                FfiConverterString.write(value.`roomId`, buf)
                Unit
            }
            is AllowRule.Custom -> {
                buf.putInt(2)
                FfiConverterString.write(value.`json`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class AssetType {
    
    SENDER,
    PIN;
    companion object
}


public object FfiConverterTypeAssetType: FfiConverterRustBuffer<AssetType> {
    override fun read(buf: ByteBuffer) = try {
        AssetType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: AssetType) = 4UL

    override fun write(value: AssetType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class AuthData {
    
    /**
     * Password-based authentication (`m.login.password`).
     */
    data class Password(
        val `passwordDetails`: AuthDataPasswordDetails) : AuthData() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeAuthData : FfiConverterRustBuffer<AuthData>{
    override fun read(buf: ByteBuffer): AuthData {
        return when(buf.getInt()) {
            1 -> AuthData.Password(
                FfiConverterTypeAuthDataPasswordDetails.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AuthData) = when(value) {
        is AuthData.Password -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAuthDataPasswordDetails.allocationSize(value.`passwordDetails`)
            )
        }
    }

    override fun write(value: AuthData, buf: ByteBuffer) {
        when(value) {
            is AuthData.Password -> {
                buf.putInt(1)
                FfiConverterTypeAuthDataPasswordDetails.write(value.`passwordDetails`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class BackupState {
    
    UNKNOWN,
    CREATING,
    ENABLING,
    RESUMING,
    ENABLED,
    DOWNLOADING,
    DISABLING;
    companion object
}


public object FfiConverterTypeBackupState: FfiConverterRustBuffer<BackupState> {
    override fun read(buf: ByteBuffer) = try {
        BackupState.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: BackupState) = 4UL

    override fun write(value: BackupState, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class BackupUploadState {
    
    object Waiting : BackupUploadState()
    
    
    data class Uploading(
        val `backedUpCount`: kotlin.UInt, 
        val `totalCount`: kotlin.UInt) : BackupUploadState() {
        companion object
    }
    
    object Error : BackupUploadState()
    
    
    object Done : BackupUploadState()
    
    

    
    companion object
}

public object FfiConverterTypeBackupUploadState : FfiConverterRustBuffer<BackupUploadState>{
    override fun read(buf: ByteBuffer): BackupUploadState {
        return when(buf.getInt()) {
            1 -> BackupUploadState.Waiting
            2 -> BackupUploadState.Uploading(
                FfiConverterUInt.read(buf),
                FfiConverterUInt.read(buf),
                )
            3 -> BackupUploadState.Error
            4 -> BackupUploadState.Done
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: BackupUploadState) = when(value) {
        is BackupUploadState.Waiting -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is BackupUploadState.Uploading -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUInt.allocationSize(value.`backedUpCount`)
                + FfiConverterUInt.allocationSize(value.`totalCount`)
            )
        }
        is BackupUploadState.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is BackupUploadState.Done -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: BackupUploadState, buf: ByteBuffer) {
        when(value) {
            is BackupUploadState.Waiting -> {
                buf.putInt(1)
                Unit
            }
            is BackupUploadState.Uploading -> {
                buf.putInt(2)
                FfiConverterUInt.write(value.`backedUpCount`, buf)
                FfiConverterUInt.write(value.`totalCount`, buf)
                Unit
            }
            is BackupUploadState.Error -> {
                buf.putInt(3)
                Unit
            }
            is BackupUploadState.Done -> {
                buf.putInt(4)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class BatchNotificationResult: Disposable  {
    
    /**
     * We have more detailed information about the notification.
     */
    data class Ok(
        val `status`: NotificationStatus) : BatchNotificationResult() {
        companion object
    }
    
    /**
     * An error occurred while trying to fetch the notification.
     */
    data class Error(
        /**
         * The error message observed while handling a specific notification.
         */
        val `message`: kotlin.String) : BatchNotificationResult() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is BatchNotificationResult.Ok -> {
                
        Disposable.destroy(this.`status`)
    
                
            }
            is BatchNotificationResult.Error -> {
                
        Disposable.destroy(this.`message`)
    
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

public object FfiConverterTypeBatchNotificationResult : FfiConverterRustBuffer<BatchNotificationResult>{
    override fun read(buf: ByteBuffer): BatchNotificationResult {
        return when(buf.getInt()) {
            1 -> BatchNotificationResult.Ok(
                FfiConverterTypeNotificationStatus.read(buf),
                )
            2 -> BatchNotificationResult.Error(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: BatchNotificationResult) = when(value) {
        is BatchNotificationResult.Ok -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeNotificationStatus.allocationSize(value.`status`)
            )
        }
        is BatchNotificationResult.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`message`)
            )
        }
    }

    override fun write(value: BatchNotificationResult, buf: ByteBuffer) {
        when(value) {
            is BatchNotificationResult.Ok -> {
                buf.putInt(1)
                FfiConverterTypeNotificationStatus.write(value.`status`, buf)
                Unit
            }
            is BatchNotificationResult.Error -> {
                buf.putInt(2)
                FfiConverterString.write(value.`message`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class ClientBuildException(message: String): kotlin.Exception(message) {
        
        class InvalidServerName(message: String) : ClientBuildException(message)
        
        class ServerUnreachable(message: String) : ClientBuildException(message)
        
        class WellKnownLookupFailed(message: String) : ClientBuildException(message)
        
        class WellKnownDeserializationException(message: String) : ClientBuildException(message)
        
        class SlidingSync(message: String) : ClientBuildException(message)
        
        class SlidingSyncVersion(message: String) : ClientBuildException(message)
        
        class Sdk(message: String) : ClientBuildException(message)
        
        class EventCache(message: String) : ClientBuildException(message)
        
        class Generic(message: String) : ClientBuildException(message)
        

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<ClientBuildException> {
        override fun lift(error_buf: RustBuffer.ByValue): ClientBuildException = FfiConverterTypeClientBuildError.lift(error_buf)
    }
}

public object FfiConverterTypeClientBuildError : FfiConverterRustBuffer<ClientBuildException> {
    override fun read(buf: ByteBuffer): ClientBuildException {
        
            return when(buf.getInt()) {
            1 -> ClientBuildException.InvalidServerName(FfiConverterString.read(buf))
            2 -> ClientBuildException.ServerUnreachable(FfiConverterString.read(buf))
            3 -> ClientBuildException.WellKnownLookupFailed(FfiConverterString.read(buf))
            4 -> ClientBuildException.WellKnownDeserializationException(FfiConverterString.read(buf))
            5 -> ClientBuildException.SlidingSync(FfiConverterString.read(buf))
            6 -> ClientBuildException.SlidingSyncVersion(FfiConverterString.read(buf))
            7 -> ClientBuildException.Sdk(FfiConverterString.read(buf))
            8 -> ClientBuildException.EventCache(FfiConverterString.read(buf))
            9 -> ClientBuildException.Generic(FfiConverterString.read(buf))
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
        
    }

    override fun allocationSize(value: ClientBuildException): ULong {
        return 4UL
    }

    override fun write(value: ClientBuildException, buf: ByteBuffer) {
        when(value) {
            is ClientBuildException.InvalidServerName -> {
                buf.putInt(1)
                Unit
            }
            is ClientBuildException.ServerUnreachable -> {
                buf.putInt(2)
                Unit
            }
            is ClientBuildException.WellKnownLookupFailed -> {
                buf.putInt(3)
                Unit
            }
            is ClientBuildException.WellKnownDeserializationException -> {
                buf.putInt(4)
                Unit
            }
            is ClientBuildException.SlidingSync -> {
                buf.putInt(5)
                Unit
            }
            is ClientBuildException.SlidingSyncVersion -> {
                buf.putInt(6)
                Unit
            }
            is ClientBuildException.Sdk -> {
                buf.putInt(7)
                Unit
            }
            is ClientBuildException.EventCache -> {
                buf.putInt(8)
                Unit
            }
            is ClientBuildException.Generic -> {
                buf.putInt(9)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class ClientException: kotlin.Exception() {
    
    class Generic(
        
        val `msg`: kotlin.String, 
        
        val `details`: kotlin.String?
        ) : ClientException() {
        override val message
            get() = "msg=${ `msg` }, details=${ `details` }"
    }
    
    class MatrixApi(
        
        val `kind`: ErrorKind, 
        
        val `code`: kotlin.String, 
        
        val `msg`: kotlin.String, 
        
        val `details`: kotlin.String?
        ) : ClientException() {
        override val message
            get() = "kind=${ `kind` }, code=${ `code` }, msg=${ `msg` }, details=${ `details` }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<ClientException> {
        override fun lift(error_buf: RustBuffer.ByValue): ClientException = FfiConverterTypeClientError.lift(error_buf)
    }

    
}

public object FfiConverterTypeClientError : FfiConverterRustBuffer<ClientException> {
    override fun read(buf: ByteBuffer): ClientException {
        

        return when(buf.getInt()) {
            1 -> ClientException.Generic(
                FfiConverterString.read(buf),
                FfiConverterOptionalString.read(buf),
                )
            2 -> ClientException.MatrixApi(
                FfiConverterTypeErrorKind.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterOptionalString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ClientException): ULong {
        return when(value) {
            is ClientException.Generic -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`msg`)
                + FfiConverterOptionalString.allocationSize(value.`details`)
            )
            is ClientException.MatrixApi -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeErrorKind.allocationSize(value.`kind`)
                + FfiConverterString.allocationSize(value.`code`)
                + FfiConverterString.allocationSize(value.`msg`)
                + FfiConverterOptionalString.allocationSize(value.`details`)
            )
        }
    }

    override fun write(value: ClientException, buf: ByteBuffer) {
        when(value) {
            is ClientException.Generic -> {
                buf.putInt(1)
                FfiConverterString.write(value.`msg`, buf)
                FfiConverterOptionalString.write(value.`details`, buf)
                Unit
            }
            is ClientException.MatrixApi -> {
                buf.putInt(2)
                FfiConverterTypeErrorKind.write(value.`kind`, buf)
                FfiConverterString.write(value.`code`, buf)
                FfiConverterString.write(value.`msg`, buf)
                FfiConverterOptionalString.write(value.`details`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




enum class ComparisonOperator {
    
    /**
     * Equals
     */
    EQ,
    /**
     * Less than
     */
    LT,
    /**
     * Greater than
     */
    GT,
    /**
     * Greater or equal
     */
    GE,
    /**
     * Less or equal
     */
    LE;
    companion object
}


public object FfiConverterTypeComparisonOperator: FfiConverterRustBuffer<ComparisonOperator> {
    override fun read(buf: ByteBuffer) = try {
        ComparisonOperator.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ComparisonOperator) = 4UL

    override fun write(value: ComparisonOperator, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * The type of draft of the composer.
 */
sealed class ComposerDraftType {
    
    /**
     * The draft is a new message.
     */
    object NewMessage : ComposerDraftType()
    
    
    /**
     * The draft is a reply to an event.
     */
    data class Reply(
        /**
         * The ID of the event being replied to.
         */
        val `eventId`: kotlin.String) : ComposerDraftType() {
        companion object
    }
    
    /**
     * The draft is an edit of an event.
     */
    data class Edit(
        /**
         * The ID of the event being edited.
         */
        val `eventId`: kotlin.String) : ComposerDraftType() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeComposerDraftType : FfiConverterRustBuffer<ComposerDraftType>{
    override fun read(buf: ByteBuffer): ComposerDraftType {
        return when(buf.getInt()) {
            1 -> ComposerDraftType.NewMessage
            2 -> ComposerDraftType.Reply(
                FfiConverterString.read(buf),
                )
            3 -> ComposerDraftType.Edit(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ComposerDraftType) = when(value) {
        is ComposerDraftType.NewMessage -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ComposerDraftType.Reply -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`eventId`)
            )
        }
        is ComposerDraftType.Edit -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`eventId`)
            )
        }
    }

    override fun write(value: ComposerDraftType, buf: ByteBuffer) {
        when(value) {
            is ComposerDraftType.NewMessage -> {
                buf.putInt(1)
                Unit
            }
            is ComposerDraftType.Reply -> {
                buf.putInt(2)
                FfiConverterString.write(value.`eventId`, buf)
                Unit
            }
            is ComposerDraftType.Edit -> {
                buf.putInt(3)
                FfiConverterString.write(value.`eventId`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class CrossSigningResetAuthType {
    
    /**
     * The homeserver requires user-interactive authentication.
     */
    object Uiaa : CrossSigningResetAuthType()
    
    
    data class Oidc(
        val `info`: OidcCrossSigningResetInfo) : CrossSigningResetAuthType() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeCrossSigningResetAuthType : FfiConverterRustBuffer<CrossSigningResetAuthType>{
    override fun read(buf: ByteBuffer): CrossSigningResetAuthType {
        return when(buf.getInt()) {
            1 -> CrossSigningResetAuthType.Uiaa
            2 -> CrossSigningResetAuthType.Oidc(
                FfiConverterTypeOidcCrossSigningResetInfo.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: CrossSigningResetAuthType) = when(value) {
        is CrossSigningResetAuthType.Uiaa -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is CrossSigningResetAuthType.Oidc -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeOidcCrossSigningResetInfo.allocationSize(value.`info`)
            )
        }
    }

    override fun write(value: CrossSigningResetAuthType, buf: ByteBuffer) {
        when(value) {
            is CrossSigningResetAuthType.Uiaa -> {
                buf.putInt(1)
                Unit
            }
            is CrossSigningResetAuthType.Oidc -> {
                buf.putInt(2)
                FfiConverterTypeOidcCrossSigningResetInfo.write(value.`info`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Changes how date dividers get inserted, either in between each day or in
 * between each month
 */

enum class DateDividerMode {
    
    DAILY,
    MONTHLY;
    companion object
}


public object FfiConverterTypeDateDividerMode: FfiConverterRustBuffer<DateDividerMode> {
    override fun read(buf: ByteBuffer) = try {
        DateDividerMode.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: DateDividerMode) = 4UL

    override fun write(value: DateDividerMode, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * An attachment stored with a composer draft.
 */
sealed class DraftAttachment: Disposable  {
    
    data class Audio(
        val `audioInfo`: AudioInfo, 
        val `source`: UploadSource) : DraftAttachment() {
        companion object
    }
    
    data class File(
        val `fileInfo`: FileInfo, 
        val `source`: UploadSource) : DraftAttachment() {
        companion object
    }
    
    data class Image(
        val `imageInfo`: ImageInfo, 
        val `source`: UploadSource, 
        val `thumbnailSource`: UploadSource?) : DraftAttachment() {
        companion object
    }
    
    data class Video(
        val `videoInfo`: VideoInfo, 
        val `source`: UploadSource, 
        val `thumbnailSource`: UploadSource?) : DraftAttachment() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is DraftAttachment.Audio -> {
                
        Disposable.destroy(this.`audioInfo`)
    
        Disposable.destroy(this.`source`)
    
                
            }
            is DraftAttachment.File -> {
                
        Disposable.destroy(this.`fileInfo`)
    
        Disposable.destroy(this.`source`)
    
                
            }
            is DraftAttachment.Image -> {
                
        Disposable.destroy(this.`imageInfo`)
    
        Disposable.destroy(this.`source`)
    
        Disposable.destroy(this.`thumbnailSource`)
    
                
            }
            is DraftAttachment.Video -> {
                
        Disposable.destroy(this.`videoInfo`)
    
        Disposable.destroy(this.`source`)
    
        Disposable.destroy(this.`thumbnailSource`)
    
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

public object FfiConverterTypeDraftAttachment : FfiConverterRustBuffer<DraftAttachment>{
    override fun read(buf: ByteBuffer): DraftAttachment {
        return when(buf.getInt()) {
            1 -> DraftAttachment.Audio(
                FfiConverterTypeAudioInfo.read(buf),
                FfiConverterTypeUploadSource.read(buf),
                )
            2 -> DraftAttachment.File(
                FfiConverterTypeFileInfo.read(buf),
                FfiConverterTypeUploadSource.read(buf),
                )
            3 -> DraftAttachment.Image(
                FfiConverterTypeImageInfo.read(buf),
                FfiConverterTypeUploadSource.read(buf),
                FfiConverterOptionalTypeUploadSource.read(buf),
                )
            4 -> DraftAttachment.Video(
                FfiConverterTypeVideoInfo.read(buf),
                FfiConverterTypeUploadSource.read(buf),
                FfiConverterOptionalTypeUploadSource.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DraftAttachment) = when(value) {
        is DraftAttachment.Audio -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAudioInfo.allocationSize(value.`audioInfo`)
                + FfiConverterTypeUploadSource.allocationSize(value.`source`)
            )
        }
        is DraftAttachment.File -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeFileInfo.allocationSize(value.`fileInfo`)
                + FfiConverterTypeUploadSource.allocationSize(value.`source`)
            )
        }
        is DraftAttachment.Image -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeImageInfo.allocationSize(value.`imageInfo`)
                + FfiConverterTypeUploadSource.allocationSize(value.`source`)
                + FfiConverterOptionalTypeUploadSource.allocationSize(value.`thumbnailSource`)
            )
        }
        is DraftAttachment.Video -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeVideoInfo.allocationSize(value.`videoInfo`)
                + FfiConverterTypeUploadSource.allocationSize(value.`source`)
                + FfiConverterOptionalTypeUploadSource.allocationSize(value.`thumbnailSource`)
            )
        }
    }

    override fun write(value: DraftAttachment, buf: ByteBuffer) {
        when(value) {
            is DraftAttachment.Audio -> {
                buf.putInt(1)
                FfiConverterTypeAudioInfo.write(value.`audioInfo`, buf)
                FfiConverterTypeUploadSource.write(value.`source`, buf)
                Unit
            }
            is DraftAttachment.File -> {
                buf.putInt(2)
                FfiConverterTypeFileInfo.write(value.`fileInfo`, buf)
                FfiConverterTypeUploadSource.write(value.`source`, buf)
                Unit
            }
            is DraftAttachment.Image -> {
                buf.putInt(3)
                FfiConverterTypeImageInfo.write(value.`imageInfo`, buf)
                FfiConverterTypeUploadSource.write(value.`source`, buf)
                FfiConverterOptionalTypeUploadSource.write(value.`thumbnailSource`, buf)
                Unit
            }
            is DraftAttachment.Video -> {
                buf.putInt(4)
                FfiConverterTypeVideoInfo.write(value.`videoInfo`, buf)
                FfiConverterTypeUploadSource.write(value.`source`, buf)
                FfiConverterOptionalTypeUploadSource.write(value.`thumbnailSource`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class EditedContent: Disposable  {
    
    data class RoomMessage(
        val `content`: RoomMessageEventContentWithoutRelation) : EditedContent() {
        companion object
    }
    
    data class MediaCaption(
        val `caption`: kotlin.String?, 
        val `formattedCaption`: FormattedBody?, 
        val `mentions`: Mentions?) : EditedContent() {
        companion object
    }
    
    data class PollStart(
        val `pollData`: PollData) : EditedContent() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is EditedContent.RoomMessage -> {
                
        Disposable.destroy(this.`content`)
    
                
            }
            is EditedContent.MediaCaption -> {
                
        Disposable.destroy(this.`caption`)
    
        Disposable.destroy(this.`formattedCaption`)
    
        Disposable.destroy(this.`mentions`)
    
                
            }
            is EditedContent.PollStart -> {
                
        Disposable.destroy(this.`pollData`)
    
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

public object FfiConverterTypeEditedContent : FfiConverterRustBuffer<EditedContent>{
    override fun read(buf: ByteBuffer): EditedContent {
        return when(buf.getInt()) {
            1 -> EditedContent.RoomMessage(
                FfiConverterTypeRoomMessageEventContentWithoutRelation.read(buf),
                )
            2 -> EditedContent.MediaCaption(
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalTypeFormattedBody.read(buf),
                FfiConverterOptionalTypeMentions.read(buf),
                )
            3 -> EditedContent.PollStart(
                FfiConverterTypePollData.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: EditedContent) = when(value) {
        is EditedContent.RoomMessage -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeRoomMessageEventContentWithoutRelation.allocationSize(value.`content`)
            )
        }
        is EditedContent.MediaCaption -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalString.allocationSize(value.`caption`)
                + FfiConverterOptionalTypeFormattedBody.allocationSize(value.`formattedCaption`)
                + FfiConverterOptionalTypeMentions.allocationSize(value.`mentions`)
            )
        }
        is EditedContent.PollStart -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePollData.allocationSize(value.`pollData`)
            )
        }
    }

    override fun write(value: EditedContent, buf: ByteBuffer) {
        when(value) {
            is EditedContent.RoomMessage -> {
                buf.putInt(1)
                FfiConverterTypeRoomMessageEventContentWithoutRelation.write(value.`content`, buf)
                Unit
            }
            is EditedContent.MediaCaption -> {
                buf.putInt(2)
                FfiConverterOptionalString.write(value.`caption`, buf)
                FfiConverterOptionalTypeFormattedBody.write(value.`formattedCaption`, buf)
                FfiConverterOptionalTypeMentions.write(value.`mentions`, buf)
                Unit
            }
            is EditedContent.PollStart -> {
                buf.putInt(3)
                FfiConverterTypePollData.write(value.`pollData`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class EmbeddedEventDetails: Disposable  {
    
    object Unavailable : EmbeddedEventDetails()
    
    
    object Pending : EmbeddedEventDetails()
    
    
    data class Ready(
        val `content`: TimelineItemContent, 
        val `sender`: kotlin.String, 
        val `senderProfile`: ProfileDetails, 
        val `timestamp`: Timestamp, 
        val `eventOrTransactionId`: EventOrTransactionId) : EmbeddedEventDetails() {
        companion object
    }
    
    data class Error(
        val `message`: kotlin.String) : EmbeddedEventDetails() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is EmbeddedEventDetails.Unavailable -> {// Nothing to destroy
            }
            is EmbeddedEventDetails.Pending -> {// Nothing to destroy
            }
            is EmbeddedEventDetails.Ready -> {
                
        Disposable.destroy(this.`content`)
    
        Disposable.destroy(this.`sender`)
    
        Disposable.destroy(this.`senderProfile`)
    
        Disposable.destroy(this.`timestamp`)
    
        Disposable.destroy(this.`eventOrTransactionId`)
    
                
            }
            is EmbeddedEventDetails.Error -> {
                
        Disposable.destroy(this.`message`)
    
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

public object FfiConverterTypeEmbeddedEventDetails : FfiConverterRustBuffer<EmbeddedEventDetails>{
    override fun read(buf: ByteBuffer): EmbeddedEventDetails {
        return when(buf.getInt()) {
            1 -> EmbeddedEventDetails.Unavailable
            2 -> EmbeddedEventDetails.Pending
            3 -> EmbeddedEventDetails.Ready(
                FfiConverterTypeTimelineItemContent.read(buf),
                FfiConverterString.read(buf),
                FfiConverterTypeProfileDetails.read(buf),
                FfiConverterTypeTimestamp.read(buf),
                FfiConverterTypeEventOrTransactionId.read(buf),
                )
            4 -> EmbeddedEventDetails.Error(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: EmbeddedEventDetails) = when(value) {
        is EmbeddedEventDetails.Unavailable -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is EmbeddedEventDetails.Pending -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is EmbeddedEventDetails.Ready -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTimelineItemContent.allocationSize(value.`content`)
                + FfiConverterString.allocationSize(value.`sender`)
                + FfiConverterTypeProfileDetails.allocationSize(value.`senderProfile`)
                + FfiConverterTypeTimestamp.allocationSize(value.`timestamp`)
                + FfiConverterTypeEventOrTransactionId.allocationSize(value.`eventOrTransactionId`)
            )
        }
        is EmbeddedEventDetails.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`message`)
            )
        }
    }

    override fun write(value: EmbeddedEventDetails, buf: ByteBuffer) {
        when(value) {
            is EmbeddedEventDetails.Unavailable -> {
                buf.putInt(1)
                Unit
            }
            is EmbeddedEventDetails.Pending -> {
                buf.putInt(2)
                Unit
            }
            is EmbeddedEventDetails.Ready -> {
                buf.putInt(3)
                FfiConverterTypeTimelineItemContent.write(value.`content`, buf)
                FfiConverterString.write(value.`sender`, buf)
                FfiConverterTypeProfileDetails.write(value.`senderProfile`, buf)
                FfiConverterTypeTimestamp.write(value.`timestamp`, buf)
                FfiConverterTypeEventOrTransactionId.write(value.`eventOrTransactionId`, buf)
                Unit
            }
            is EmbeddedEventDetails.Error -> {
                buf.putInt(4)
                FfiConverterString.write(value.`message`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class EnableRecoveryProgress {
    
    object Starting : EnableRecoveryProgress()
    
    
    object CreatingBackup : EnableRecoveryProgress()
    
    
    object CreatingRecoveryKey : EnableRecoveryProgress()
    
    
    data class BackingUp(
        val `backedUpCount`: kotlin.UInt, 
        val `totalCount`: kotlin.UInt) : EnableRecoveryProgress() {
        companion object
    }
    
    object RoomKeyUploadError : EnableRecoveryProgress()
    
    
    data class Done(
        val `recoveryKey`: kotlin.String) : EnableRecoveryProgress() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeEnableRecoveryProgress : FfiConverterRustBuffer<EnableRecoveryProgress>{
    override fun read(buf: ByteBuffer): EnableRecoveryProgress {
        return when(buf.getInt()) {
            1 -> EnableRecoveryProgress.Starting
            2 -> EnableRecoveryProgress.CreatingBackup
            3 -> EnableRecoveryProgress.CreatingRecoveryKey
            4 -> EnableRecoveryProgress.BackingUp(
                FfiConverterUInt.read(buf),
                FfiConverterUInt.read(buf),
                )
            5 -> EnableRecoveryProgress.RoomKeyUploadError
            6 -> EnableRecoveryProgress.Done(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: EnableRecoveryProgress) = when(value) {
        is EnableRecoveryProgress.Starting -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is EnableRecoveryProgress.CreatingBackup -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is EnableRecoveryProgress.CreatingRecoveryKey -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is EnableRecoveryProgress.BackingUp -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUInt.allocationSize(value.`backedUpCount`)
                + FfiConverterUInt.allocationSize(value.`totalCount`)
            )
        }
        is EnableRecoveryProgress.RoomKeyUploadError -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is EnableRecoveryProgress.Done -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`recoveryKey`)
            )
        }
    }

    override fun write(value: EnableRecoveryProgress, buf: ByteBuffer) {
        when(value) {
            is EnableRecoveryProgress.Starting -> {
                buf.putInt(1)
                Unit
            }
            is EnableRecoveryProgress.CreatingBackup -> {
                buf.putInt(2)
                Unit
            }
            is EnableRecoveryProgress.CreatingRecoveryKey -> {
                buf.putInt(3)
                Unit
            }
            is EnableRecoveryProgress.BackingUp -> {
                buf.putInt(4)
                FfiConverterUInt.write(value.`backedUpCount`, buf)
                FfiConverterUInt.write(value.`totalCount`, buf)
                Unit
            }
            is EnableRecoveryProgress.RoomKeyUploadError -> {
                buf.putInt(5)
                Unit
            }
            is EnableRecoveryProgress.Done -> {
                buf.putInt(6)
                FfiConverterString.write(value.`recoveryKey`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class EncryptedMessage {
    
    data class OlmV1Curve25519AesSha2(
        /**
         * The Curve25519 key of the sender.
         */
        val `senderKey`: kotlin.String) : EncryptedMessage() {
        companion object
    }
    
    data class MegolmV1AesSha2(
        /**
         * The ID of the session used to encrypt the message.
         */
        val `sessionId`: kotlin.String, 
        /**
         * What we know about what caused this UTD. E.g. was this event sent
         * when we were not a member of this room?
         */
        val `cause`: UtdCause) : EncryptedMessage() {
        companion object
    }
    
    object Unknown : EncryptedMessage()
    
    

    
    companion object
}

public object FfiConverterTypeEncryptedMessage : FfiConverterRustBuffer<EncryptedMessage>{
    override fun read(buf: ByteBuffer): EncryptedMessage {
        return when(buf.getInt()) {
            1 -> EncryptedMessage.OlmV1Curve25519AesSha2(
                FfiConverterString.read(buf),
                )
            2 -> EncryptedMessage.MegolmV1AesSha2(
                FfiConverterString.read(buf),
                FfiConverterTypeUtdCause.read(buf),
                )
            3 -> EncryptedMessage.Unknown
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: EncryptedMessage) = when(value) {
        is EncryptedMessage.OlmV1Curve25519AesSha2 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`senderKey`)
            )
        }
        is EncryptedMessage.MegolmV1AesSha2 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`sessionId`)
                + FfiConverterTypeUtdCause.allocationSize(value.`cause`)
            )
        }
        is EncryptedMessage.Unknown -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: EncryptedMessage, buf: ByteBuffer) {
        when(value) {
            is EncryptedMessage.OlmV1Curve25519AesSha2 -> {
                buf.putInt(1)
                FfiConverterString.write(value.`senderKey`, buf)
                Unit
            }
            is EncryptedMessage.MegolmV1AesSha2 -> {
                buf.putInt(2)
                FfiConverterString.write(value.`sessionId`, buf)
                FfiConverterTypeUtdCause.write(value.`cause`, buf)
                Unit
            }
            is EncryptedMessage.Unknown -> {
                buf.putInt(3)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ErrorKind {
    
    /**
     * `M_BAD_ALIAS`
     *
     * One or more [room aliases] within the `m.room.canonical_alias` event do
     * not point to the room ID for which the state event is to be sent to.
     *
     * [room aliases]: https://spec.matrix.org/latest/client-server-api/#room-aliases
     */
    object BadAlias : ErrorKind()
    
    
    /**
     * `M_BAD_JSON`
     *
     * The request contained valid JSON, but it was malformed in some way, e.g.
     * missing required keys, invalid values for keys.
     */
    object BadJson : ErrorKind()
    
    
    /**
     * `M_BAD_STATE`
     *
     * The state change requested cannot be performed, such as attempting to
     * unban a user who is not banned.
     */
    object BadState : ErrorKind()
    
    
    /**
     * `M_BAD_STATUS`
     *
     * The application service returned a bad status.
     */
    data class BadStatus(
        /**
         * The HTTP status code of the response.
         */
        val `status`: kotlin.UShort?, 
        /**
         * The body of the response.
         */
        val `body`: kotlin.String?) : ErrorKind() {
        companion object
    }
    
    /**
     * `M_CANNOT_LEAVE_SERVER_NOTICE_ROOM`
     *
     * The user is unable to reject an invite to join the [server notices]
     * room.
     *
     * [server notices]: https://spec.matrix.org/latest/client-server-api/#server-notices
     */
    object CannotLeaveServerNoticeRoom : ErrorKind()
    
    
    /**
     * `M_CANNOT_OVERWRITE_MEDIA`
     *
     * The [`create_content_async`] endpoint was called with a media ID that
     * already has content.
     *
     * [`create_content_async`]: crate::media::create_content_async
     */
    object CannotOverwriteMedia : ErrorKind()
    
    
    /**
     * `M_CAPTCHA_INVALID`
     *
     * The Captcha provided did not match what was expected.
     */
    object CaptchaInvalid : ErrorKind()
    
    
    /**
     * `M_CAPTCHA_NEEDED`
     *
     * A Captcha is required to complete the request.
     */
    object CaptchaNeeded : ErrorKind()
    
    
    /**
     * `M_CONNECTION_FAILED`
     *
     * The connection to the application service failed.
     */
    object ConnectionFailed : ErrorKind()
    
    
    /**
     * `M_CONNECTION_TIMEOUT`
     *
     * The connection to the application service timed out.
     */
    object ConnectionTimeout : ErrorKind()
    
    
    /**
     * `M_DUPLICATE_ANNOTATION`
     *
     * The request is an attempt to send a [duplicate annotation].
     *
     * [duplicate annotation]: https://spec.matrix.org/latest/client-server-api/#avoiding-duplicate-annotations
     */
    object DuplicateAnnotation : ErrorKind()
    
    
    /**
     * `M_EXCLUSIVE`
     *
     * The resource being requested is reserved by an application service, or
     * the application service making the request has not created the
     * resource.
     */
    object Exclusive : ErrorKind()
    
    
    /**
     * `M_FORBIDDEN`
     *
     * Forbidden access, e.g. joining a room without permission, failed login.
     */
    object Forbidden : ErrorKind()
    
    
    /**
     * `M_GUEST_ACCESS_FORBIDDEN`
     *
     * The room or resource does not permit [guests] to access it.
     *
     * [guests]: https://spec.matrix.org/latest/client-server-api/#guest-access
     */
    object GuestAccessForbidden : ErrorKind()
    
    
    /**
     * `M_INCOMPATIBLE_ROOM_VERSION`
     *
     * The client attempted to join a room that has a version the server does
     * not support.
     */
    data class IncompatibleRoomVersion(
        /**
         * The room's version.
         */
        val `roomVersion`: kotlin.String) : ErrorKind() {
        companion object
    }
    
    /**
     * `M_INVALID_PARAM`
     *
     * A parameter that was specified has the wrong value. For example, the
     * server expected an integer and instead received a string.
     */
    object InvalidParam : ErrorKind()
    
    
    /**
     * `M_INVALID_ROOM_STATE`
     *
     * The initial state implied by the parameters to the [`create_room`]
     * request is invalid, e.g. the user's `power_level` is set below that
     * necessary to set the room name.
     *
     * [`create_room`]: crate::room::create_room
     */
    object InvalidRoomState : ErrorKind()
    
    
    /**
     * `M_INVALID_USERNAME`
     *
     * The desired user name is not valid.
     */
    object InvalidUsername : ErrorKind()
    
    
    /**
     * `M_LIMIT_EXCEEDED`
     *
     * The request has been refused due to [rate limiting]: too many requests
     * have been sent in a short period of time.
     *
     * [rate limiting]: https://spec.matrix.org/latest/client-server-api/#rate-limiting
     */
    data class LimitExceeded(
        /**
         * How long a client should wait before they can try again.
         */
        val `retryAfterMs`: kotlin.ULong?) : ErrorKind() {
        companion object
    }
    
    /**
     * `M_MISSING_PARAM`
     *
     * A required parameter was missing from the request.
     */
    object MissingParam : ErrorKind()
    
    
    /**
     * `M_MISSING_TOKEN`
     *
     * No [access token] was specified for the request, but one is required.
     *
     * [access token]: https://spec.matrix.org/latest/client-server-api/#client-authentication
     */
    object MissingToken : ErrorKind()
    
    
    /**
     * `M_NOT_FOUND`
     *
     * No resource was found for this request.
     */
    object NotFound : ErrorKind()
    
    
    /**
     * `M_NOT_JSON`
     *
     * The request did not contain valid JSON.
     */
    object NotJson : ErrorKind()
    
    
    /**
     * `M_NOT_YET_UPLOADED`
     *
     * An `mxc:` URI generated with the [`create_mxc_uri`] endpoint was used
     * and the content is not yet available.
     *
     * [`create_mxc_uri`]: crate::media::create_mxc_uri
     */
    object NotYetUploaded : ErrorKind()
    
    
    /**
     * `M_RESOURCE_LIMIT_EXCEEDED`
     *
     * The request cannot be completed because the homeserver has reached a
     * resource limit imposed on it. For example, a homeserver held in a
     * shared hosting environment may reach a resource limit if it starts
     * using too much memory or disk space.
     */
    data class ResourceLimitExceeded(
        /**
         * A URI giving a contact method for the server administrator.
         */
        val `adminContact`: kotlin.String) : ErrorKind() {
        companion object
    }
    
    /**
     * `M_ROOM_IN_USE`
     *
     * The [room alias] specified in the [`create_room`] request is already
     * taken.
     *
     * [`create_room`]: crate::room::create_room
     * [room alias]: https://spec.matrix.org/latest/client-server-api/#room-aliases
     */
    object RoomInUse : ErrorKind()
    
    
    /**
     * `M_SERVER_NOT_TRUSTED`
     *
     * The client's request used a third-party server, e.g. identity server,
     * that this server does not trust.
     */
    object ServerNotTrusted : ErrorKind()
    
    
    /**
     * `M_THREEPID_AUTH_FAILED`
     *
     * Authentication could not be performed on the [third-party identifier].
     *
     * [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
     */
    object ThreepidAuthFailed : ErrorKind()
    
    
    /**
     * `M_THREEPID_DENIED`
     *
     * The server does not permit this [third-party identifier]. This may
     * happen if the server only permits, for example, email addresses from
     * a particular domain.
     *
     * [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
     */
    object ThreepidDenied : ErrorKind()
    
    
    /**
     * `M_THREEPID_IN_USE`
     *
     * The [third-party identifier] is already in use by another user.
     *
     * [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
     */
    object ThreepidInUse : ErrorKind()
    
    
    /**
     * `M_THREEPID_MEDIUM_NOT_SUPPORTED`
     *
     * The homeserver does not support adding a [third-party identifier] of the
     * given medium.
     *
     * [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
     */
    object ThreepidMediumNotSupported : ErrorKind()
    
    
    /**
     * `M_THREEPID_NOT_FOUND`
     *
     * No account matching the given [third-party identifier] could be found.
     *
     * [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
     */
    object ThreepidNotFound : ErrorKind()
    
    
    /**
     * `M_TOO_LARGE`
     *
     * The request or entity was too large.
     */
    object TooLarge : ErrorKind()
    
    
    /**
     * `M_UNABLE_TO_AUTHORISE_JOIN`
     *
     * The room is [restricted] and none of the conditions can be validated by
     * the homeserver. This can happen if the homeserver does not know
     * about any of the rooms listed as conditions, for example.
     *
     * [restricted]: https://spec.matrix.org/latest/client-server-api/#restricted-rooms
     */
    object UnableToAuthorizeJoin : ErrorKind()
    
    
    /**
     * `M_UNABLE_TO_GRANT_JOIN`
     *
     * A different server should be attempted for the join. This is typically
     * because the resident server can see that the joining user satisfies
     * one or more conditions, such as in the case of [restricted rooms],
     * but the resident server would be unable to meet the authorization
     * rules.
     *
     * [restricted rooms]: https://spec.matrix.org/latest/client-server-api/#restricted-rooms
     */
    object UnableToGrantJoin : ErrorKind()
    
    
    /**
     * `M_UNAUTHORIZED`
     *
     * The request was not correctly authorized. Usually due to login failures.
     */
    object Unauthorized : ErrorKind()
    
    
    /**
     * `M_UNKNOWN`
     *
     * An unknown error has occurred.
     */
    object Unknown : ErrorKind()
    
    
    /**
     * `M_UNKNOWN_TOKEN`
     *
     * The [access or refresh token] specified was not recognized.
     *
     * [access or refresh token]: https://spec.matrix.org/latest/client-server-api/#client-authentication
     */
    data class UnknownToken(
        /**
         * If this is `true`, the client is in a "[soft logout]" state, i.e.
         * the server requires re-authentication but the session is not
         * invalidated. The client can acquire a new access token by
         * specifying the device ID it is already using to the login API.
         *
         * [soft logout]: https://spec.matrix.org/latest/client-server-api/#soft-logout
         */
        val `softLogout`: kotlin.Boolean) : ErrorKind() {
        companion object
    }
    
    /**
     * `M_UNRECOGNIZED`
     *
     * The server did not understand the request.
     *
     * This is expected to be returned with a 404 HTTP status code if the
     * endpoint is not implemented or a 405 HTTP status code if the
     * endpoint is implemented, but the incorrect HTTP method is used.
     */
    object Unrecognized : ErrorKind()
    
    
    /**
     * `M_UNSUPPORTED_ROOM_VERSION`
     *
     * The request to [`create_room`] used a room version that the server does
     * not support.
     *
     * [`create_room`]: crate::room::create_room
     */
    object UnsupportedRoomVersion : ErrorKind()
    
    
    /**
     * `M_URL_NOT_SET`
     *
     * The application service doesn't have a URL configured.
     */
    object UrlNotSet : ErrorKind()
    
    
    /**
     * `M_USER_DEACTIVATED`
     *
     * The user ID associated with the request has been deactivated.
     */
    object UserDeactivated : ErrorKind()
    
    
    /**
     * `M_USER_IN_USE`
     *
     * The desired user ID is already taken.
     */
    object UserInUse : ErrorKind()
    
    
    /**
     * `M_USER_LOCKED`
     *
     * The account has been [locked] and cannot be used at this time.
     *
     * [locked]: https://spec.matrix.org/latest/client-server-api/#account-locking
     */
    object UserLocked : ErrorKind()
    
    
    /**
     * `M_USER_SUSPENDED`
     *
     * The account has been [suspended] and can only be used for limited
     * actions at this time.
     *
     * [suspended]: https://spec.matrix.org/latest/client-server-api/#account-suspension
     */
    object UserSuspended : ErrorKind()
    
    
    /**
     * `M_WEAK_PASSWORD`
     *
     * The password was [rejected] by the server for being too weak.
     *
     * [rejected]: https://spec.matrix.org/latest/client-server-api/#notes-on-password-management
     */
    object WeakPassword : ErrorKind()
    
    
    /**
     * `M_WRONG_ROOM_KEYS_VERSION`
     *
     * The version of the [room keys backup] provided in the request does not
     * match the current backup version.
     *
     * [room keys backup]: https://spec.matrix.org/latest/client-server-api/#server-side-key-backups
     */
    data class WrongRoomKeysVersion(
        /**
         * The currently active backup version.
         */
        val `currentVersion`: kotlin.String?) : ErrorKind() {
        companion object
    }
    
    /**
     * A custom API error.
     */
    data class Custom(
        val `errcode`: kotlin.String) : ErrorKind() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeErrorKind : FfiConverterRustBuffer<ErrorKind>{
    override fun read(buf: ByteBuffer): ErrorKind {
        return when(buf.getInt()) {
            1 -> ErrorKind.BadAlias
            2 -> ErrorKind.BadJson
            3 -> ErrorKind.BadState
            4 -> ErrorKind.BadStatus(
                FfiConverterOptionalUShort.read(buf),
                FfiConverterOptionalString.read(buf),
                )
            5 -> ErrorKind.CannotLeaveServerNoticeRoom
            6 -> ErrorKind.CannotOverwriteMedia
            7 -> ErrorKind.CaptchaInvalid
            8 -> ErrorKind.CaptchaNeeded
            9 -> ErrorKind.ConnectionFailed
            10 -> ErrorKind.ConnectionTimeout
            11 -> ErrorKind.DuplicateAnnotation
            12 -> ErrorKind.Exclusive
            13 -> ErrorKind.Forbidden
            14 -> ErrorKind.GuestAccessForbidden
            15 -> ErrorKind.IncompatibleRoomVersion(
                FfiConverterString.read(buf),
                )
            16 -> ErrorKind.InvalidParam
            17 -> ErrorKind.InvalidRoomState
            18 -> ErrorKind.InvalidUsername
            19 -> ErrorKind.LimitExceeded(
                FfiConverterOptionalULong.read(buf),
                )
            20 -> ErrorKind.MissingParam
            21 -> ErrorKind.MissingToken
            22 -> ErrorKind.NotFound
            23 -> ErrorKind.NotJson
            24 -> ErrorKind.NotYetUploaded
            25 -> ErrorKind.ResourceLimitExceeded(
                FfiConverterString.read(buf),
                )
            26 -> ErrorKind.RoomInUse
            27 -> ErrorKind.ServerNotTrusted
            28 -> ErrorKind.ThreepidAuthFailed
            29 -> ErrorKind.ThreepidDenied
            30 -> ErrorKind.ThreepidInUse
            31 -> ErrorKind.ThreepidMediumNotSupported
            32 -> ErrorKind.ThreepidNotFound
            33 -> ErrorKind.TooLarge
            34 -> ErrorKind.UnableToAuthorizeJoin
            35 -> ErrorKind.UnableToGrantJoin
            36 -> ErrorKind.Unauthorized
            37 -> ErrorKind.Unknown
            38 -> ErrorKind.UnknownToken(
                FfiConverterBoolean.read(buf),
                )
            39 -> ErrorKind.Unrecognized
            40 -> ErrorKind.UnsupportedRoomVersion
            41 -> ErrorKind.UrlNotSet
            42 -> ErrorKind.UserDeactivated
            43 -> ErrorKind.UserInUse
            44 -> ErrorKind.UserLocked
            45 -> ErrorKind.UserSuspended
            46 -> ErrorKind.WeakPassword
            47 -> ErrorKind.WrongRoomKeysVersion(
                FfiConverterOptionalString.read(buf),
                )
            48 -> ErrorKind.Custom(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ErrorKind) = when(value) {
        is ErrorKind.BadAlias -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.BadJson -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.BadState -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.BadStatus -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalUShort.allocationSize(value.`status`)
                + FfiConverterOptionalString.allocationSize(value.`body`)
            )
        }
        is ErrorKind.CannotLeaveServerNoticeRoom -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.CannotOverwriteMedia -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.CaptchaInvalid -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.CaptchaNeeded -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.ConnectionFailed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.ConnectionTimeout -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.DuplicateAnnotation -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.Exclusive -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.Forbidden -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.GuestAccessForbidden -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.IncompatibleRoomVersion -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`roomVersion`)
            )
        }
        is ErrorKind.InvalidParam -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.InvalidRoomState -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.InvalidUsername -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.LimitExceeded -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalULong.allocationSize(value.`retryAfterMs`)
            )
        }
        is ErrorKind.MissingParam -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.MissingToken -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.NotFound -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.NotJson -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.NotYetUploaded -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.ResourceLimitExceeded -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`adminContact`)
            )
        }
        is ErrorKind.RoomInUse -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.ServerNotTrusted -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.ThreepidAuthFailed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.ThreepidDenied -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.ThreepidInUse -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.ThreepidMediumNotSupported -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.ThreepidNotFound -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.TooLarge -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.UnableToAuthorizeJoin -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.UnableToGrantJoin -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.Unauthorized -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.Unknown -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.UnknownToken -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterBoolean.allocationSize(value.`softLogout`)
            )
        }
        is ErrorKind.Unrecognized -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.UnsupportedRoomVersion -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.UrlNotSet -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.UserDeactivated -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.UserInUse -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.UserLocked -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.UserSuspended -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.WeakPassword -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ErrorKind.WrongRoomKeysVersion -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalString.allocationSize(value.`currentVersion`)
            )
        }
        is ErrorKind.Custom -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`errcode`)
            )
        }
    }

    override fun write(value: ErrorKind, buf: ByteBuffer) {
        when(value) {
            is ErrorKind.BadAlias -> {
                buf.putInt(1)
                Unit
            }
            is ErrorKind.BadJson -> {
                buf.putInt(2)
                Unit
            }
            is ErrorKind.BadState -> {
                buf.putInt(3)
                Unit
            }
            is ErrorKind.BadStatus -> {
                buf.putInt(4)
                FfiConverterOptionalUShort.write(value.`status`, buf)
                FfiConverterOptionalString.write(value.`body`, buf)
                Unit
            }
            is ErrorKind.CannotLeaveServerNoticeRoom -> {
                buf.putInt(5)
                Unit
            }
            is ErrorKind.CannotOverwriteMedia -> {
                buf.putInt(6)
                Unit
            }
            is ErrorKind.CaptchaInvalid -> {
                buf.putInt(7)
                Unit
            }
            is ErrorKind.CaptchaNeeded -> {
                buf.putInt(8)
                Unit
            }
            is ErrorKind.ConnectionFailed -> {
                buf.putInt(9)
                Unit
            }
            is ErrorKind.ConnectionTimeout -> {
                buf.putInt(10)
                Unit
            }
            is ErrorKind.DuplicateAnnotation -> {
                buf.putInt(11)
                Unit
            }
            is ErrorKind.Exclusive -> {
                buf.putInt(12)
                Unit
            }
            is ErrorKind.Forbidden -> {
                buf.putInt(13)
                Unit
            }
            is ErrorKind.GuestAccessForbidden -> {
                buf.putInt(14)
                Unit
            }
            is ErrorKind.IncompatibleRoomVersion -> {
                buf.putInt(15)
                FfiConverterString.write(value.`roomVersion`, buf)
                Unit
            }
            is ErrorKind.InvalidParam -> {
                buf.putInt(16)
                Unit
            }
            is ErrorKind.InvalidRoomState -> {
                buf.putInt(17)
                Unit
            }
            is ErrorKind.InvalidUsername -> {
                buf.putInt(18)
                Unit
            }
            is ErrorKind.LimitExceeded -> {
                buf.putInt(19)
                FfiConverterOptionalULong.write(value.`retryAfterMs`, buf)
                Unit
            }
            is ErrorKind.MissingParam -> {
                buf.putInt(20)
                Unit
            }
            is ErrorKind.MissingToken -> {
                buf.putInt(21)
                Unit
            }
            is ErrorKind.NotFound -> {
                buf.putInt(22)
                Unit
            }
            is ErrorKind.NotJson -> {
                buf.putInt(23)
                Unit
            }
            is ErrorKind.NotYetUploaded -> {
                buf.putInt(24)
                Unit
            }
            is ErrorKind.ResourceLimitExceeded -> {
                buf.putInt(25)
                FfiConverterString.write(value.`adminContact`, buf)
                Unit
            }
            is ErrorKind.RoomInUse -> {
                buf.putInt(26)
                Unit
            }
            is ErrorKind.ServerNotTrusted -> {
                buf.putInt(27)
                Unit
            }
            is ErrorKind.ThreepidAuthFailed -> {
                buf.putInt(28)
                Unit
            }
            is ErrorKind.ThreepidDenied -> {
                buf.putInt(29)
                Unit
            }
            is ErrorKind.ThreepidInUse -> {
                buf.putInt(30)
                Unit
            }
            is ErrorKind.ThreepidMediumNotSupported -> {
                buf.putInt(31)
                Unit
            }
            is ErrorKind.ThreepidNotFound -> {
                buf.putInt(32)
                Unit
            }
            is ErrorKind.TooLarge -> {
                buf.putInt(33)
                Unit
            }
            is ErrorKind.UnableToAuthorizeJoin -> {
                buf.putInt(34)
                Unit
            }
            is ErrorKind.UnableToGrantJoin -> {
                buf.putInt(35)
                Unit
            }
            is ErrorKind.Unauthorized -> {
                buf.putInt(36)
                Unit
            }
            is ErrorKind.Unknown -> {
                buf.putInt(37)
                Unit
            }
            is ErrorKind.UnknownToken -> {
                buf.putInt(38)
                FfiConverterBoolean.write(value.`softLogout`, buf)
                Unit
            }
            is ErrorKind.Unrecognized -> {
                buf.putInt(39)
                Unit
            }
            is ErrorKind.UnsupportedRoomVersion -> {
                buf.putInt(40)
                Unit
            }
            is ErrorKind.UrlNotSet -> {
                buf.putInt(41)
                Unit
            }
            is ErrorKind.UserDeactivated -> {
                buf.putInt(42)
                Unit
            }
            is ErrorKind.UserInUse -> {
                buf.putInt(43)
                Unit
            }
            is ErrorKind.UserLocked -> {
                buf.putInt(44)
                Unit
            }
            is ErrorKind.UserSuspended -> {
                buf.putInt(45)
                Unit
            }
            is ErrorKind.WeakPassword -> {
                buf.putInt(46)
                Unit
            }
            is ErrorKind.WrongRoomKeysVersion -> {
                buf.putInt(47)
                FfiConverterOptionalString.write(value.`currentVersion`, buf)
                Unit
            }
            is ErrorKind.Custom -> {
                buf.putInt(48)
                FfiConverterString.write(value.`errcode`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Contains the 2 possible identifiers of an event, either it has a remote
 * event id or a local transaction id, never both or none.
 */
sealed class EventOrTransactionId {
    
    data class EventId(
        val `eventId`: kotlin.String) : EventOrTransactionId() {
        companion object
    }
    
    data class TransactionId(
        val `transactionId`: kotlin.String) : EventOrTransactionId() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeEventOrTransactionId : FfiConverterRustBuffer<EventOrTransactionId>{
    override fun read(buf: ByteBuffer): EventOrTransactionId {
        return when(buf.getInt()) {
            1 -> EventOrTransactionId.EventId(
                FfiConverterString.read(buf),
                )
            2 -> EventOrTransactionId.TransactionId(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: EventOrTransactionId) = when(value) {
        is EventOrTransactionId.EventId -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`eventId`)
            )
        }
        is EventOrTransactionId.TransactionId -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`transactionId`)
            )
        }
    }

    override fun write(value: EventOrTransactionId, buf: ByteBuffer) {
        when(value) {
            is EventOrTransactionId.EventId -> {
                buf.putInt(1)
                FfiConverterString.write(value.`eventId`, buf)
                Unit
            }
            is EventOrTransactionId.TransactionId -> {
                buf.putInt(2)
                FfiConverterString.write(value.`transactionId`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * This type represents the send state of a local event timeline item.
 */
sealed class EventSendState {
    
    /**
     * The local event has not been sent yet.
     */
    data class NotSentYet(
        /**
         * The progress of the sending operation, if the event involves a media
         * upload.
         */
        val `progress`: MediaUploadProgress?) : EventSendState() {
        companion object
    }
    
    /**
     * The local event has been sent to the server, but unsuccessfully: The
     * sending has failed.
     */
    data class SendingFailed(
        /**
         * The error reason, with information for the user.
         */
        val `error`: QueueWedgeError, 
        /**
         * Whether the error is considered recoverable or not.
         *
         * An error that's recoverable will disable the room's send queue,
         * while an unrecoverable error will be parked, until the user
         * decides to cancel sending it.
         */
        val `isRecoverable`: kotlin.Boolean) : EventSendState() {
        companion object
    }
    
    /**
     * The local event has been sent successfully to the server.
     */
    data class Sent(
        val `eventId`: kotlin.String) : EventSendState() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeEventSendState : FfiConverterRustBuffer<EventSendState>{
    override fun read(buf: ByteBuffer): EventSendState {
        return when(buf.getInt()) {
            1 -> EventSendState.NotSentYet(
                FfiConverterOptionalTypeMediaUploadProgress.read(buf),
                )
            2 -> EventSendState.SendingFailed(
                FfiConverterTypeQueueWedgeError.read(buf),
                FfiConverterBoolean.read(buf),
                )
            3 -> EventSendState.Sent(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: EventSendState) = when(value) {
        is EventSendState.NotSentYet -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeMediaUploadProgress.allocationSize(value.`progress`)
            )
        }
        is EventSendState.SendingFailed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeQueueWedgeError.allocationSize(value.`error`)
                + FfiConverterBoolean.allocationSize(value.`isRecoverable`)
            )
        }
        is EventSendState.Sent -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`eventId`)
            )
        }
    }

    override fun write(value: EventSendState, buf: ByteBuffer) {
        when(value) {
            is EventSendState.NotSentYet -> {
                buf.putInt(1)
                FfiConverterOptionalTypeMediaUploadProgress.write(value.`progress`, buf)
                Unit
            }
            is EventSendState.SendingFailed -> {
                buf.putInt(2)
                FfiConverterTypeQueueWedgeError.write(value.`error`, buf)
                FfiConverterBoolean.write(value.`isRecoverable`, buf)
                Unit
            }
            is EventSendState.Sent -> {
                buf.putInt(3)
                FfiConverterString.write(value.`eventId`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class FilterTimelineEventType {
    
    data class MessageLike(
        val `eventType`: MessageLikeEventType) : FilterTimelineEventType() {
        companion object
    }
    
    data class State(
        val `eventType`: StateEventType) : FilterTimelineEventType() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeFilterTimelineEventType : FfiConverterRustBuffer<FilterTimelineEventType>{
    override fun read(buf: ByteBuffer): FilterTimelineEventType {
        return when(buf.getInt()) {
            1 -> FilterTimelineEventType.MessageLike(
                FfiConverterTypeMessageLikeEventType.read(buf),
                )
            2 -> FilterTimelineEventType.State(
                FfiConverterTypeStateEventType.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: FilterTimelineEventType) = when(value) {
        is FilterTimelineEventType.MessageLike -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMessageLikeEventType.allocationSize(value.`eventType`)
            )
        }
        is FilterTimelineEventType.State -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeStateEventType.allocationSize(value.`eventType`)
            )
        }
    }

    override fun write(value: FilterTimelineEventType, buf: ByteBuffer) {
        when(value) {
            is FilterTimelineEventType.MessageLike -> {
                buf.putInt(1)
                FfiConverterTypeMessageLikeEventType.write(value.`eventType`, buf)
                Unit
            }
            is FilterTimelineEventType.State -> {
                buf.putInt(2)
                FfiConverterTypeStateEventType.write(value.`eventType`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class FocusEventException: kotlin.Exception() {
    
    class InvalidEventId(
        
        val `eventId`: kotlin.String, 
        
        val `err`: kotlin.String
        ) : FocusEventException() {
        override val message
            get() = "eventId=${ `eventId` }, err=${ `err` }"
    }
    
    class EventNotFound(
        
        val `eventId`: kotlin.String
        ) : FocusEventException() {
        override val message
            get() = "eventId=${ `eventId` }"
    }
    
    class Other(
        
        val `msg`: kotlin.String
        ) : FocusEventException() {
        override val message
            get() = "msg=${ `msg` }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<FocusEventException> {
        override fun lift(error_buf: RustBuffer.ByValue): FocusEventException = FfiConverterTypeFocusEventError.lift(error_buf)
    }

    
}

public object FfiConverterTypeFocusEventError : FfiConverterRustBuffer<FocusEventException> {
    override fun read(buf: ByteBuffer): FocusEventException {
        

        return when(buf.getInt()) {
            1 -> FocusEventException.InvalidEventId(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                )
            2 -> FocusEventException.EventNotFound(
                FfiConverterString.read(buf),
                )
            3 -> FocusEventException.Other(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: FocusEventException): ULong {
        return when(value) {
            is FocusEventException.InvalidEventId -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`eventId`)
                + FfiConverterString.allocationSize(value.`err`)
            )
            is FocusEventException.EventNotFound -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`eventId`)
            )
            is FocusEventException.Other -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`msg`)
            )
        }
    }

    override fun write(value: FocusEventException, buf: ByteBuffer) {
        when(value) {
            is FocusEventException.InvalidEventId -> {
                buf.putInt(1)
                FfiConverterString.write(value.`eventId`, buf)
                FfiConverterString.write(value.`err`, buf)
                Unit
            }
            is FocusEventException.EventNotFound -> {
                buf.putInt(2)
                FfiConverterString.write(value.`eventId`, buf)
                Unit
            }
            is FocusEventException.Other -> {
                buf.putInt(3)
                FfiConverterString.write(value.`msg`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class GalleryItemInfo: Disposable  {
    
    data class Audio(
        val `audioInfo`: AudioInfo, 
        val `source`: UploadSource, 
        val `caption`: kotlin.String?, 
        val `formattedCaption`: FormattedBody?) : GalleryItemInfo() {
        companion object
    }
    
    data class File(
        val `fileInfo`: FileInfo, 
        val `source`: UploadSource, 
        val `caption`: kotlin.String?, 
        val `formattedCaption`: FormattedBody?) : GalleryItemInfo() {
        companion object
    }
    
    data class Image(
        val `imageInfo`: ImageInfo, 
        val `source`: UploadSource, 
        val `caption`: kotlin.String?, 
        val `formattedCaption`: FormattedBody?, 
        val `thumbnailSource`: UploadSource?) : GalleryItemInfo() {
        companion object
    }
    
    data class Video(
        val `videoInfo`: VideoInfo, 
        val `source`: UploadSource, 
        val `caption`: kotlin.String?, 
        val `formattedCaption`: FormattedBody?, 
        val `thumbnailSource`: UploadSource?) : GalleryItemInfo() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is GalleryItemInfo.Audio -> {
                
        Disposable.destroy(this.`audioInfo`)
    
        Disposable.destroy(this.`source`)
    
        Disposable.destroy(this.`caption`)
    
        Disposable.destroy(this.`formattedCaption`)
    
                
            }
            is GalleryItemInfo.File -> {
                
        Disposable.destroy(this.`fileInfo`)
    
        Disposable.destroy(this.`source`)
    
        Disposable.destroy(this.`caption`)
    
        Disposable.destroy(this.`formattedCaption`)
    
                
            }
            is GalleryItemInfo.Image -> {
                
        Disposable.destroy(this.`imageInfo`)
    
        Disposable.destroy(this.`source`)
    
        Disposable.destroy(this.`caption`)
    
        Disposable.destroy(this.`formattedCaption`)
    
        Disposable.destroy(this.`thumbnailSource`)
    
                
            }
            is GalleryItemInfo.Video -> {
                
        Disposable.destroy(this.`videoInfo`)
    
        Disposable.destroy(this.`source`)
    
        Disposable.destroy(this.`caption`)
    
        Disposable.destroy(this.`formattedCaption`)
    
        Disposable.destroy(this.`thumbnailSource`)
    
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

public object FfiConverterTypeGalleryItemInfo : FfiConverterRustBuffer<GalleryItemInfo>{
    override fun read(buf: ByteBuffer): GalleryItemInfo {
        return when(buf.getInt()) {
            1 -> GalleryItemInfo.Audio(
                FfiConverterTypeAudioInfo.read(buf),
                FfiConverterTypeUploadSource.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalTypeFormattedBody.read(buf),
                )
            2 -> GalleryItemInfo.File(
                FfiConverterTypeFileInfo.read(buf),
                FfiConverterTypeUploadSource.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalTypeFormattedBody.read(buf),
                )
            3 -> GalleryItemInfo.Image(
                FfiConverterTypeImageInfo.read(buf),
                FfiConverterTypeUploadSource.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalTypeFormattedBody.read(buf),
                FfiConverterOptionalTypeUploadSource.read(buf),
                )
            4 -> GalleryItemInfo.Video(
                FfiConverterTypeVideoInfo.read(buf),
                FfiConverterTypeUploadSource.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalTypeFormattedBody.read(buf),
                FfiConverterOptionalTypeUploadSource.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: GalleryItemInfo) = when(value) {
        is GalleryItemInfo.Audio -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAudioInfo.allocationSize(value.`audioInfo`)
                + FfiConverterTypeUploadSource.allocationSize(value.`source`)
                + FfiConverterOptionalString.allocationSize(value.`caption`)
                + FfiConverterOptionalTypeFormattedBody.allocationSize(value.`formattedCaption`)
            )
        }
        is GalleryItemInfo.File -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeFileInfo.allocationSize(value.`fileInfo`)
                + FfiConverterTypeUploadSource.allocationSize(value.`source`)
                + FfiConverterOptionalString.allocationSize(value.`caption`)
                + FfiConverterOptionalTypeFormattedBody.allocationSize(value.`formattedCaption`)
            )
        }
        is GalleryItemInfo.Image -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeImageInfo.allocationSize(value.`imageInfo`)
                + FfiConverterTypeUploadSource.allocationSize(value.`source`)
                + FfiConverterOptionalString.allocationSize(value.`caption`)
                + FfiConverterOptionalTypeFormattedBody.allocationSize(value.`formattedCaption`)
                + FfiConverterOptionalTypeUploadSource.allocationSize(value.`thumbnailSource`)
            )
        }
        is GalleryItemInfo.Video -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeVideoInfo.allocationSize(value.`videoInfo`)
                + FfiConverterTypeUploadSource.allocationSize(value.`source`)
                + FfiConverterOptionalString.allocationSize(value.`caption`)
                + FfiConverterOptionalTypeFormattedBody.allocationSize(value.`formattedCaption`)
                + FfiConverterOptionalTypeUploadSource.allocationSize(value.`thumbnailSource`)
            )
        }
    }

    override fun write(value: GalleryItemInfo, buf: ByteBuffer) {
        when(value) {
            is GalleryItemInfo.Audio -> {
                buf.putInt(1)
                FfiConverterTypeAudioInfo.write(value.`audioInfo`, buf)
                FfiConverterTypeUploadSource.write(value.`source`, buf)
                FfiConverterOptionalString.write(value.`caption`, buf)
                FfiConverterOptionalTypeFormattedBody.write(value.`formattedCaption`, buf)
                Unit
            }
            is GalleryItemInfo.File -> {
                buf.putInt(2)
                FfiConverterTypeFileInfo.write(value.`fileInfo`, buf)
                FfiConverterTypeUploadSource.write(value.`source`, buf)
                FfiConverterOptionalString.write(value.`caption`, buf)
                FfiConverterOptionalTypeFormattedBody.write(value.`formattedCaption`, buf)
                Unit
            }
            is GalleryItemInfo.Image -> {
                buf.putInt(3)
                FfiConverterTypeImageInfo.write(value.`imageInfo`, buf)
                FfiConverterTypeUploadSource.write(value.`source`, buf)
                FfiConverterOptionalString.write(value.`caption`, buf)
                FfiConverterOptionalTypeFormattedBody.write(value.`formattedCaption`, buf)
                FfiConverterOptionalTypeUploadSource.write(value.`thumbnailSource`, buf)
                Unit
            }
            is GalleryItemInfo.Video -> {
                buf.putInt(4)
                FfiConverterTypeVideoInfo.write(value.`videoInfo`, buf)
                FfiConverterTypeUploadSource.write(value.`source`, buf)
                FfiConverterOptionalString.write(value.`caption`, buf)
                FfiConverterOptionalTypeFormattedBody.write(value.`formattedCaption`, buf)
                FfiConverterOptionalTypeUploadSource.write(value.`thumbnailSource`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class GalleryItemType: Disposable  {
    
    data class Image(
        val `content`: ImageMessageContent) : GalleryItemType() {
        companion object
    }
    
    data class Audio(
        val `content`: AudioMessageContent) : GalleryItemType() {
        companion object
    }
    
    data class Video(
        val `content`: VideoMessageContent) : GalleryItemType() {
        companion object
    }
    
    data class File(
        val `content`: FileMessageContent) : GalleryItemType() {
        companion object
    }
    
    data class Other(
        val `itemtype`: kotlin.String, 
        val `body`: kotlin.String) : GalleryItemType() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is GalleryItemType.Image -> {
                
        Disposable.destroy(this.`content`)
    
                
            }
            is GalleryItemType.Audio -> {
                
        Disposable.destroy(this.`content`)
    
                
            }
            is GalleryItemType.Video -> {
                
        Disposable.destroy(this.`content`)
    
                
            }
            is GalleryItemType.File -> {
                
        Disposable.destroy(this.`content`)
    
                
            }
            is GalleryItemType.Other -> {
                
        Disposable.destroy(this.`itemtype`)
    
        Disposable.destroy(this.`body`)
    
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

public object FfiConverterTypeGalleryItemType : FfiConverterRustBuffer<GalleryItemType>{
    override fun read(buf: ByteBuffer): GalleryItemType {
        return when(buf.getInt()) {
            1 -> GalleryItemType.Image(
                FfiConverterTypeImageMessageContent.read(buf),
                )
            2 -> GalleryItemType.Audio(
                FfiConverterTypeAudioMessageContent.read(buf),
                )
            3 -> GalleryItemType.Video(
                FfiConverterTypeVideoMessageContent.read(buf),
                )
            4 -> GalleryItemType.File(
                FfiConverterTypeFileMessageContent.read(buf),
                )
            5 -> GalleryItemType.Other(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: GalleryItemType) = when(value) {
        is GalleryItemType.Image -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeImageMessageContent.allocationSize(value.`content`)
            )
        }
        is GalleryItemType.Audio -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAudioMessageContent.allocationSize(value.`content`)
            )
        }
        is GalleryItemType.Video -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeVideoMessageContent.allocationSize(value.`content`)
            )
        }
        is GalleryItemType.File -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeFileMessageContent.allocationSize(value.`content`)
            )
        }
        is GalleryItemType.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`itemtype`)
                + FfiConverterString.allocationSize(value.`body`)
            )
        }
    }

    override fun write(value: GalleryItemType, buf: ByteBuffer) {
        when(value) {
            is GalleryItemType.Image -> {
                buf.putInt(1)
                FfiConverterTypeImageMessageContent.write(value.`content`, buf)
                Unit
            }
            is GalleryItemType.Audio -> {
                buf.putInt(2)
                FfiConverterTypeAudioMessageContent.write(value.`content`, buf)
                Unit
            }
            is GalleryItemType.Video -> {
                buf.putInt(3)
                FfiConverterTypeVideoMessageContent.write(value.`content`, buf)
                Unit
            }
            is GalleryItemType.File -> {
                buf.putInt(4)
                FfiConverterTypeFileMessageContent.write(value.`content`, buf)
                Unit
            }
            is GalleryItemType.Other -> {
                buf.putInt(5)
                FfiConverterString.write(value.`itemtype`, buf)
                FfiConverterString.write(value.`body`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Enum describing the progress of logging in by generating a QR code and
 * having an existing device scan it.
 */
sealed class GeneratedQrLoginProgress: Disposable  {
    
    /**
     * The login process is starting.
     */
    object Starting : GeneratedQrLoginProgress()
    
    
    /**
     * We have established the secure channel and now need to display the
     * QR code so that the existing device can scan it.
     */
    data class QrReady(
        val `qrCode`: QrCodeData) : GeneratedQrLoginProgress() {
        companion object
    }
    
    /**
     * The existing device has scanned the QR code and is displaying the
     * checkcode. We now need to ask the user to enter the checkcode so that
     * we can verify that the channel is indeed secure.
     */
    data class QrScanned(
        val `checkCodeSender`: CheckCodeSender) : GeneratedQrLoginProgress() {
        companion object
    }
    
    /**
     * We are waiting for the login and for the OAuth 2.0 authorization server
     * to give us an access token.
     */
    data class WaitingForToken(
        val `userCode`: kotlin.String) : GeneratedQrLoginProgress() {
        companion object
    }
    
    /**
     * We are syncing secrets.
     */
    object SyncingSecrets : GeneratedQrLoginProgress()
    
    
    /**
     * The login has successfully finished.
     */
    object Done : GeneratedQrLoginProgress()
    
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is GeneratedQrLoginProgress.Starting -> {// Nothing to destroy
            }
            is GeneratedQrLoginProgress.QrReady -> {
                
        Disposable.destroy(this.`qrCode`)
    
                
            }
            is GeneratedQrLoginProgress.QrScanned -> {
                
        Disposable.destroy(this.`checkCodeSender`)
    
                
            }
            is GeneratedQrLoginProgress.WaitingForToken -> {
                
        Disposable.destroy(this.`userCode`)
    
                
            }
            is GeneratedQrLoginProgress.SyncingSecrets -> {// Nothing to destroy
            }
            is GeneratedQrLoginProgress.Done -> {// Nothing to destroy
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

public object FfiConverterTypeGeneratedQrLoginProgress : FfiConverterRustBuffer<GeneratedQrLoginProgress>{
    override fun read(buf: ByteBuffer): GeneratedQrLoginProgress {
        return when(buf.getInt()) {
            1 -> GeneratedQrLoginProgress.Starting
            2 -> GeneratedQrLoginProgress.QrReady(
                FfiConverterTypeQrCodeData.read(buf),
                )
            3 -> GeneratedQrLoginProgress.QrScanned(
                FfiConverterTypeCheckCodeSender.read(buf),
                )
            4 -> GeneratedQrLoginProgress.WaitingForToken(
                FfiConverterString.read(buf),
                )
            5 -> GeneratedQrLoginProgress.SyncingSecrets
            6 -> GeneratedQrLoginProgress.Done
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: GeneratedQrLoginProgress) = when(value) {
        is GeneratedQrLoginProgress.Starting -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is GeneratedQrLoginProgress.QrReady -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeQrCodeData.allocationSize(value.`qrCode`)
            )
        }
        is GeneratedQrLoginProgress.QrScanned -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeCheckCodeSender.allocationSize(value.`checkCodeSender`)
            )
        }
        is GeneratedQrLoginProgress.WaitingForToken -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`userCode`)
            )
        }
        is GeneratedQrLoginProgress.SyncingSecrets -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is GeneratedQrLoginProgress.Done -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: GeneratedQrLoginProgress, buf: ByteBuffer) {
        when(value) {
            is GeneratedQrLoginProgress.Starting -> {
                buf.putInt(1)
                Unit
            }
            is GeneratedQrLoginProgress.QrReady -> {
                buf.putInt(2)
                FfiConverterTypeQrCodeData.write(value.`qrCode`, buf)
                Unit
            }
            is GeneratedQrLoginProgress.QrScanned -> {
                buf.putInt(3)
                FfiConverterTypeCheckCodeSender.write(value.`checkCodeSender`, buf)
                Unit
            }
            is GeneratedQrLoginProgress.WaitingForToken -> {
                buf.putInt(4)
                FfiConverterString.write(value.`userCode`, buf)
                Unit
            }
            is GeneratedQrLoginProgress.SyncingSecrets -> {
                buf.putInt(5)
                Unit
            }
            is GeneratedQrLoginProgress.Done -> {
                buf.putInt(6)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class HumanQrLoginException: kotlin.Exception() {
    
    class LinkingNotSupported(
        ) : HumanQrLoginException() {
        override val message
            get() = ""
    }
    
    class Cancelled(
        ) : HumanQrLoginException() {
        override val message
            get() = ""
    }
    
    class Expired(
        ) : HumanQrLoginException() {
        override val message
            get() = ""
    }
    
    class ConnectionInsecure(
        ) : HumanQrLoginException() {
        override val message
            get() = ""
    }
    
    class Declined(
        ) : HumanQrLoginException() {
        override val message
            get() = ""
    }
    
    class Unknown(
        ) : HumanQrLoginException() {
        override val message
            get() = ""
    }
    
    class SlidingSyncNotAvailable(
        ) : HumanQrLoginException() {
        override val message
            get() = ""
    }
    
    class OidcMetadataInvalid(
        ) : HumanQrLoginException() {
        override val message
            get() = ""
    }
    
    class OtherDeviceNotSignedIn(
        ) : HumanQrLoginException() {
        override val message
            get() = ""
    }
    
    class CheckCodeAlreadySent(
        ) : HumanQrLoginException() {
        override val message
            get() = ""
    }
    
    class CheckCodeCannotBeSent(
        ) : HumanQrLoginException() {
        override val message
            get() = ""
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<HumanQrLoginException> {
        override fun lift(error_buf: RustBuffer.ByValue): HumanQrLoginException = FfiConverterTypeHumanQrLoginError.lift(error_buf)
    }

    
}

public object FfiConverterTypeHumanQrLoginError : FfiConverterRustBuffer<HumanQrLoginException> {
    override fun read(buf: ByteBuffer): HumanQrLoginException {
        

        return when(buf.getInt()) {
            1 -> HumanQrLoginException.LinkingNotSupported()
            2 -> HumanQrLoginException.Cancelled()
            3 -> HumanQrLoginException.Expired()
            4 -> HumanQrLoginException.ConnectionInsecure()
            5 -> HumanQrLoginException.Declined()
            6 -> HumanQrLoginException.Unknown()
            7 -> HumanQrLoginException.SlidingSyncNotAvailable()
            8 -> HumanQrLoginException.OidcMetadataInvalid()
            9 -> HumanQrLoginException.OtherDeviceNotSignedIn()
            10 -> HumanQrLoginException.CheckCodeAlreadySent()
            11 -> HumanQrLoginException.CheckCodeCannotBeSent()
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: HumanQrLoginException): ULong {
        return when(value) {
            is HumanQrLoginException.LinkingNotSupported -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is HumanQrLoginException.Cancelled -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is HumanQrLoginException.Expired -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is HumanQrLoginException.ConnectionInsecure -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is HumanQrLoginException.Declined -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is HumanQrLoginException.Unknown -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is HumanQrLoginException.SlidingSyncNotAvailable -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is HumanQrLoginException.OidcMetadataInvalid -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is HumanQrLoginException.OtherDeviceNotSignedIn -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is HumanQrLoginException.CheckCodeAlreadySent -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is HumanQrLoginException.CheckCodeCannotBeSent -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
        }
    }

    override fun write(value: HumanQrLoginException, buf: ByteBuffer) {
        when(value) {
            is HumanQrLoginException.LinkingNotSupported -> {
                buf.putInt(1)
                Unit
            }
            is HumanQrLoginException.Cancelled -> {
                buf.putInt(2)
                Unit
            }
            is HumanQrLoginException.Expired -> {
                buf.putInt(3)
                Unit
            }
            is HumanQrLoginException.ConnectionInsecure -> {
                buf.putInt(4)
                Unit
            }
            is HumanQrLoginException.Declined -> {
                buf.putInt(5)
                Unit
            }
            is HumanQrLoginException.Unknown -> {
                buf.putInt(6)
                Unit
            }
            is HumanQrLoginException.SlidingSyncNotAvailable -> {
                buf.putInt(7)
                Unit
            }
            is HumanQrLoginException.OidcMetadataInvalid -> {
                buf.putInt(8)
                Unit
            }
            is HumanQrLoginException.OtherDeviceNotSignedIn -> {
                buf.putInt(9)
                Unit
            }
            is HumanQrLoginException.CheckCodeAlreadySent -> {
                buf.putInt(10)
                Unit
            }
            is HumanQrLoginException.CheckCodeCannotBeSent -> {
                buf.putInt(11)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



/**
 * The policy that decides if avatars should be shown in invite requests.
 */

enum class InviteAvatars {
    
    /**
     * Always show avatars in invite requests.
     */
    ON,
    /**
     * Never show avatars in invite requests.
     */
    OFF;
    companion object
}


public object FfiConverterTypeInviteAvatars: FfiConverterRustBuffer<InviteAvatars> {
    override fun read(buf: ByteBuffer) = try {
        InviteAvatars.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: InviteAvatars) = 4UL

    override fun write(value: InviteAvatars, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * The rule used for users wishing to join this room.
 */
sealed class JoinRule {
    
    /**
     * Anyone can join the room without any prior action.
     */
    object Public : JoinRule()
    
    
    /**
     * A user who wishes to join the room must first receive an invite to the
     * room from someone already inside of the room.
     */
    object Invite : JoinRule()
    
    
    /**
     * Users can join the room if they are invited, or they can request an
     * invite to the room.
     *
     * They can be allowed (invited) or denied (kicked/banned) access.
     */
    object Knock : JoinRule()
    
    
    /**
     * Reserved but not yet implemented by the Matrix specification.
     */
    object Private : JoinRule()
    
    
    /**
     * Users can join the room if they are invited, or if they meet any of the
     * conditions described in a set of [`AllowRule`]s.
     */
    data class Restricted(
        val `rules`: List<AllowRule>) : JoinRule() {
        companion object
    }
    
    /**
     * Users can join the room if they are invited, or if they meet any of the
     * conditions described in a set of [`AllowRule`]s, or they can request
     * an invite to the room.
     */
    data class KnockRestricted(
        val `rules`: List<AllowRule>) : JoinRule() {
        companion object
    }
    
    /**
     * A custom join rule, up for interpretation by the consumer.
     */
    data class Custom(
        /**
         * The string representation for this custom rule.
         */
        val `repr`: kotlin.String) : JoinRule() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeJoinRule : FfiConverterRustBuffer<JoinRule>{
    override fun read(buf: ByteBuffer): JoinRule {
        return when(buf.getInt()) {
            1 -> JoinRule.Public
            2 -> JoinRule.Invite
            3 -> JoinRule.Knock
            4 -> JoinRule.Private
            5 -> JoinRule.Restricted(
                FfiConverterSequenceTypeAllowRule.read(buf),
                )
            6 -> JoinRule.KnockRestricted(
                FfiConverterSequenceTypeAllowRule.read(buf),
                )
            7 -> JoinRule.Custom(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: JoinRule) = when(value) {
        is JoinRule.Public -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is JoinRule.Invite -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is JoinRule.Knock -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is JoinRule.Private -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is JoinRule.Restricted -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeAllowRule.allocationSize(value.`rules`)
            )
        }
        is JoinRule.KnockRestricted -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeAllowRule.allocationSize(value.`rules`)
            )
        }
        is JoinRule.Custom -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`repr`)
            )
        }
    }

    override fun write(value: JoinRule, buf: ByteBuffer) {
        when(value) {
            is JoinRule.Public -> {
                buf.putInt(1)
                Unit
            }
            is JoinRule.Invite -> {
                buf.putInt(2)
                Unit
            }
            is JoinRule.Knock -> {
                buf.putInt(3)
                Unit
            }
            is JoinRule.Private -> {
                buf.putInt(4)
                Unit
            }
            is JoinRule.Restricted -> {
                buf.putInt(5)
                FfiConverterSequenceTypeAllowRule.write(value.`rules`, buf)
                Unit
            }
            is JoinRule.KnockRestricted -> {
                buf.putInt(6)
                FfiConverterSequenceTypeAllowRule.write(value.`rules`, buf)
                Unit
            }
            is JoinRule.Custom -> {
                buf.putInt(7)
                FfiConverterString.write(value.`repr`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class JsonValue {
    
    /**
     * Represents a `null` value.
     */
    object Null : JsonValue()
    
    
    /**
     * Represents a boolean.
     */
    data class Bool(
        val `value`: kotlin.Boolean) : JsonValue() {
        companion object
    }
    
    /**
     * Represents an integer.
     */
    data class Integer(
        val `value`: kotlin.Long) : JsonValue() {
        companion object
    }
    
    /**
     * Represents a string.
     */
    data class String(
        val `value`: kotlin.String) : JsonValue() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeJsonValue : FfiConverterRustBuffer<JsonValue>{
    override fun read(buf: ByteBuffer): JsonValue {
        return when(buf.getInt()) {
            1 -> JsonValue.Null
            2 -> JsonValue.Bool(
                FfiConverterBoolean.read(buf),
                )
            3 -> JsonValue.Integer(
                FfiConverterLong.read(buf),
                )
            4 -> JsonValue.String(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: JsonValue) = when(value) {
        is JsonValue.Null -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is JsonValue.Bool -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterBoolean.allocationSize(value.`value`)
            )
        }
        is JsonValue.Integer -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterLong.allocationSize(value.`value`)
            )
        }
        is JsonValue.String -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: JsonValue, buf: ByteBuffer) {
        when(value) {
            is JsonValue.Null -> {
                buf.putInt(1)
                Unit
            }
            is JsonValue.Bool -> {
                buf.putInt(2)
                FfiConverterBoolean.write(value.`value`, buf)
                Unit
            }
            is JsonValue.Integer -> {
                buf.putInt(3)
                FfiConverterLong.write(value.`value`, buf)
                Unit
            }
            is JsonValue.String -> {
                buf.putInt(4)
                FfiConverterString.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * A key algorithm to be used to generate a key from a passphrase.
 */

enum class KeyDerivationAlgorithm {
    
    /**
     * PBKDF2
     */
    PBKFD2;
    companion object
}


public object FfiConverterTypeKeyDerivationAlgorithm: FfiConverterRustBuffer<KeyDerivationAlgorithm> {
    override fun read(buf: ByteBuffer) = try {
        KeyDerivationAlgorithm.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: KeyDerivationAlgorithm) = 4UL

    override fun write(value: KeyDerivationAlgorithm, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Mimic the [`UiLatestEventValue`] type.
 */
sealed class LatestEventValue: Disposable  {
    
    object None : LatestEventValue()
    
    
    data class Remote(
        val `timestamp`: Timestamp, 
        val `sender`: kotlin.String, 
        val `isOwn`: kotlin.Boolean, 
        val `profile`: ProfileDetails, 
        val `content`: TimelineItemContent) : LatestEventValue() {
        companion object
    }
    
    data class Local(
        val `timestamp`: Timestamp, 
        val `content`: TimelineItemContent, 
        val `isSending`: kotlin.Boolean) : LatestEventValue() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is LatestEventValue.None -> {// Nothing to destroy
            }
            is LatestEventValue.Remote -> {
                
        Disposable.destroy(this.`timestamp`)
    
        Disposable.destroy(this.`sender`)
    
        Disposable.destroy(this.`isOwn`)
    
        Disposable.destroy(this.`profile`)
    
        Disposable.destroy(this.`content`)
    
                
            }
            is LatestEventValue.Local -> {
                
        Disposable.destroy(this.`timestamp`)
    
        Disposable.destroy(this.`content`)
    
        Disposable.destroy(this.`isSending`)
    
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

public object FfiConverterTypeLatestEventValue : FfiConverterRustBuffer<LatestEventValue>{
    override fun read(buf: ByteBuffer): LatestEventValue {
        return when(buf.getInt()) {
            1 -> LatestEventValue.None
            2 -> LatestEventValue.Remote(
                FfiConverterTypeTimestamp.read(buf),
                FfiConverterString.read(buf),
                FfiConverterBoolean.read(buf),
                FfiConverterTypeProfileDetails.read(buf),
                FfiConverterTypeTimelineItemContent.read(buf),
                )
            3 -> LatestEventValue.Local(
                FfiConverterTypeTimestamp.read(buf),
                FfiConverterTypeTimelineItemContent.read(buf),
                FfiConverterBoolean.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LatestEventValue) = when(value) {
        is LatestEventValue.None -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is LatestEventValue.Remote -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTimestamp.allocationSize(value.`timestamp`)
                + FfiConverterString.allocationSize(value.`sender`)
                + FfiConverterBoolean.allocationSize(value.`isOwn`)
                + FfiConverterTypeProfileDetails.allocationSize(value.`profile`)
                + FfiConverterTypeTimelineItemContent.allocationSize(value.`content`)
            )
        }
        is LatestEventValue.Local -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTimestamp.allocationSize(value.`timestamp`)
                + FfiConverterTypeTimelineItemContent.allocationSize(value.`content`)
                + FfiConverterBoolean.allocationSize(value.`isSending`)
            )
        }
    }

    override fun write(value: LatestEventValue, buf: ByteBuffer) {
        when(value) {
            is LatestEventValue.None -> {
                buf.putInt(1)
                Unit
            }
            is LatestEventValue.Remote -> {
                buf.putInt(2)
                FfiConverterTypeTimestamp.write(value.`timestamp`, buf)
                FfiConverterString.write(value.`sender`, buf)
                FfiConverterBoolean.write(value.`isOwn`, buf)
                FfiConverterTypeProfileDetails.write(value.`profile`, buf)
                FfiConverterTypeTimelineItemContent.write(value.`content`, buf)
                Unit
            }
            is LatestEventValue.Local -> {
                buf.putInt(3)
                FfiConverterTypeTimestamp.write(value.`timestamp`, buf)
                FfiConverterTypeTimelineItemContent.write(value.`content`, buf)
                FfiConverterBoolean.write(value.`isSending`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class LogLevel {
    
    ERROR,
    WARN,
    INFO,
    DEBUG,
    TRACE;
    companion object
}


public object FfiConverterTypeLogLevel: FfiConverterRustBuffer<LogLevel> {
    override fun read(buf: ByteBuffer) = try {
        LogLevel.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: LogLevel) = 4UL

    override fun write(value: LogLevel, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * A Matrix ID that can be a room, room alias, user, or event.
 */
sealed class MatrixId {
    
    data class Room(
        val `id`: kotlin.String) : MatrixId() {
        companion object
    }
    
    data class RoomAlias(
        val `alias`: kotlin.String) : MatrixId() {
        companion object
    }
    
    data class User(
        val `id`: kotlin.String) : MatrixId() {
        companion object
    }
    
    data class EventOnRoomId(
        val `roomId`: kotlin.String, 
        val `eventId`: kotlin.String) : MatrixId() {
        companion object
    }
    
    data class EventOnRoomAlias(
        val `alias`: kotlin.String, 
        val `eventId`: kotlin.String) : MatrixId() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeMatrixId : FfiConverterRustBuffer<MatrixId>{
    override fun read(buf: ByteBuffer): MatrixId {
        return when(buf.getInt()) {
            1 -> MatrixId.Room(
                FfiConverterString.read(buf),
                )
            2 -> MatrixId.RoomAlias(
                FfiConverterString.read(buf),
                )
            3 -> MatrixId.User(
                FfiConverterString.read(buf),
                )
            4 -> MatrixId.EventOnRoomId(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                )
            5 -> MatrixId.EventOnRoomAlias(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MatrixId) = when(value) {
        is MatrixId.Room -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`id`)
            )
        }
        is MatrixId.RoomAlias -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`alias`)
            )
        }
        is MatrixId.User -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`id`)
            )
        }
        is MatrixId.EventOnRoomId -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`roomId`)
                + FfiConverterString.allocationSize(value.`eventId`)
            )
        }
        is MatrixId.EventOnRoomAlias -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`alias`)
                + FfiConverterString.allocationSize(value.`eventId`)
            )
        }
    }

    override fun write(value: MatrixId, buf: ByteBuffer) {
        when(value) {
            is MatrixId.Room -> {
                buf.putInt(1)
                FfiConverterString.write(value.`id`, buf)
                Unit
            }
            is MatrixId.RoomAlias -> {
                buf.putInt(2)
                FfiConverterString.write(value.`alias`, buf)
                Unit
            }
            is MatrixId.User -> {
                buf.putInt(3)
                FfiConverterString.write(value.`id`, buf)
                Unit
            }
            is MatrixId.EventOnRoomId -> {
                buf.putInt(4)
                FfiConverterString.write(value.`roomId`, buf)
                FfiConverterString.write(value.`eventId`, buf)
                Unit
            }
            is MatrixId.EventOnRoomAlias -> {
                buf.putInt(5)
                FfiConverterString.write(value.`alias`, buf)
                FfiConverterString.write(value.`eventId`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class MediaInfoException(message: String): kotlin.Exception(message) {
        
        class MissingField(message: String) : MediaInfoException(message)
        
        class InvalidField(message: String) : MediaInfoException(message)
        

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<MediaInfoException> {
        override fun lift(error_buf: RustBuffer.ByValue): MediaInfoException = FfiConverterTypeMediaInfoError.lift(error_buf)
    }
}

public object FfiConverterTypeMediaInfoError : FfiConverterRustBuffer<MediaInfoException> {
    override fun read(buf: ByteBuffer): MediaInfoException {
        
            return when(buf.getInt()) {
            1 -> MediaInfoException.MissingField(FfiConverterString.read(buf))
            2 -> MediaInfoException.InvalidField(FfiConverterString.read(buf))
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
        
    }

    override fun allocationSize(value: MediaInfoException): ULong {
        return 4UL
    }

    override fun write(value: MediaInfoException, buf: ByteBuffer) {
        when(value) {
            is MediaInfoException.MissingField -> {
                buf.putInt(1)
                Unit
            }
            is MediaInfoException.InvalidField -> {
                buf.putInt(2)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



/**
 * The policy that decides if media previews should be shown in the timeline.
 */

enum class MediaPreviews {
    
    /**
     * Always show media previews in the timeline.
     */
    ON,
    /**
     * Show media previews in the timeline only if the room is private.
     */
    PRIVATE,
    /**
     * Never show media previews in the timeline.
     */
    OFF;
    companion object
}


public object FfiConverterTypeMediaPreviews: FfiConverterRustBuffer<MediaPreviews> {
    override fun read(buf: ByteBuffer) = try {
        MediaPreviews.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: MediaPreviews) = 4UL

    override fun write(value: MediaPreviews, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class Membership {
    
    INVITED,
    JOINED,
    LEFT,
    KNOCKED,
    BANNED;
    companion object
}


public object FfiConverterTypeMembership: FfiConverterRustBuffer<Membership> {
    override fun read(buf: ByteBuffer) = try {
        Membership.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: Membership) = 4UL

    override fun write(value: Membership, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class MembershipChange {
    
    NONE,
    ERROR,
    JOINED,
    LEFT,
    BANNED,
    UNBANNED,
    KICKED,
    INVITED,
    KICKED_AND_BANNED,
    INVITATION_ACCEPTED,
    INVITATION_REJECTED,
    INVITATION_REVOKED,
    KNOCKED,
    KNOCK_ACCEPTED,
    KNOCK_RETRACTED,
    KNOCK_DENIED,
    NOT_IMPLEMENTED;
    companion object
}


public object FfiConverterTypeMembershipChange: FfiConverterRustBuffer<MembershipChange> {
    override fun read(buf: ByteBuffer) = try {
        MembershipChange.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: MembershipChange) = 4UL

    override fun write(value: MembershipChange, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class MembershipState {
    
    /**
     * The user is banned.
     */
    object Ban : MembershipState()
    
    
    /**
     * The user has been invited.
     */
    object Invite : MembershipState()
    
    
    /**
     * The user has joined.
     */
    object Join : MembershipState()
    
    
    /**
     * The user has requested to join.
     */
    object Knock : MembershipState()
    
    
    /**
     * The user has left.
     */
    object Leave : MembershipState()
    
    
    /**
     * A custom membership state value.
     */
    data class Custom(
        val `value`: kotlin.String) : MembershipState() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeMembershipState : FfiConverterRustBuffer<MembershipState>{
    override fun read(buf: ByteBuffer): MembershipState {
        return when(buf.getInt()) {
            1 -> MembershipState.Ban
            2 -> MembershipState.Invite
            3 -> MembershipState.Join
            4 -> MembershipState.Knock
            5 -> MembershipState.Leave
            6 -> MembershipState.Custom(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MembershipState) = when(value) {
        is MembershipState.Ban -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MembershipState.Invite -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MembershipState.Join -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MembershipState.Knock -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MembershipState.Leave -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MembershipState.Custom -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: MembershipState, buf: ByteBuffer) {
        when(value) {
            is MembershipState.Ban -> {
                buf.putInt(1)
                Unit
            }
            is MembershipState.Invite -> {
                buf.putInt(2)
                Unit
            }
            is MembershipState.Join -> {
                buf.putInt(3)
                Unit
            }
            is MembershipState.Knock -> {
                buf.putInt(4)
                Unit
            }
            is MembershipState.Leave -> {
                buf.putInt(5)
                Unit
            }
            is MembershipState.Custom -> {
                buf.putInt(6)
                FfiConverterString.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MessageFormat {
    
    object Html : MessageFormat()
    
    
    data class Unknown(
        val `format`: kotlin.String) : MessageFormat() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeMessageFormat : FfiConverterRustBuffer<MessageFormat>{
    override fun read(buf: ByteBuffer): MessageFormat {
        return when(buf.getInt()) {
            1 -> MessageFormat.Html
            2 -> MessageFormat.Unknown(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MessageFormat) = when(value) {
        is MessageFormat.Html -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageFormat.Unknown -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`format`)
            )
        }
    }

    override fun write(value: MessageFormat, buf: ByteBuffer) {
        when(value) {
            is MessageFormat.Html -> {
                buf.putInt(1)
                Unit
            }
            is MessageFormat.Unknown -> {
                buf.putInt(2)
                FfiConverterString.write(value.`format`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MessageLikeEventContent: Disposable  {
    
    object CallAnswer : MessageLikeEventContent()
    
    
    object CallInvite : MessageLikeEventContent()
    
    
    data class RtcNotification(
        val `notificationType`: RtcNotificationType, 
        /**
         * The timestamp at which this notification is considered invalid.
         */
        val `expirationTs`: Timestamp) : MessageLikeEventContent() {
        companion object
    }
    
    object CallHangup : MessageLikeEventContent()
    
    
    object CallCandidates : MessageLikeEventContent()
    
    
    object KeyVerificationReady : MessageLikeEventContent()
    
    
    object KeyVerificationStart : MessageLikeEventContent()
    
    
    object KeyVerificationCancel : MessageLikeEventContent()
    
    
    object KeyVerificationAccept : MessageLikeEventContent()
    
    
    object KeyVerificationKey : MessageLikeEventContent()
    
    
    object KeyVerificationMac : MessageLikeEventContent()
    
    
    object KeyVerificationDone : MessageLikeEventContent()
    
    
    data class Poll(
        val `question`: kotlin.String) : MessageLikeEventContent() {
        companion object
    }
    
    data class ReactionContent(
        val `relatedEventId`: kotlin.String) : MessageLikeEventContent() {
        companion object
    }
    
    object RoomEncrypted : MessageLikeEventContent()
    
    
    data class RoomMessage(
        val `messageType`: MessageType, 
        val `inReplyToEventId`: kotlin.String?) : MessageLikeEventContent() {
        companion object
    }
    
    data class RoomRedaction(
        val `redactedEventId`: kotlin.String?, 
        val `reason`: kotlin.String?) : MessageLikeEventContent() {
        companion object
    }
    
    object Sticker : MessageLikeEventContent()
    
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MessageLikeEventContent.CallAnswer -> {// Nothing to destroy
            }
            is MessageLikeEventContent.CallInvite -> {// Nothing to destroy
            }
            is MessageLikeEventContent.RtcNotification -> {
                
        Disposable.destroy(this.`notificationType`)
    
        Disposable.destroy(this.`expirationTs`)
    
                
            }
            is MessageLikeEventContent.CallHangup -> {// Nothing to destroy
            }
            is MessageLikeEventContent.CallCandidates -> {// Nothing to destroy
            }
            is MessageLikeEventContent.KeyVerificationReady -> {// Nothing to destroy
            }
            is MessageLikeEventContent.KeyVerificationStart -> {// Nothing to destroy
            }
            is MessageLikeEventContent.KeyVerificationCancel -> {// Nothing to destroy
            }
            is MessageLikeEventContent.KeyVerificationAccept -> {// Nothing to destroy
            }
            is MessageLikeEventContent.KeyVerificationKey -> {// Nothing to destroy
            }
            is MessageLikeEventContent.KeyVerificationMac -> {// Nothing to destroy
            }
            is MessageLikeEventContent.KeyVerificationDone -> {// Nothing to destroy
            }
            is MessageLikeEventContent.Poll -> {
                
        Disposable.destroy(this.`question`)
    
                
            }
            is MessageLikeEventContent.ReactionContent -> {
                
        Disposable.destroy(this.`relatedEventId`)
    
                
            }
            is MessageLikeEventContent.RoomEncrypted -> {// Nothing to destroy
            }
            is MessageLikeEventContent.RoomMessage -> {
                
        Disposable.destroy(this.`messageType`)
    
        Disposable.destroy(this.`inReplyToEventId`)
    
                
            }
            is MessageLikeEventContent.RoomRedaction -> {
                
        Disposable.destroy(this.`redactedEventId`)
    
        Disposable.destroy(this.`reason`)
    
                
            }
            is MessageLikeEventContent.Sticker -> {// Nothing to destroy
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

public object FfiConverterTypeMessageLikeEventContent : FfiConverterRustBuffer<MessageLikeEventContent>{
    override fun read(buf: ByteBuffer): MessageLikeEventContent {
        return when(buf.getInt()) {
            1 -> MessageLikeEventContent.CallAnswer
            2 -> MessageLikeEventContent.CallInvite
            3 -> MessageLikeEventContent.RtcNotification(
                FfiConverterTypeRtcNotificationType.read(buf),
                FfiConverterTypeTimestamp.read(buf),
                )
            4 -> MessageLikeEventContent.CallHangup
            5 -> MessageLikeEventContent.CallCandidates
            6 -> MessageLikeEventContent.KeyVerificationReady
            7 -> MessageLikeEventContent.KeyVerificationStart
            8 -> MessageLikeEventContent.KeyVerificationCancel
            9 -> MessageLikeEventContent.KeyVerificationAccept
            10 -> MessageLikeEventContent.KeyVerificationKey
            11 -> MessageLikeEventContent.KeyVerificationMac
            12 -> MessageLikeEventContent.KeyVerificationDone
            13 -> MessageLikeEventContent.Poll(
                FfiConverterString.read(buf),
                )
            14 -> MessageLikeEventContent.ReactionContent(
                FfiConverterString.read(buf),
                )
            15 -> MessageLikeEventContent.RoomEncrypted
            16 -> MessageLikeEventContent.RoomMessage(
                FfiConverterTypeMessageType.read(buf),
                FfiConverterOptionalString.read(buf),
                )
            17 -> MessageLikeEventContent.RoomRedaction(
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalString.read(buf),
                )
            18 -> MessageLikeEventContent.Sticker
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MessageLikeEventContent) = when(value) {
        is MessageLikeEventContent.CallAnswer -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventContent.CallInvite -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventContent.RtcNotification -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeRtcNotificationType.allocationSize(value.`notificationType`)
                + FfiConverterTypeTimestamp.allocationSize(value.`expirationTs`)
            )
        }
        is MessageLikeEventContent.CallHangup -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventContent.CallCandidates -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventContent.KeyVerificationReady -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventContent.KeyVerificationStart -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventContent.KeyVerificationCancel -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventContent.KeyVerificationAccept -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventContent.KeyVerificationKey -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventContent.KeyVerificationMac -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventContent.KeyVerificationDone -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventContent.Poll -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`question`)
            )
        }
        is MessageLikeEventContent.ReactionContent -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`relatedEventId`)
            )
        }
        is MessageLikeEventContent.RoomEncrypted -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventContent.RoomMessage -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMessageType.allocationSize(value.`messageType`)
                + FfiConverterOptionalString.allocationSize(value.`inReplyToEventId`)
            )
        }
        is MessageLikeEventContent.RoomRedaction -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalString.allocationSize(value.`redactedEventId`)
                + FfiConverterOptionalString.allocationSize(value.`reason`)
            )
        }
        is MessageLikeEventContent.Sticker -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: MessageLikeEventContent, buf: ByteBuffer) {
        when(value) {
            is MessageLikeEventContent.CallAnswer -> {
                buf.putInt(1)
                Unit
            }
            is MessageLikeEventContent.CallInvite -> {
                buf.putInt(2)
                Unit
            }
            is MessageLikeEventContent.RtcNotification -> {
                buf.putInt(3)
                FfiConverterTypeRtcNotificationType.write(value.`notificationType`, buf)
                FfiConverterTypeTimestamp.write(value.`expirationTs`, buf)
                Unit
            }
            is MessageLikeEventContent.CallHangup -> {
                buf.putInt(4)
                Unit
            }
            is MessageLikeEventContent.CallCandidates -> {
                buf.putInt(5)
                Unit
            }
            is MessageLikeEventContent.KeyVerificationReady -> {
                buf.putInt(6)
                Unit
            }
            is MessageLikeEventContent.KeyVerificationStart -> {
                buf.putInt(7)
                Unit
            }
            is MessageLikeEventContent.KeyVerificationCancel -> {
                buf.putInt(8)
                Unit
            }
            is MessageLikeEventContent.KeyVerificationAccept -> {
                buf.putInt(9)
                Unit
            }
            is MessageLikeEventContent.KeyVerificationKey -> {
                buf.putInt(10)
                Unit
            }
            is MessageLikeEventContent.KeyVerificationMac -> {
                buf.putInt(11)
                Unit
            }
            is MessageLikeEventContent.KeyVerificationDone -> {
                buf.putInt(12)
                Unit
            }
            is MessageLikeEventContent.Poll -> {
                buf.putInt(13)
                FfiConverterString.write(value.`question`, buf)
                Unit
            }
            is MessageLikeEventContent.ReactionContent -> {
                buf.putInt(14)
                FfiConverterString.write(value.`relatedEventId`, buf)
                Unit
            }
            is MessageLikeEventContent.RoomEncrypted -> {
                buf.putInt(15)
                Unit
            }
            is MessageLikeEventContent.RoomMessage -> {
                buf.putInt(16)
                FfiConverterTypeMessageType.write(value.`messageType`, buf)
                FfiConverterOptionalString.write(value.`inReplyToEventId`, buf)
                Unit
            }
            is MessageLikeEventContent.RoomRedaction -> {
                buf.putInt(17)
                FfiConverterOptionalString.write(value.`redactedEventId`, buf)
                FfiConverterOptionalString.write(value.`reason`, buf)
                Unit
            }
            is MessageLikeEventContent.Sticker -> {
                buf.putInt(18)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MessageLikeEventType {
    
    object CallAnswer : MessageLikeEventType()
    
    
    object CallCandidates : MessageLikeEventType()
    
    
    object CallHangup : MessageLikeEventType()
    
    
    object CallInvite : MessageLikeEventType()
    
    
    object RtcNotification : MessageLikeEventType()
    
    
    object KeyVerificationAccept : MessageLikeEventType()
    
    
    object KeyVerificationCancel : MessageLikeEventType()
    
    
    object KeyVerificationDone : MessageLikeEventType()
    
    
    object KeyVerificationKey : MessageLikeEventType()
    
    
    object KeyVerificationMac : MessageLikeEventType()
    
    
    object KeyVerificationReady : MessageLikeEventType()
    
    
    object KeyVerificationStart : MessageLikeEventType()
    
    
    object PollEnd : MessageLikeEventType()
    
    
    object PollResponse : MessageLikeEventType()
    
    
    object PollStart : MessageLikeEventType()
    
    
    object Reaction : MessageLikeEventType()
    
    
    object RoomEncrypted : MessageLikeEventType()
    
    
    object RoomMessage : MessageLikeEventType()
    
    
    object RoomRedaction : MessageLikeEventType()
    
    
    object Sticker : MessageLikeEventType()
    
    
    object UnstablePollEnd : MessageLikeEventType()
    
    
    object UnstablePollResponse : MessageLikeEventType()
    
    
    object UnstablePollStart : MessageLikeEventType()
    
    
    data class Other(
        val v1: kotlin.String) : MessageLikeEventType() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeMessageLikeEventType : FfiConverterRustBuffer<MessageLikeEventType>{
    override fun read(buf: ByteBuffer): MessageLikeEventType {
        return when(buf.getInt()) {
            1 -> MessageLikeEventType.CallAnswer
            2 -> MessageLikeEventType.CallCandidates
            3 -> MessageLikeEventType.CallHangup
            4 -> MessageLikeEventType.CallInvite
            5 -> MessageLikeEventType.RtcNotification
            6 -> MessageLikeEventType.KeyVerificationAccept
            7 -> MessageLikeEventType.KeyVerificationCancel
            8 -> MessageLikeEventType.KeyVerificationDone
            9 -> MessageLikeEventType.KeyVerificationKey
            10 -> MessageLikeEventType.KeyVerificationMac
            11 -> MessageLikeEventType.KeyVerificationReady
            12 -> MessageLikeEventType.KeyVerificationStart
            13 -> MessageLikeEventType.PollEnd
            14 -> MessageLikeEventType.PollResponse
            15 -> MessageLikeEventType.PollStart
            16 -> MessageLikeEventType.Reaction
            17 -> MessageLikeEventType.RoomEncrypted
            18 -> MessageLikeEventType.RoomMessage
            19 -> MessageLikeEventType.RoomRedaction
            20 -> MessageLikeEventType.Sticker
            21 -> MessageLikeEventType.UnstablePollEnd
            22 -> MessageLikeEventType.UnstablePollResponse
            23 -> MessageLikeEventType.UnstablePollStart
            24 -> MessageLikeEventType.Other(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MessageLikeEventType) = when(value) {
        is MessageLikeEventType.CallAnswer -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventType.CallCandidates -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventType.CallHangup -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventType.CallInvite -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventType.RtcNotification -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventType.KeyVerificationAccept -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventType.KeyVerificationCancel -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventType.KeyVerificationDone -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventType.KeyVerificationKey -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventType.KeyVerificationMac -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventType.KeyVerificationReady -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventType.KeyVerificationStart -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventType.PollEnd -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventType.PollResponse -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventType.PollStart -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventType.Reaction -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventType.RoomEncrypted -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventType.RoomMessage -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventType.RoomRedaction -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventType.Sticker -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventType.UnstablePollEnd -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventType.UnstablePollResponse -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventType.UnstablePollStart -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MessageLikeEventType.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MessageLikeEventType, buf: ByteBuffer) {
        when(value) {
            is MessageLikeEventType.CallAnswer -> {
                buf.putInt(1)
                Unit
            }
            is MessageLikeEventType.CallCandidates -> {
                buf.putInt(2)
                Unit
            }
            is MessageLikeEventType.CallHangup -> {
                buf.putInt(3)
                Unit
            }
            is MessageLikeEventType.CallInvite -> {
                buf.putInt(4)
                Unit
            }
            is MessageLikeEventType.RtcNotification -> {
                buf.putInt(5)
                Unit
            }
            is MessageLikeEventType.KeyVerificationAccept -> {
                buf.putInt(6)
                Unit
            }
            is MessageLikeEventType.KeyVerificationCancel -> {
                buf.putInt(7)
                Unit
            }
            is MessageLikeEventType.KeyVerificationDone -> {
                buf.putInt(8)
                Unit
            }
            is MessageLikeEventType.KeyVerificationKey -> {
                buf.putInt(9)
                Unit
            }
            is MessageLikeEventType.KeyVerificationMac -> {
                buf.putInt(10)
                Unit
            }
            is MessageLikeEventType.KeyVerificationReady -> {
                buf.putInt(11)
                Unit
            }
            is MessageLikeEventType.KeyVerificationStart -> {
                buf.putInt(12)
                Unit
            }
            is MessageLikeEventType.PollEnd -> {
                buf.putInt(13)
                Unit
            }
            is MessageLikeEventType.PollResponse -> {
                buf.putInt(14)
                Unit
            }
            is MessageLikeEventType.PollStart -> {
                buf.putInt(15)
                Unit
            }
            is MessageLikeEventType.Reaction -> {
                buf.putInt(16)
                Unit
            }
            is MessageLikeEventType.RoomEncrypted -> {
                buf.putInt(17)
                Unit
            }
            is MessageLikeEventType.RoomMessage -> {
                buf.putInt(18)
                Unit
            }
            is MessageLikeEventType.RoomRedaction -> {
                buf.putInt(19)
                Unit
            }
            is MessageLikeEventType.Sticker -> {
                buf.putInt(20)
                Unit
            }
            is MessageLikeEventType.UnstablePollEnd -> {
                buf.putInt(21)
                Unit
            }
            is MessageLikeEventType.UnstablePollResponse -> {
                buf.putInt(22)
                Unit
            }
            is MessageLikeEventType.UnstablePollStart -> {
                buf.putInt(23)
                Unit
            }
            is MessageLikeEventType.Other -> {
                buf.putInt(24)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MessageType: Disposable  {
    
    data class Emote(
        val `content`: EmoteMessageContent) : MessageType() {
        companion object
    }
    
    data class Image(
        val `content`: ImageMessageContent) : MessageType() {
        companion object
    }
    
    data class Audio(
        val `content`: AudioMessageContent) : MessageType() {
        companion object
    }
    
    data class Video(
        val `content`: VideoMessageContent) : MessageType() {
        companion object
    }
    
    data class File(
        val `content`: FileMessageContent) : MessageType() {
        companion object
    }
    
    data class Gallery(
        val `content`: GalleryMessageContent) : MessageType() {
        companion object
    }
    
    data class Notice(
        val `content`: NoticeMessageContent) : MessageType() {
        companion object
    }
    
    data class Text(
        val `content`: TextMessageContent) : MessageType() {
        companion object
    }
    
    data class Location(
        val `content`: LocationContent) : MessageType() {
        companion object
    }
    
    data class Other(
        val `msgtype`: kotlin.String, 
        val `body`: kotlin.String) : MessageType() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MessageType.Emote -> {
                
        Disposable.destroy(this.`content`)
    
                
            }
            is MessageType.Image -> {
                
        Disposable.destroy(this.`content`)
    
                
            }
            is MessageType.Audio -> {
                
        Disposable.destroy(this.`content`)
    
                
            }
            is MessageType.Video -> {
                
        Disposable.destroy(this.`content`)
    
                
            }
            is MessageType.File -> {
                
        Disposable.destroy(this.`content`)
    
                
            }
            is MessageType.Gallery -> {
                
        Disposable.destroy(this.`content`)
    
                
            }
            is MessageType.Notice -> {
                
        Disposable.destroy(this.`content`)
    
                
            }
            is MessageType.Text -> {
                
        Disposable.destroy(this.`content`)
    
                
            }
            is MessageType.Location -> {
                
        Disposable.destroy(this.`content`)
    
                
            }
            is MessageType.Other -> {
                
        Disposable.destroy(this.`msgtype`)
    
        Disposable.destroy(this.`body`)
    
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

public object FfiConverterTypeMessageType : FfiConverterRustBuffer<MessageType>{
    override fun read(buf: ByteBuffer): MessageType {
        return when(buf.getInt()) {
            1 -> MessageType.Emote(
                FfiConverterTypeEmoteMessageContent.read(buf),
                )
            2 -> MessageType.Image(
                FfiConverterTypeImageMessageContent.read(buf),
                )
            3 -> MessageType.Audio(
                FfiConverterTypeAudioMessageContent.read(buf),
                )
            4 -> MessageType.Video(
                FfiConverterTypeVideoMessageContent.read(buf),
                )
            5 -> MessageType.File(
                FfiConverterTypeFileMessageContent.read(buf),
                )
            6 -> MessageType.Gallery(
                FfiConverterTypeGalleryMessageContent.read(buf),
                )
            7 -> MessageType.Notice(
                FfiConverterTypeNoticeMessageContent.read(buf),
                )
            8 -> MessageType.Text(
                FfiConverterTypeTextMessageContent.read(buf),
                )
            9 -> MessageType.Location(
                FfiConverterTypeLocationContent.read(buf),
                )
            10 -> MessageType.Other(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MessageType) = when(value) {
        is MessageType.Emote -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeEmoteMessageContent.allocationSize(value.`content`)
            )
        }
        is MessageType.Image -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeImageMessageContent.allocationSize(value.`content`)
            )
        }
        is MessageType.Audio -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAudioMessageContent.allocationSize(value.`content`)
            )
        }
        is MessageType.Video -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeVideoMessageContent.allocationSize(value.`content`)
            )
        }
        is MessageType.File -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeFileMessageContent.allocationSize(value.`content`)
            )
        }
        is MessageType.Gallery -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeGalleryMessageContent.allocationSize(value.`content`)
            )
        }
        is MessageType.Notice -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeNoticeMessageContent.allocationSize(value.`content`)
            )
        }
        is MessageType.Text -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTextMessageContent.allocationSize(value.`content`)
            )
        }
        is MessageType.Location -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeLocationContent.allocationSize(value.`content`)
            )
        }
        is MessageType.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`msgtype`)
                + FfiConverterString.allocationSize(value.`body`)
            )
        }
    }

    override fun write(value: MessageType, buf: ByteBuffer) {
        when(value) {
            is MessageType.Emote -> {
                buf.putInt(1)
                FfiConverterTypeEmoteMessageContent.write(value.`content`, buf)
                Unit
            }
            is MessageType.Image -> {
                buf.putInt(2)
                FfiConverterTypeImageMessageContent.write(value.`content`, buf)
                Unit
            }
            is MessageType.Audio -> {
                buf.putInt(3)
                FfiConverterTypeAudioMessageContent.write(value.`content`, buf)
                Unit
            }
            is MessageType.Video -> {
                buf.putInt(4)
                FfiConverterTypeVideoMessageContent.write(value.`content`, buf)
                Unit
            }
            is MessageType.File -> {
                buf.putInt(5)
                FfiConverterTypeFileMessageContent.write(value.`content`, buf)
                Unit
            }
            is MessageType.Gallery -> {
                buf.putInt(6)
                FfiConverterTypeGalleryMessageContent.write(value.`content`, buf)
                Unit
            }
            is MessageType.Notice -> {
                buf.putInt(7)
                FfiConverterTypeNoticeMessageContent.write(value.`content`, buf)
                Unit
            }
            is MessageType.Text -> {
                buf.putInt(8)
                FfiConverterTypeTextMessageContent.write(value.`content`, buf)
                Unit
            }
            is MessageType.Location -> {
                buf.putInt(9)
                FfiConverterTypeLocationContent.write(value.`content`, buf)
                Unit
            }
            is MessageType.Other -> {
                buf.putInt(10)
                FfiConverterString.write(value.`msgtype`, buf)
                FfiConverterString.write(value.`body`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class MsgLikeKind: Disposable  {
    
    /**
     * An `m.room.message` event or extensible event, including edits.
     */
    data class Message(
        val `content`: MessageContent) : MsgLikeKind() {
        companion object
    }
    
    /**
     * An `m.sticker` event.
     */
    data class Sticker(
        val `body`: kotlin.String, 
        val `info`: ImageInfo, 
        val `source`: MediaSource) : MsgLikeKind() {
        companion object
    }
    
    /**
     * An `m.poll.start` event.
     */
    data class Poll(
        val `question`: kotlin.String, 
        val `kind`: PollKind, 
        val `maxSelections`: kotlin.ULong, 
        val `answers`: List<PollAnswer>, 
        val `votes`: Map<kotlin.String, List<kotlin.String>>, 
        val `endTime`: Timestamp?, 
        val `hasBeenEdited`: kotlin.Boolean) : MsgLikeKind() {
        companion object
    }
    
    /**
     * A redacted message.
     */
    object Redacted : MsgLikeKind()
    
    
    /**
     * An `m.room.encrypted` event that could not be decrypted.
     */
    data class UnableToDecrypt(
        val `msg`: EncryptedMessage) : MsgLikeKind() {
        companion object
    }
    
    /**
     * A custom message like event.
     */
    data class Other(
        val `eventType`: MessageLikeEventType) : MsgLikeKind() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MsgLikeKind.Message -> {
                
        Disposable.destroy(this.`content`)
    
                
            }
            is MsgLikeKind.Sticker -> {
                
        Disposable.destroy(this.`body`)
    
        Disposable.destroy(this.`info`)
    
        Disposable.destroy(this.`source`)
    
                
            }
            is MsgLikeKind.Poll -> {
                
        Disposable.destroy(this.`question`)
    
        Disposable.destroy(this.`kind`)
    
        Disposable.destroy(this.`maxSelections`)
    
        Disposable.destroy(this.`answers`)
    
        Disposable.destroy(this.`votes`)
    
        Disposable.destroy(this.`endTime`)
    
        Disposable.destroy(this.`hasBeenEdited`)
    
                
            }
            is MsgLikeKind.Redacted -> {// Nothing to destroy
            }
            is MsgLikeKind.UnableToDecrypt -> {
                
        Disposable.destroy(this.`msg`)
    
                
            }
            is MsgLikeKind.Other -> {
                
        Disposable.destroy(this.`eventType`)
    
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

public object FfiConverterTypeMsgLikeKind : FfiConverterRustBuffer<MsgLikeKind>{
    override fun read(buf: ByteBuffer): MsgLikeKind {
        return when(buf.getInt()) {
            1 -> MsgLikeKind.Message(
                FfiConverterTypeMessageContent.read(buf),
                )
            2 -> MsgLikeKind.Sticker(
                FfiConverterString.read(buf),
                FfiConverterTypeImageInfo.read(buf),
                FfiConverterTypeMediaSource.read(buf),
                )
            3 -> MsgLikeKind.Poll(
                FfiConverterString.read(buf),
                FfiConverterTypePollKind.read(buf),
                FfiConverterULong.read(buf),
                FfiConverterSequenceTypePollAnswer.read(buf),
                FfiConverterMapStringSequenceString.read(buf),
                FfiConverterOptionalTypeTimestamp.read(buf),
                FfiConverterBoolean.read(buf),
                )
            4 -> MsgLikeKind.Redacted
            5 -> MsgLikeKind.UnableToDecrypt(
                FfiConverterTypeEncryptedMessage.read(buf),
                )
            6 -> MsgLikeKind.Other(
                FfiConverterTypeMessageLikeEventType.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MsgLikeKind) = when(value) {
        is MsgLikeKind.Message -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMessageContent.allocationSize(value.`content`)
            )
        }
        is MsgLikeKind.Sticker -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`body`)
                + FfiConverterTypeImageInfo.allocationSize(value.`info`)
                + FfiConverterTypeMediaSource.allocationSize(value.`source`)
            )
        }
        is MsgLikeKind.Poll -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`question`)
                + FfiConverterTypePollKind.allocationSize(value.`kind`)
                + FfiConverterULong.allocationSize(value.`maxSelections`)
                + FfiConverterSequenceTypePollAnswer.allocationSize(value.`answers`)
                + FfiConverterMapStringSequenceString.allocationSize(value.`votes`)
                + FfiConverterOptionalTypeTimestamp.allocationSize(value.`endTime`)
                + FfiConverterBoolean.allocationSize(value.`hasBeenEdited`)
            )
        }
        is MsgLikeKind.Redacted -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is MsgLikeKind.UnableToDecrypt -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeEncryptedMessage.allocationSize(value.`msg`)
            )
        }
        is MsgLikeKind.Other -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMessageLikeEventType.allocationSize(value.`eventType`)
            )
        }
    }

    override fun write(value: MsgLikeKind, buf: ByteBuffer) {
        when(value) {
            is MsgLikeKind.Message -> {
                buf.putInt(1)
                FfiConverterTypeMessageContent.write(value.`content`, buf)
                Unit
            }
            is MsgLikeKind.Sticker -> {
                buf.putInt(2)
                FfiConverterString.write(value.`body`, buf)
                FfiConverterTypeImageInfo.write(value.`info`, buf)
                FfiConverterTypeMediaSource.write(value.`source`, buf)
                Unit
            }
            is MsgLikeKind.Poll -> {
                buf.putInt(3)
                FfiConverterString.write(value.`question`, buf)
                FfiConverterTypePollKind.write(value.`kind`, buf)
                FfiConverterULong.write(value.`maxSelections`, buf)
                FfiConverterSequenceTypePollAnswer.write(value.`answers`, buf)
                FfiConverterMapStringSequenceString.write(value.`votes`, buf)
                FfiConverterOptionalTypeTimestamp.write(value.`endTime`, buf)
                FfiConverterBoolean.write(value.`hasBeenEdited`, buf)
                Unit
            }
            is MsgLikeKind.Redacted -> {
                buf.putInt(4)
                Unit
            }
            is MsgLikeKind.UnableToDecrypt -> {
                buf.putInt(5)
                FfiConverterTypeEncryptedMessage.write(value.`msg`, buf)
                Unit
            }
            is MsgLikeKind.Other -> {
                buf.putInt(6)
                FfiConverterTypeMessageLikeEventType.write(value.`eventType`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class NotificationEvent: Disposable  {
    
    data class Timeline(
        val `event`: TimelineEvent) : NotificationEvent() {
        companion object
    }
    
    data class Invite(
        val `sender`: kotlin.String) : NotificationEvent() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is NotificationEvent.Timeline -> {
                
        Disposable.destroy(this.`event`)
    
                
            }
            is NotificationEvent.Invite -> {
                
        Disposable.destroy(this.`sender`)
    
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

public object FfiConverterTypeNotificationEvent : FfiConverterRustBuffer<NotificationEvent>{
    override fun read(buf: ByteBuffer): NotificationEvent {
        return when(buf.getInt()) {
            1 -> NotificationEvent.Timeline(
                FfiConverterTypeTimelineEvent.read(buf),
                )
            2 -> NotificationEvent.Invite(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: NotificationEvent) = when(value) {
        is NotificationEvent.Timeline -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTimelineEvent.allocationSize(value.`event`)
            )
        }
        is NotificationEvent.Invite -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`sender`)
            )
        }
    }

    override fun write(value: NotificationEvent, buf: ByteBuffer) {
        when(value) {
            is NotificationEvent.Timeline -> {
                buf.putInt(1)
                FfiConverterTypeTimelineEvent.write(value.`event`, buf)
                Unit
            }
            is NotificationEvent.Invite -> {
                buf.putInt(2)
                FfiConverterString.write(value.`sender`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class NotificationProcessSetup: Disposable  {
    
    object MultipleProcesses : NotificationProcessSetup()
    
    
    data class SingleProcess(
        val `syncService`: SyncService) : NotificationProcessSetup() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is NotificationProcessSetup.MultipleProcesses -> {// Nothing to destroy
            }
            is NotificationProcessSetup.SingleProcess -> {
                
        Disposable.destroy(this.`syncService`)
    
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

public object FfiConverterTypeNotificationProcessSetup : FfiConverterRustBuffer<NotificationProcessSetup>{
    override fun read(buf: ByteBuffer): NotificationProcessSetup {
        return when(buf.getInt()) {
            1 -> NotificationProcessSetup.MultipleProcesses
            2 -> NotificationProcessSetup.SingleProcess(
                FfiConverterTypeSyncService.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: NotificationProcessSetup) = when(value) {
        is NotificationProcessSetup.MultipleProcesses -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is NotificationProcessSetup.SingleProcess -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSyncService.allocationSize(value.`syncService`)
            )
        }
    }

    override fun write(value: NotificationProcessSetup, buf: ByteBuffer) {
        when(value) {
            is NotificationProcessSetup.MultipleProcesses -> {
                buf.putInt(1)
                Unit
            }
            is NotificationProcessSetup.SingleProcess -> {
                buf.putInt(2)
                FfiConverterTypeSyncService.write(value.`syncService`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class NotificationSettingsException: kotlin.Exception() {
    
    class Generic(
        
        val `msg`: kotlin.String
        ) : NotificationSettingsException() {
        override val message
            get() = "msg=${ `msg` }"
    }
    
    /**
     * Invalid parameter.
     */
    class InvalidParameter(
        
        val `msg`: kotlin.String
        ) : NotificationSettingsException() {
        override val message
            get() = "msg=${ `msg` }"
    }
    
    /**
     * Invalid room id.
     */
    class InvalidRoomId(
        
        val `roomId`: kotlin.String
        ) : NotificationSettingsException() {
        override val message
            get() = "roomId=${ `roomId` }"
    }
    
    /**
     * Rule not found
     */
    class RuleNotFound(
        
        val `ruleId`: kotlin.String
        ) : NotificationSettingsException() {
        override val message
            get() = "ruleId=${ `ruleId` }"
    }
    
    /**
     * Unable to add push rule.
     */
    class UnableToAddPushRule(
        ) : NotificationSettingsException() {
        override val message
            get() = ""
    }
    
    /**
     * Unable to remove push rule.
     */
    class UnableToRemovePushRule(
        ) : NotificationSettingsException() {
        override val message
            get() = ""
    }
    
    /**
     * Unable to save the push rules
     */
    class UnableToSavePushRules(
        ) : NotificationSettingsException() {
        override val message
            get() = ""
    }
    
    /**
     * Unable to update push rule.
     */
    class UnableToUpdatePushRule(
        ) : NotificationSettingsException() {
        override val message
            get() = ""
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<NotificationSettingsException> {
        override fun lift(error_buf: RustBuffer.ByValue): NotificationSettingsException = FfiConverterTypeNotificationSettingsError.lift(error_buf)
    }

    
}

public object FfiConverterTypeNotificationSettingsError : FfiConverterRustBuffer<NotificationSettingsException> {
    override fun read(buf: ByteBuffer): NotificationSettingsException {
        

        return when(buf.getInt()) {
            1 -> NotificationSettingsException.Generic(
                FfiConverterString.read(buf),
                )
            2 -> NotificationSettingsException.InvalidParameter(
                FfiConverterString.read(buf),
                )
            3 -> NotificationSettingsException.InvalidRoomId(
                FfiConverterString.read(buf),
                )
            4 -> NotificationSettingsException.RuleNotFound(
                FfiConverterString.read(buf),
                )
            5 -> NotificationSettingsException.UnableToAddPushRule()
            6 -> NotificationSettingsException.UnableToRemovePushRule()
            7 -> NotificationSettingsException.UnableToSavePushRules()
            8 -> NotificationSettingsException.UnableToUpdatePushRule()
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: NotificationSettingsException): ULong {
        return when(value) {
            is NotificationSettingsException.Generic -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`msg`)
            )
            is NotificationSettingsException.InvalidParameter -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`msg`)
            )
            is NotificationSettingsException.InvalidRoomId -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`roomId`)
            )
            is NotificationSettingsException.RuleNotFound -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`ruleId`)
            )
            is NotificationSettingsException.UnableToAddPushRule -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is NotificationSettingsException.UnableToRemovePushRule -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is NotificationSettingsException.UnableToSavePushRules -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is NotificationSettingsException.UnableToUpdatePushRule -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
        }
    }

    override fun write(value: NotificationSettingsException, buf: ByteBuffer) {
        when(value) {
            is NotificationSettingsException.Generic -> {
                buf.putInt(1)
                FfiConverterString.write(value.`msg`, buf)
                Unit
            }
            is NotificationSettingsException.InvalidParameter -> {
                buf.putInt(2)
                FfiConverterString.write(value.`msg`, buf)
                Unit
            }
            is NotificationSettingsException.InvalidRoomId -> {
                buf.putInt(3)
                FfiConverterString.write(value.`roomId`, buf)
                Unit
            }
            is NotificationSettingsException.RuleNotFound -> {
                buf.putInt(4)
                FfiConverterString.write(value.`ruleId`, buf)
                Unit
            }
            is NotificationSettingsException.UnableToAddPushRule -> {
                buf.putInt(5)
                Unit
            }
            is NotificationSettingsException.UnableToRemovePushRule -> {
                buf.putInt(6)
                Unit
            }
            is NotificationSettingsException.UnableToSavePushRules -> {
                buf.putInt(7)
                Unit
            }
            is NotificationSettingsException.UnableToUpdatePushRule -> {
                buf.putInt(8)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class NotificationStatus: Disposable  {
    
    /**
     * The event has been found and was not filtered out.
     */
    data class Event(
        val `item`: NotificationItem) : NotificationStatus() {
        companion object
    }
    
    /**
     * The event couldn't be found in the network queries used to find it.
     */
    object EventNotFound : NotificationStatus()
    
    
    /**
     * The event has been filtered out, either because of the user's push
     * rules, or because the user which triggered it is ignored by the
     * current user.
     */
    object EventFilteredOut : NotificationStatus()
    
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is NotificationStatus.Event -> {
                
        Disposable.destroy(this.`item`)
    
                
            }
            is NotificationStatus.EventNotFound -> {// Nothing to destroy
            }
            is NotificationStatus.EventFilteredOut -> {// Nothing to destroy
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

public object FfiConverterTypeNotificationStatus : FfiConverterRustBuffer<NotificationStatus>{
    override fun read(buf: ByteBuffer): NotificationStatus {
        return when(buf.getInt()) {
            1 -> NotificationStatus.Event(
                FfiConverterTypeNotificationItem.read(buf),
                )
            2 -> NotificationStatus.EventNotFound
            3 -> NotificationStatus.EventFilteredOut
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: NotificationStatus) = when(value) {
        is NotificationStatus.Event -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeNotificationItem.allocationSize(value.`item`)
            )
        }
        is NotificationStatus.EventNotFound -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is NotificationStatus.EventFilteredOut -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: NotificationStatus, buf: ByteBuffer) {
        when(value) {
            is NotificationStatus.Event -> {
                buf.putInt(1)
                FfiConverterTypeNotificationItem.write(value.`item`, buf)
                Unit
            }
            is NotificationStatus.EventNotFound -> {
                buf.putInt(2)
                Unit
            }
            is NotificationStatus.EventFilteredOut -> {
                buf.putInt(3)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class OidcException(message: String): kotlin.Exception(message) {
        
        class NotSupported(message: String) : OidcException(message)
        
        class MetadataInvalid(message: String) : OidcException(message)
        
        class CallbackUrlInvalid(message: String) : OidcException(message)
        
        class Cancelled(message: String) : OidcException(message)
        
        class Generic(message: String) : OidcException(message)
        

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<OidcException> {
        override fun lift(error_buf: RustBuffer.ByValue): OidcException = FfiConverterTypeOidcError.lift(error_buf)
    }
}

public object FfiConverterTypeOidcError : FfiConverterRustBuffer<OidcException> {
    override fun read(buf: ByteBuffer): OidcException {
        
            return when(buf.getInt()) {
            1 -> OidcException.NotSupported(FfiConverterString.read(buf))
            2 -> OidcException.MetadataInvalid(FfiConverterString.read(buf))
            3 -> OidcException.CallbackUrlInvalid(FfiConverterString.read(buf))
            4 -> OidcException.Cancelled(FfiConverterString.read(buf))
            5 -> OidcException.Generic(FfiConverterString.read(buf))
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
        
    }

    override fun allocationSize(value: OidcException): ULong {
        return 4UL
    }

    override fun write(value: OidcException, buf: ByteBuffer) {
        when(value) {
            is OidcException.NotSupported -> {
                buf.putInt(1)
                Unit
            }
            is OidcException.MetadataInvalid -> {
                buf.putInt(2)
                Unit
            }
            is OidcException.CallbackUrlInvalid -> {
                buf.putInt(3)
                Unit
            }
            is OidcException.Cancelled -> {
                buf.putInt(4)
                Unit
            }
            is OidcException.Generic -> {
                buf.putInt(5)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class OidcPrompt {
    
    /**
     * The Authorization Server should prompt the End-User to create a user
     * account.
     *
     * Defined in [Initiating User Registration via OpenID Connect](https://openid.net/specs/openid-connect-prompt-create-1_0.html).
     */
    object Create : OidcPrompt()
    
    
    /**
     * The Authorization Server should prompt the End-User for
     * reauthentication.
     */
    object Login : OidcPrompt()
    
    
    /**
     * The Authorization Server should prompt the End-User for consent before
     * returning information to the Client.
     */
    object Consent : OidcPrompt()
    
    
    /**
     * An unknown value.
     */
    data class Unknown(
        val `value`: kotlin.String) : OidcPrompt() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeOidcPrompt : FfiConverterRustBuffer<OidcPrompt>{
    override fun read(buf: ByteBuffer): OidcPrompt {
        return when(buf.getInt()) {
            1 -> OidcPrompt.Create
            2 -> OidcPrompt.Login
            3 -> OidcPrompt.Consent
            4 -> OidcPrompt.Unknown(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: OidcPrompt) = when(value) {
        is OidcPrompt.Create -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is OidcPrompt.Login -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is OidcPrompt.Consent -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is OidcPrompt.Unknown -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: OidcPrompt, buf: ByteBuffer) {
        when(value) {
            is OidcPrompt.Create -> {
                buf.putInt(1)
                Unit
            }
            is OidcPrompt.Login -> {
                buf.putInt(2)
                Unit
            }
            is OidcPrompt.Consent -> {
                buf.putInt(3)
                Unit
            }
            is OidcPrompt.Unknown -> {
                buf.putInt(4)
                FfiConverterString.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class OtherState {
    
    object PolicyRuleRoom : OtherState()
    
    
    object PolicyRuleServer : OtherState()
    
    
    object PolicyRuleUser : OtherState()
    
    
    object RoomAliases : OtherState()
    
    
    data class RoomAvatar(
        val `url`: kotlin.String?) : OtherState() {
        companion object
    }
    
    object RoomCanonicalAlias : OtherState()
    
    
    object RoomCreate : OtherState()
    
    
    object RoomEncryption : OtherState()
    
    
    object RoomGuestAccess : OtherState()
    
    
    object RoomHistoryVisibility : OtherState()
    
    
    object RoomJoinRules : OtherState()
    
    
    data class RoomName(
        val `name`: kotlin.String?) : OtherState() {
        companion object
    }
    
    data class RoomPinnedEvents(
        val `change`: RoomPinnedEventsChange) : OtherState() {
        companion object
    }
    
    data class RoomPowerLevels(
        val `users`: Map<kotlin.String, kotlin.Long>, 
        val `previous`: Map<kotlin.String, kotlin.Long>?) : OtherState() {
        companion object
    }
    
    object RoomServerAcl : OtherState()
    
    
    data class RoomThirdPartyInvite(
        val `displayName`: kotlin.String?) : OtherState() {
        companion object
    }
    
    object RoomTombstone : OtherState()
    
    
    data class RoomTopic(
        val `topic`: kotlin.String?) : OtherState() {
        companion object
    }
    
    object SpaceChild : OtherState()
    
    
    object SpaceParent : OtherState()
    
    
    data class Custom(
        val `eventType`: kotlin.String) : OtherState() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeOtherState : FfiConverterRustBuffer<OtherState>{
    override fun read(buf: ByteBuffer): OtherState {
        return when(buf.getInt()) {
            1 -> OtherState.PolicyRuleRoom
            2 -> OtherState.PolicyRuleServer
            3 -> OtherState.PolicyRuleUser
            4 -> OtherState.RoomAliases
            5 -> OtherState.RoomAvatar(
                FfiConverterOptionalString.read(buf),
                )
            6 -> OtherState.RoomCanonicalAlias
            7 -> OtherState.RoomCreate
            8 -> OtherState.RoomEncryption
            9 -> OtherState.RoomGuestAccess
            10 -> OtherState.RoomHistoryVisibility
            11 -> OtherState.RoomJoinRules
            12 -> OtherState.RoomName(
                FfiConverterOptionalString.read(buf),
                )
            13 -> OtherState.RoomPinnedEvents(
                FfiConverterTypeRoomPinnedEventsChange.read(buf),
                )
            14 -> OtherState.RoomPowerLevels(
                FfiConverterMapStringLong.read(buf),
                FfiConverterOptionalMapStringLong.read(buf),
                )
            15 -> OtherState.RoomServerAcl
            16 -> OtherState.RoomThirdPartyInvite(
                FfiConverterOptionalString.read(buf),
                )
            17 -> OtherState.RoomTombstone
            18 -> OtherState.RoomTopic(
                FfiConverterOptionalString.read(buf),
                )
            19 -> OtherState.SpaceChild
            20 -> OtherState.SpaceParent
            21 -> OtherState.Custom(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: OtherState) = when(value) {
        is OtherState.PolicyRuleRoom -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is OtherState.PolicyRuleServer -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is OtherState.PolicyRuleUser -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is OtherState.RoomAliases -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is OtherState.RoomAvatar -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalString.allocationSize(value.`url`)
            )
        }
        is OtherState.RoomCanonicalAlias -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is OtherState.RoomCreate -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is OtherState.RoomEncryption -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is OtherState.RoomGuestAccess -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is OtherState.RoomHistoryVisibility -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is OtherState.RoomJoinRules -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is OtherState.RoomName -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalString.allocationSize(value.`name`)
            )
        }
        is OtherState.RoomPinnedEvents -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeRoomPinnedEventsChange.allocationSize(value.`change`)
            )
        }
        is OtherState.RoomPowerLevels -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterMapStringLong.allocationSize(value.`users`)
                + FfiConverterOptionalMapStringLong.allocationSize(value.`previous`)
            )
        }
        is OtherState.RoomServerAcl -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is OtherState.RoomThirdPartyInvite -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalString.allocationSize(value.`displayName`)
            )
        }
        is OtherState.RoomTombstone -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is OtherState.RoomTopic -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalString.allocationSize(value.`topic`)
            )
        }
        is OtherState.SpaceChild -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is OtherState.SpaceParent -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is OtherState.Custom -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`eventType`)
            )
        }
    }

    override fun write(value: OtherState, buf: ByteBuffer) {
        when(value) {
            is OtherState.PolicyRuleRoom -> {
                buf.putInt(1)
                Unit
            }
            is OtherState.PolicyRuleServer -> {
                buf.putInt(2)
                Unit
            }
            is OtherState.PolicyRuleUser -> {
                buf.putInt(3)
                Unit
            }
            is OtherState.RoomAliases -> {
                buf.putInt(4)
                Unit
            }
            is OtherState.RoomAvatar -> {
                buf.putInt(5)
                FfiConverterOptionalString.write(value.`url`, buf)
                Unit
            }
            is OtherState.RoomCanonicalAlias -> {
                buf.putInt(6)
                Unit
            }
            is OtherState.RoomCreate -> {
                buf.putInt(7)
                Unit
            }
            is OtherState.RoomEncryption -> {
                buf.putInt(8)
                Unit
            }
            is OtherState.RoomGuestAccess -> {
                buf.putInt(9)
                Unit
            }
            is OtherState.RoomHistoryVisibility -> {
                buf.putInt(10)
                Unit
            }
            is OtherState.RoomJoinRules -> {
                buf.putInt(11)
                Unit
            }
            is OtherState.RoomName -> {
                buf.putInt(12)
                FfiConverterOptionalString.write(value.`name`, buf)
                Unit
            }
            is OtherState.RoomPinnedEvents -> {
                buf.putInt(13)
                FfiConverterTypeRoomPinnedEventsChange.write(value.`change`, buf)
                Unit
            }
            is OtherState.RoomPowerLevels -> {
                buf.putInt(14)
                FfiConverterMapStringLong.write(value.`users`, buf)
                FfiConverterOptionalMapStringLong.write(value.`previous`, buf)
                Unit
            }
            is OtherState.RoomServerAcl -> {
                buf.putInt(15)
                Unit
            }
            is OtherState.RoomThirdPartyInvite -> {
                buf.putInt(16)
                FfiConverterOptionalString.write(value.`displayName`, buf)
                Unit
            }
            is OtherState.RoomTombstone -> {
                buf.putInt(17)
                Unit
            }
            is OtherState.RoomTopic -> {
                buf.putInt(18)
                FfiConverterOptionalString.write(value.`topic`, buf)
                Unit
            }
            is OtherState.SpaceChild -> {
                buf.putInt(19)
                Unit
            }
            is OtherState.SpaceParent -> {
                buf.putInt(20)
                Unit
            }
            is OtherState.Custom -> {
                buf.putInt(21)
                FfiConverterString.write(value.`eventType`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class ParseException(message: String): kotlin.Exception(message) {
        
        class EmptyHost(message: String) : ParseException(message)
        
        class IdnaException(message: String) : ParseException(message)
        
        class InvalidPort(message: String) : ParseException(message)
        
        class InvalidIpv4Address(message: String) : ParseException(message)
        
        class InvalidIpv6Address(message: String) : ParseException(message)
        
        class InvalidDomainCharacter(message: String) : ParseException(message)
        
        class RelativeUrlWithoutBase(message: String) : ParseException(message)
        
        class RelativeUrlWithCannotBeABaseBase(message: String) : ParseException(message)
        
        class SetHostOnCannotBeABaseUrl(message: String) : ParseException(message)
        
        class Overflow(message: String) : ParseException(message)
        
        class Other(message: String) : ParseException(message)
        

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<ParseException> {
        override fun lift(error_buf: RustBuffer.ByValue): ParseException = FfiConverterTypeParseError.lift(error_buf)
    }
}

public object FfiConverterTypeParseError : FfiConverterRustBuffer<ParseException> {
    override fun read(buf: ByteBuffer): ParseException {
        
            return when(buf.getInt()) {
            1 -> ParseException.EmptyHost(FfiConverterString.read(buf))
            2 -> ParseException.IdnaException(FfiConverterString.read(buf))
            3 -> ParseException.InvalidPort(FfiConverterString.read(buf))
            4 -> ParseException.InvalidIpv4Address(FfiConverterString.read(buf))
            5 -> ParseException.InvalidIpv6Address(FfiConverterString.read(buf))
            6 -> ParseException.InvalidDomainCharacter(FfiConverterString.read(buf))
            7 -> ParseException.RelativeUrlWithoutBase(FfiConverterString.read(buf))
            8 -> ParseException.RelativeUrlWithCannotBeABaseBase(FfiConverterString.read(buf))
            9 -> ParseException.SetHostOnCannotBeABaseUrl(FfiConverterString.read(buf))
            10 -> ParseException.Overflow(FfiConverterString.read(buf))
            11 -> ParseException.Other(FfiConverterString.read(buf))
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
        
    }

    override fun allocationSize(value: ParseException): ULong {
        return 4UL
    }

    override fun write(value: ParseException, buf: ByteBuffer) {
        when(value) {
            is ParseException.EmptyHost -> {
                buf.putInt(1)
                Unit
            }
            is ParseException.IdnaException -> {
                buf.putInt(2)
                Unit
            }
            is ParseException.InvalidPort -> {
                buf.putInt(3)
                Unit
            }
            is ParseException.InvalidIpv4Address -> {
                buf.putInt(4)
                Unit
            }
            is ParseException.InvalidIpv6Address -> {
                buf.putInt(5)
                Unit
            }
            is ParseException.InvalidDomainCharacter -> {
                buf.putInt(6)
                Unit
            }
            is ParseException.RelativeUrlWithoutBase -> {
                buf.putInt(7)
                Unit
            }
            is ParseException.RelativeUrlWithCannotBeABaseBase -> {
                buf.putInt(8)
                Unit
            }
            is ParseException.SetHostOnCannotBeABaseUrl -> {
                buf.putInt(9)
                Unit
            }
            is ParseException.Overflow -> {
                buf.putInt(10)
                Unit
            }
            is ParseException.Other -> {
                buf.putInt(11)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




enum class PollKind {
    
    DISCLOSED,
    UNDISCLOSED;
    companion object
}


public object FfiConverterTypePollKind: FfiConverterRustBuffer<PollKind> {
    override fun read(buf: ByteBuffer) = try {
        PollKind.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: PollKind) = 4UL

    override fun write(value: PollKind, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class PowerLevel {
    
    /**
     * The user is a room creator and has infinite power level.
     *
     * This power level was introduced in room version 12.
     */
    object Infinite : PowerLevel()
    
    
    /**
     * The user has the given power level.
     */
    data class Value(
        val `value`: kotlin.Long) : PowerLevel() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypePowerLevel : FfiConverterRustBuffer<PowerLevel>{
    override fun read(buf: ByteBuffer): PowerLevel {
        return when(buf.getInt()) {
            1 -> PowerLevel.Infinite
            2 -> PowerLevel.Value(
                FfiConverterLong.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PowerLevel) = when(value) {
        is PowerLevel.Infinite -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is PowerLevel.Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterLong.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: PowerLevel, buf: ByteBuffer) {
        when(value) {
            is PowerLevel.Infinite -> {
                buf.putInt(1)
                Unit
            }
            is PowerLevel.Value -> {
                buf.putInt(2)
                FfiConverterLong.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ProfileDetails {
    
    object Unavailable : ProfileDetails()
    
    
    object Pending : ProfileDetails()
    
    
    data class Ready(
        val `displayName`: kotlin.String?, 
        val `displayNameAmbiguous`: kotlin.Boolean, 
        val `avatarUrl`: kotlin.String?) : ProfileDetails() {
        companion object
    }
    
    data class Error(
        val `message`: kotlin.String) : ProfileDetails() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeProfileDetails : FfiConverterRustBuffer<ProfileDetails>{
    override fun read(buf: ByteBuffer): ProfileDetails {
        return when(buf.getInt()) {
            1 -> ProfileDetails.Unavailable
            2 -> ProfileDetails.Pending
            3 -> ProfileDetails.Ready(
                FfiConverterOptionalString.read(buf),
                FfiConverterBoolean.read(buf),
                FfiConverterOptionalString.read(buf),
                )
            4 -> ProfileDetails.Error(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ProfileDetails) = when(value) {
        is ProfileDetails.Unavailable -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ProfileDetails.Pending -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ProfileDetails.Ready -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalString.allocationSize(value.`displayName`)
                + FfiConverterBoolean.allocationSize(value.`displayNameAmbiguous`)
                + FfiConverterOptionalString.allocationSize(value.`avatarUrl`)
            )
        }
        is ProfileDetails.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`message`)
            )
        }
    }

    override fun write(value: ProfileDetails, buf: ByteBuffer) {
        when(value) {
            is ProfileDetails.Unavailable -> {
                buf.putInt(1)
                Unit
            }
            is ProfileDetails.Pending -> {
                buf.putInt(2)
                Unit
            }
            is ProfileDetails.Ready -> {
                buf.putInt(3)
                FfiConverterOptionalString.write(value.`displayName`, buf)
                FfiConverterBoolean.write(value.`displayNameAmbiguous`, buf)
                FfiConverterOptionalString.write(value.`avatarUrl`, buf)
                Unit
            }
            is ProfileDetails.Error -> {
                buf.putInt(4)
                FfiConverterString.write(value.`message`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class PublicRoomJoinRule {
    
    PUBLIC,
    KNOCK,
    RESTRICTED,
    KNOCK_RESTRICTED,
    INVITE;
    companion object
}


public object FfiConverterTypePublicRoomJoinRule: FfiConverterRustBuffer<PublicRoomJoinRule> {
    override fun read(buf: ByteBuffer) = try {
        PublicRoomJoinRule.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: PublicRoomJoinRule) = 4UL

    override fun write(value: PublicRoomJoinRule, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class PushCondition {
    
    /**
     * A glob pattern match on a field of the event.
     */
    data class EventMatch(
        /**
         * The [dot-separated path] of the property of the event to match.
         *
         * [dot-separated path]: https://spec.matrix.org/latest/appendices/#dot-separated-property-paths
         */
        val `key`: kotlin.String, 
        /**
         * The glob-style pattern to match against.
         *
         * Patterns with no special glob characters should be treated as having
         * asterisks prepended and appended when testing the condition.
         */
        val `pattern`: kotlin.String) : PushCondition() {
        companion object
    }
    
    /**
     * Matches unencrypted messages where `content.body` contains the owner's
     * display name in that room.
     */
    object ContainsDisplayName : PushCondition()
    
    
    /**
     * Matches the current number of members in the room.
     */
    data class RoomMemberCount(
        val `prefix`: ComparisonOperator, 
        val `count`: kotlin.ULong) : PushCondition() {
        companion object
    }
    
    /**
     * Takes into account the current power levels in the room, ensuring the
     * sender of the event has high enough power to trigger the
     * notification.
     */
    data class SenderNotificationPermission(
        /**
         * The field in the power level event the user needs a minimum power
         * level for.
         *
         * Fields must be specified under the `notifications` property in the
         * power level event's `content`.
         */
        val `key`: kotlin.String) : PushCondition() {
        companion object
    }
    
    /**
     * Exact value match on a property of the event.
     */
    data class EventPropertyIs(
        /**
         * The [dot-separated path] of the property of the event to match.
         *
         * [dot-separated path]: https://spec.matrix.org/latest/appendices/#dot-separated-property-paths
         */
        val `key`: kotlin.String, 
        /**
         * The value to match against.
         */
        val `value`: JsonValue) : PushCondition() {
        companion object
    }
    
    /**
     * Exact value match on a value in an array property of the event.
     */
    data class EventPropertyContains(
        /**
         * The [dot-separated path] of the property of the event to match.
         *
         * [dot-separated path]: https://spec.matrix.org/latest/appendices/#dot-separated-property-paths
         */
        val `key`: kotlin.String, 
        /**
         * The value to match against.
         */
        val `value`: JsonValue) : PushCondition() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypePushCondition : FfiConverterRustBuffer<PushCondition>{
    override fun read(buf: ByteBuffer): PushCondition {
        return when(buf.getInt()) {
            1 -> PushCondition.EventMatch(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                )
            2 -> PushCondition.ContainsDisplayName
            3 -> PushCondition.RoomMemberCount(
                FfiConverterTypeComparisonOperator.read(buf),
                FfiConverterULong.read(buf),
                )
            4 -> PushCondition.SenderNotificationPermission(
                FfiConverterString.read(buf),
                )
            5 -> PushCondition.EventPropertyIs(
                FfiConverterString.read(buf),
                FfiConverterTypeJsonValue.read(buf),
                )
            6 -> PushCondition.EventPropertyContains(
                FfiConverterString.read(buf),
                FfiConverterTypeJsonValue.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PushCondition) = when(value) {
        is PushCondition.EventMatch -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`key`)
                + FfiConverterString.allocationSize(value.`pattern`)
            )
        }
        is PushCondition.ContainsDisplayName -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is PushCondition.RoomMemberCount -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeComparisonOperator.allocationSize(value.`prefix`)
                + FfiConverterULong.allocationSize(value.`count`)
            )
        }
        is PushCondition.SenderNotificationPermission -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`key`)
            )
        }
        is PushCondition.EventPropertyIs -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`key`)
                + FfiConverterTypeJsonValue.allocationSize(value.`value`)
            )
        }
        is PushCondition.EventPropertyContains -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`key`)
                + FfiConverterTypeJsonValue.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: PushCondition, buf: ByteBuffer) {
        when(value) {
            is PushCondition.EventMatch -> {
                buf.putInt(1)
                FfiConverterString.write(value.`key`, buf)
                FfiConverterString.write(value.`pattern`, buf)
                Unit
            }
            is PushCondition.ContainsDisplayName -> {
                buf.putInt(2)
                Unit
            }
            is PushCondition.RoomMemberCount -> {
                buf.putInt(3)
                FfiConverterTypeComparisonOperator.write(value.`prefix`, buf)
                FfiConverterULong.write(value.`count`, buf)
                Unit
            }
            is PushCondition.SenderNotificationPermission -> {
                buf.putInt(4)
                FfiConverterString.write(value.`key`, buf)
                Unit
            }
            is PushCondition.EventPropertyIs -> {
                buf.putInt(5)
                FfiConverterString.write(value.`key`, buf)
                FfiConverterTypeJsonValue.write(value.`value`, buf)
                Unit
            }
            is PushCondition.EventPropertyContains -> {
                buf.putInt(6)
                FfiConverterString.write(value.`key`, buf)
                FfiConverterTypeJsonValue.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class PushFormat {
    
    EVENT_ID_ONLY;
    companion object
}


public object FfiConverterTypePushFormat: FfiConverterRustBuffer<PushFormat> {
    override fun read(buf: ByteBuffer) = try {
        PushFormat.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: PushFormat) = 4UL

    override fun write(value: PushFormat, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class PusherKind {
    
    data class Http(
        val `data`: HttpPusherData) : PusherKind() {
        companion object
    }
    
    object Email : PusherKind()
    
    

    
    companion object
}

public object FfiConverterTypePusherKind : FfiConverterRustBuffer<PusherKind>{
    override fun read(buf: ByteBuffer): PusherKind {
        return when(buf.getInt()) {
            1 -> PusherKind.Http(
                FfiConverterTypeHttpPusherData.read(buf),
                )
            2 -> PusherKind.Email
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PusherKind) = when(value) {
        is PusherKind.Http -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeHttpPusherData.allocationSize(value.`data`)
            )
        }
        is PusherKind.Email -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: PusherKind, buf: ByteBuffer) {
        when(value) {
            is PusherKind.Http -> {
                buf.putInt(1)
                FfiConverterTypeHttpPusherData.write(value.`data`, buf)
                Unit
            }
            is PusherKind.Email -> {
                buf.putInt(2)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







/**
 * Error type for the decoding of the [`QrCodeData`].
 */
sealed class QrCodeDecodeException(message: String): kotlin.Exception(message) {
        
        class Crypto(message: String) : QrCodeDecodeException(message)
        

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<QrCodeDecodeException> {
        override fun lift(error_buf: RustBuffer.ByValue): QrCodeDecodeException = FfiConverterTypeQrCodeDecodeError.lift(error_buf)
    }
}

public object FfiConverterTypeQrCodeDecodeError : FfiConverterRustBuffer<QrCodeDecodeException> {
    override fun read(buf: ByteBuffer): QrCodeDecodeException {
        
            return when(buf.getInt()) {
            1 -> QrCodeDecodeException.Crypto(FfiConverterString.read(buf))
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
        
    }

    override fun allocationSize(value: QrCodeDecodeException): ULong {
        return 4UL
    }

    override fun write(value: QrCodeDecodeException, buf: ByteBuffer) {
        when(value) {
            is QrCodeDecodeException.Crypto -> {
                buf.putInt(1)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



/**
 * Enum describing the progress of logging in by scanning a QR code that was
 * generated on an existing device.
 */
sealed class QrLoginProgress {
    
    /**
     * The login process is starting.
     */
    object Starting : QrLoginProgress()
    
    
    /**
     * We established a secure channel with the other device.
     */
    data class EstablishingSecureChannel(
        /**
         * The check code that the device should display so the other device
         * can confirm that the channel is secure as well.
         */
        val `checkCode`: kotlin.UByte, 
        /**
         * The string representation of the check code, will be guaranteed to
         * be 2 characters long, preserving the leading zero if the
         * first digit is a zero.
         */
        val `checkCodeString`: kotlin.String) : QrLoginProgress() {
        companion object
    }
    
    /**
     * We are waiting for the login and for the OAuth 2.0 authorization server
     * to give us an access token.
     */
    data class WaitingForToken(
        val `userCode`: kotlin.String) : QrLoginProgress() {
        companion object
    }
    
    /**
     * We are syncing secrets.
     */
    object SyncingSecrets : QrLoginProgress()
    
    
    /**
     * The login has successfully finished.
     */
    object Done : QrLoginProgress()
    
    

    
    companion object
}

public object FfiConverterTypeQrLoginProgress : FfiConverterRustBuffer<QrLoginProgress>{
    override fun read(buf: ByteBuffer): QrLoginProgress {
        return when(buf.getInt()) {
            1 -> QrLoginProgress.Starting
            2 -> QrLoginProgress.EstablishingSecureChannel(
                FfiConverterUByte.read(buf),
                FfiConverterString.read(buf),
                )
            3 -> QrLoginProgress.WaitingForToken(
                FfiConverterString.read(buf),
                )
            4 -> QrLoginProgress.SyncingSecrets
            5 -> QrLoginProgress.Done
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: QrLoginProgress) = when(value) {
        is QrLoginProgress.Starting -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is QrLoginProgress.EstablishingSecureChannel -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUByte.allocationSize(value.`checkCode`)
                + FfiConverterString.allocationSize(value.`checkCodeString`)
            )
        }
        is QrLoginProgress.WaitingForToken -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`userCode`)
            )
        }
        is QrLoginProgress.SyncingSecrets -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is QrLoginProgress.Done -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: QrLoginProgress, buf: ByteBuffer) {
        when(value) {
            is QrLoginProgress.Starting -> {
                buf.putInt(1)
                Unit
            }
            is QrLoginProgress.EstablishingSecureChannel -> {
                buf.putInt(2)
                FfiConverterUByte.write(value.`checkCode`, buf)
                FfiConverterString.write(value.`checkCodeString`, buf)
                Unit
            }
            is QrLoginProgress.WaitingForToken -> {
                buf.putInt(3)
                FfiConverterString.write(value.`userCode`, buf)
                Unit
            }
            is QrLoginProgress.SyncingSecrets -> {
                buf.putInt(4)
                Unit
            }
            is QrLoginProgress.Done -> {
                buf.putInt(5)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Bindings version of the sdk type replacing OwnedUserId/DeviceIds with simple
 * String.
 *
 * Represent a failed to send unrecoverable error of an event sent via the
 * send_queue. It is a serializable representation of a client error, see
 * `From` implementation for more details. These errors can not be
 * automatically retried, but yet some manual action can be taken before retry
 * sending. If not the only solution is to delete the local event.
 */
sealed class QueueWedgeError {
    
    /**
     * This error occurs when there are some insecure devices in the room, and
     * the current encryption setting prohibit sharing with them.
     */
    data class InsecureDevices(
        /**
         * The insecure devices as a Map of userID to deviceID.
         */
        val `userDeviceMap`: Map<kotlin.String, List<kotlin.String>>) : QueueWedgeError() {
        companion object
    }
    
    /**
     * This error occurs when a previously verified user is not anymore, and
     * the current encryption setting prohibit sharing when it happens.
     */
    data class IdentityViolations(
        /**
         * The users that are expected to be verified but are not.
         */
        val `users`: List<kotlin.String>) : QueueWedgeError() {
        companion object
    }
    
    /**
     * It is required to set up cross-signing and properly erify the current
     * session before sending.
     */
    object CrossVerificationRequired : QueueWedgeError()
    
    
    /**
     * Some media content to be sent has disappeared from the cache.
     */
    object MissingMediaContent : QueueWedgeError()
    
    
    /**
     * Some mime type couldn't be parsed.
     */
    data class InvalidMimeType(
        val `mimeType`: kotlin.String) : QueueWedgeError() {
        companion object
    }
    
    /**
     * Other errors.
     */
    data class GenericApiError(
        val `msg`: kotlin.String) : QueueWedgeError() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeQueueWedgeError : FfiConverterRustBuffer<QueueWedgeError>{
    override fun read(buf: ByteBuffer): QueueWedgeError {
        return when(buf.getInt()) {
            1 -> QueueWedgeError.InsecureDevices(
                FfiConverterMapStringSequenceString.read(buf),
                )
            2 -> QueueWedgeError.IdentityViolations(
                FfiConverterSequenceString.read(buf),
                )
            3 -> QueueWedgeError.CrossVerificationRequired
            4 -> QueueWedgeError.MissingMediaContent
            5 -> QueueWedgeError.InvalidMimeType(
                FfiConverterString.read(buf),
                )
            6 -> QueueWedgeError.GenericApiError(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: QueueWedgeError) = when(value) {
        is QueueWedgeError.InsecureDevices -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterMapStringSequenceString.allocationSize(value.`userDeviceMap`)
            )
        }
        is QueueWedgeError.IdentityViolations -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceString.allocationSize(value.`users`)
            )
        }
        is QueueWedgeError.CrossVerificationRequired -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is QueueWedgeError.MissingMediaContent -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is QueueWedgeError.InvalidMimeType -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`mimeType`)
            )
        }
        is QueueWedgeError.GenericApiError -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`msg`)
            )
        }
    }

    override fun write(value: QueueWedgeError, buf: ByteBuffer) {
        when(value) {
            is QueueWedgeError.InsecureDevices -> {
                buf.putInt(1)
                FfiConverterMapStringSequenceString.write(value.`userDeviceMap`, buf)
                Unit
            }
            is QueueWedgeError.IdentityViolations -> {
                buf.putInt(2)
                FfiConverterSequenceString.write(value.`users`, buf)
                Unit
            }
            is QueueWedgeError.CrossVerificationRequired -> {
                buf.putInt(3)
                Unit
            }
            is QueueWedgeError.MissingMediaContent -> {
                buf.putInt(4)
                Unit
            }
            is QueueWedgeError.InvalidMimeType -> {
                buf.putInt(5)
                FfiConverterString.write(value.`mimeType`, buf)
                Unit
            }
            is QueueWedgeError.GenericApiError -> {
                buf.putInt(6)
                FfiConverterString.write(value.`msg`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * A [`TimelineItem`](super::TimelineItem) that doesn't correspond to an event.
 */

enum class ReceiptType {
    
    READ,
    READ_PRIVATE,
    FULLY_READ;
    companion object
}


public object FfiConverterTypeReceiptType: FfiConverterRustBuffer<ReceiptType> {
    override fun read(buf: ByteBuffer) = try {
        ReceiptType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ReceiptType) = 4UL

    override fun write(value: ReceiptType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







sealed class RecoveryException: kotlin.Exception() {
    
    /**
     * A backup already exists on the homeserver, the recovery subsystem does
     * not allow backups to be overwritten, disable recovery first.
     */
    class BackupExistsOnServer(
        ) : RecoveryException() {
        override val message
            get() = ""
    }
    
    /**
     * A typical SDK error.
     */
    class Client(
        
        val `source`: ClientException
        ) : RecoveryException() {
        override val message
            get() = "source=${ `source` }"
    }
    
    /**
     * Error in the secret storage subsystem, except for when importing a
     * secret.
     */
    class SecretStorage(
        
        val `errorMessage`: kotlin.String
        ) : RecoveryException() {
        override val message
            get() = "errorMessage=${ `errorMessage` }"
    }
    
    /**
     * Error when importing a secret from secret storage.
     */
    class Import(
        
        val `errorMessage`: kotlin.String
        ) : RecoveryException() {
        override val message
            get() = "errorMessage=${ `errorMessage` }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<RecoveryException> {
        override fun lift(error_buf: RustBuffer.ByValue): RecoveryException = FfiConverterTypeRecoveryError.lift(error_buf)
    }

    
}

public object FfiConverterTypeRecoveryError : FfiConverterRustBuffer<RecoveryException> {
    override fun read(buf: ByteBuffer): RecoveryException {
        

        return when(buf.getInt()) {
            1 -> RecoveryException.BackupExistsOnServer()
            2 -> RecoveryException.Client(
                FfiConverterTypeClientError.read(buf),
                )
            3 -> RecoveryException.SecretStorage(
                FfiConverterString.read(buf),
                )
            4 -> RecoveryException.Import(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: RecoveryException): ULong {
        return when(value) {
            is RecoveryException.BackupExistsOnServer -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is RecoveryException.Client -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeClientError.allocationSize(value.`source`)
            )
            is RecoveryException.SecretStorage -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`errorMessage`)
            )
            is RecoveryException.Import -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`errorMessage`)
            )
        }
    }

    override fun write(value: RecoveryException, buf: ByteBuffer) {
        when(value) {
            is RecoveryException.BackupExistsOnServer -> {
                buf.putInt(1)
                Unit
            }
            is RecoveryException.Client -> {
                buf.putInt(2)
                FfiConverterTypeClientError.write(value.`source`, buf)
                Unit
            }
            is RecoveryException.SecretStorage -> {
                buf.putInt(3)
                FfiConverterString.write(value.`errorMessage`, buf)
                Unit
            }
            is RecoveryException.Import -> {
                buf.putInt(4)
                FfiConverterString.write(value.`errorMessage`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




enum class RecoveryState {
    
    UNKNOWN,
    ENABLED,
    DISABLED,
    INCOMPLETE;
    companion object
}


public object FfiConverterTypeRecoveryState: FfiConverterRustBuffer<RecoveryState> {
    override fun read(buf: ByteBuffer) = try {
        RecoveryState.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: RecoveryState) = 4UL

    override fun write(value: RecoveryState, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Room account data events.
 */
sealed class RoomAccountDataEvent {
    
    /**
     * m.fully_read
     */
    data class FullyReadEvent(
        /**
         * The event the user's read marker is located at in the room.
         */
        val `eventId`: kotlin.String) : RoomAccountDataEvent() {
        companion object
    }
    
    /**
     * m.marked_unread
     */
    data class MarkedUnread(
        /**
         * The current unread state.
         */
        val `unread`: kotlin.Boolean) : RoomAccountDataEvent() {
        companion object
    }
    
    /**
     * m.tag
     */
    data class Tag(
        val `tags`: Map<TagName, TagInfo>) : RoomAccountDataEvent() {
        companion object
    }
    
    /**
     * com.famedly.marked_unread
     */
    data class UnstableMarkedUnread(
        /**
         * The current unread state.
         */
        val `unread`: kotlin.Boolean) : RoomAccountDataEvent() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeRoomAccountDataEvent : FfiConverterRustBuffer<RoomAccountDataEvent>{
    override fun read(buf: ByteBuffer): RoomAccountDataEvent {
        return when(buf.getInt()) {
            1 -> RoomAccountDataEvent.FullyReadEvent(
                FfiConverterString.read(buf),
                )
            2 -> RoomAccountDataEvent.MarkedUnread(
                FfiConverterBoolean.read(buf),
                )
            3 -> RoomAccountDataEvent.Tag(
                FfiConverterMapTypeTagNameTypeTagInfo.read(buf),
                )
            4 -> RoomAccountDataEvent.UnstableMarkedUnread(
                FfiConverterBoolean.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: RoomAccountDataEvent) = when(value) {
        is RoomAccountDataEvent.FullyReadEvent -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`eventId`)
            )
        }
        is RoomAccountDataEvent.MarkedUnread -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterBoolean.allocationSize(value.`unread`)
            )
        }
        is RoomAccountDataEvent.Tag -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterMapTypeTagNameTypeTagInfo.allocationSize(value.`tags`)
            )
        }
        is RoomAccountDataEvent.UnstableMarkedUnread -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterBoolean.allocationSize(value.`unread`)
            )
        }
    }

    override fun write(value: RoomAccountDataEvent, buf: ByteBuffer) {
        when(value) {
            is RoomAccountDataEvent.FullyReadEvent -> {
                buf.putInt(1)
                FfiConverterString.write(value.`eventId`, buf)
                Unit
            }
            is RoomAccountDataEvent.MarkedUnread -> {
                buf.putInt(2)
                FfiConverterBoolean.write(value.`unread`, buf)
                Unit
            }
            is RoomAccountDataEvent.Tag -> {
                buf.putInt(3)
                FfiConverterMapTypeTagNameTypeTagInfo.write(value.`tags`, buf)
                Unit
            }
            is RoomAccountDataEvent.UnstableMarkedUnread -> {
                buf.putInt(4)
                FfiConverterBoolean.write(value.`unread`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Types of room account data events.
 */

enum class RoomAccountDataEventType {
    
    /**
     * m.fully_read
     */
    FULLY_READ,
    /**
     * m.marked_unread
     */
    MARKED_UNREAD,
    /**
     * m.tag
     */
    TAG,
    /**
     * com.famedly.marked_unread
     */
    UNSTABLE_MARKED_UNREAD;
    companion object
}


public object FfiConverterTypeRoomAccountDataEventType: FfiConverterRustBuffer<RoomAccountDataEventType> {
    override fun read(buf: ByteBuffer) = try {
        RoomAccountDataEventType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: RoomAccountDataEventType) = 4UL

    override fun write(value: RoomAccountDataEventType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class RoomDirectorySearchEntryUpdate {
    
    data class Append(
        val `values`: List<RoomDescription>) : RoomDirectorySearchEntryUpdate() {
        companion object
    }
    
    object Clear : RoomDirectorySearchEntryUpdate()
    
    
    data class PushFront(
        val `value`: RoomDescription) : RoomDirectorySearchEntryUpdate() {
        companion object
    }
    
    data class PushBack(
        val `value`: RoomDescription) : RoomDirectorySearchEntryUpdate() {
        companion object
    }
    
    object PopFront : RoomDirectorySearchEntryUpdate()
    
    
    object PopBack : RoomDirectorySearchEntryUpdate()
    
    
    data class Insert(
        val `index`: kotlin.UInt, 
        val `value`: RoomDescription) : RoomDirectorySearchEntryUpdate() {
        companion object
    }
    
    data class Set(
        val `index`: kotlin.UInt, 
        val `value`: RoomDescription) : RoomDirectorySearchEntryUpdate() {
        companion object
    }
    
    data class Remove(
        val `index`: kotlin.UInt) : RoomDirectorySearchEntryUpdate() {
        companion object
    }
    
    data class Truncate(
        val `length`: kotlin.UInt) : RoomDirectorySearchEntryUpdate() {
        companion object
    }
    
    data class Reset(
        val `values`: List<RoomDescription>) : RoomDirectorySearchEntryUpdate() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeRoomDirectorySearchEntryUpdate : FfiConverterRustBuffer<RoomDirectorySearchEntryUpdate>{
    override fun read(buf: ByteBuffer): RoomDirectorySearchEntryUpdate {
        return when(buf.getInt()) {
            1 -> RoomDirectorySearchEntryUpdate.Append(
                FfiConverterSequenceTypeRoomDescription.read(buf),
                )
            2 -> RoomDirectorySearchEntryUpdate.Clear
            3 -> RoomDirectorySearchEntryUpdate.PushFront(
                FfiConverterTypeRoomDescription.read(buf),
                )
            4 -> RoomDirectorySearchEntryUpdate.PushBack(
                FfiConverterTypeRoomDescription.read(buf),
                )
            5 -> RoomDirectorySearchEntryUpdate.PopFront
            6 -> RoomDirectorySearchEntryUpdate.PopBack
            7 -> RoomDirectorySearchEntryUpdate.Insert(
                FfiConverterUInt.read(buf),
                FfiConverterTypeRoomDescription.read(buf),
                )
            8 -> RoomDirectorySearchEntryUpdate.Set(
                FfiConverterUInt.read(buf),
                FfiConverterTypeRoomDescription.read(buf),
                )
            9 -> RoomDirectorySearchEntryUpdate.Remove(
                FfiConverterUInt.read(buf),
                )
            10 -> RoomDirectorySearchEntryUpdate.Truncate(
                FfiConverterUInt.read(buf),
                )
            11 -> RoomDirectorySearchEntryUpdate.Reset(
                FfiConverterSequenceTypeRoomDescription.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: RoomDirectorySearchEntryUpdate) = when(value) {
        is RoomDirectorySearchEntryUpdate.Append -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeRoomDescription.allocationSize(value.`values`)
            )
        }
        is RoomDirectorySearchEntryUpdate.Clear -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomDirectorySearchEntryUpdate.PushFront -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeRoomDescription.allocationSize(value.`value`)
            )
        }
        is RoomDirectorySearchEntryUpdate.PushBack -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeRoomDescription.allocationSize(value.`value`)
            )
        }
        is RoomDirectorySearchEntryUpdate.PopFront -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomDirectorySearchEntryUpdate.PopBack -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomDirectorySearchEntryUpdate.Insert -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUInt.allocationSize(value.`index`)
                + FfiConverterTypeRoomDescription.allocationSize(value.`value`)
            )
        }
        is RoomDirectorySearchEntryUpdate.Set -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUInt.allocationSize(value.`index`)
                + FfiConverterTypeRoomDescription.allocationSize(value.`value`)
            )
        }
        is RoomDirectorySearchEntryUpdate.Remove -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUInt.allocationSize(value.`index`)
            )
        }
        is RoomDirectorySearchEntryUpdate.Truncate -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUInt.allocationSize(value.`length`)
            )
        }
        is RoomDirectorySearchEntryUpdate.Reset -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeRoomDescription.allocationSize(value.`values`)
            )
        }
    }

    override fun write(value: RoomDirectorySearchEntryUpdate, buf: ByteBuffer) {
        when(value) {
            is RoomDirectorySearchEntryUpdate.Append -> {
                buf.putInt(1)
                FfiConverterSequenceTypeRoomDescription.write(value.`values`, buf)
                Unit
            }
            is RoomDirectorySearchEntryUpdate.Clear -> {
                buf.putInt(2)
                Unit
            }
            is RoomDirectorySearchEntryUpdate.PushFront -> {
                buf.putInt(3)
                FfiConverterTypeRoomDescription.write(value.`value`, buf)
                Unit
            }
            is RoomDirectorySearchEntryUpdate.PushBack -> {
                buf.putInt(4)
                FfiConverterTypeRoomDescription.write(value.`value`, buf)
                Unit
            }
            is RoomDirectorySearchEntryUpdate.PopFront -> {
                buf.putInt(5)
                Unit
            }
            is RoomDirectorySearchEntryUpdate.PopBack -> {
                buf.putInt(6)
                Unit
            }
            is RoomDirectorySearchEntryUpdate.Insert -> {
                buf.putInt(7)
                FfiConverterUInt.write(value.`index`, buf)
                FfiConverterTypeRoomDescription.write(value.`value`, buf)
                Unit
            }
            is RoomDirectorySearchEntryUpdate.Set -> {
                buf.putInt(8)
                FfiConverterUInt.write(value.`index`, buf)
                FfiConverterTypeRoomDescription.write(value.`value`, buf)
                Unit
            }
            is RoomDirectorySearchEntryUpdate.Remove -> {
                buf.putInt(9)
                FfiConverterUInt.write(value.`index`, buf)
                Unit
            }
            is RoomDirectorySearchEntryUpdate.Truncate -> {
                buf.putInt(10)
                FfiConverterUInt.write(value.`length`, buf)
                Unit
            }
            is RoomDirectorySearchEntryUpdate.Reset -> {
                buf.putInt(11)
                FfiConverterSequenceTypeRoomDescription.write(value.`values`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class RoomException(message: String): kotlin.Exception(message) {
        
        class InvalidAttachmentData(message: String) : RoomException(message)
        
        class InvalidAttachmentMimeType(message: String) : RoomException(message)
        
        class InvalidMediaInfo(message: String) : RoomException(message)
        
        class TimelineUnavailable(message: String) : RoomException(message)
        
        class InvalidThumbnailData(message: String) : RoomException(message)
        
        class InvalidRepliedToEventId(message: String) : RoomException(message)
        
        class FailedSendingAttachment(message: String) : RoomException(message)
        

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<RoomException> {
        override fun lift(error_buf: RustBuffer.ByValue): RoomException = FfiConverterTypeRoomError.lift(error_buf)
    }
}

public object FfiConverterTypeRoomError : FfiConverterRustBuffer<RoomException> {
    override fun read(buf: ByteBuffer): RoomException {
        
            return when(buf.getInt()) {
            1 -> RoomException.InvalidAttachmentData(FfiConverterString.read(buf))
            2 -> RoomException.InvalidAttachmentMimeType(FfiConverterString.read(buf))
            3 -> RoomException.InvalidMediaInfo(FfiConverterString.read(buf))
            4 -> RoomException.TimelineUnavailable(FfiConverterString.read(buf))
            5 -> RoomException.InvalidThumbnailData(FfiConverterString.read(buf))
            6 -> RoomException.InvalidRepliedToEventId(FfiConverterString.read(buf))
            7 -> RoomException.FailedSendingAttachment(FfiConverterString.read(buf))
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
        
    }

    override fun allocationSize(value: RoomException): ULong {
        return 4UL
    }

    override fun write(value: RoomException, buf: ByteBuffer) {
        when(value) {
            is RoomException.InvalidAttachmentData -> {
                buf.putInt(1)
                Unit
            }
            is RoomException.InvalidAttachmentMimeType -> {
                buf.putInt(2)
                Unit
            }
            is RoomException.InvalidMediaInfo -> {
                buf.putInt(3)
                Unit
            }
            is RoomException.TimelineUnavailable -> {
                buf.putInt(4)
                Unit
            }
            is RoomException.InvalidThumbnailData -> {
                buf.putInt(5)
                Unit
            }
            is RoomException.InvalidRepliedToEventId -> {
                buf.putInt(6)
                Unit
            }
            is RoomException.FailedSendingAttachment -> {
                buf.putInt(7)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class RoomHistoryVisibility {
    
    /**
     * Previous events are accessible to newly joined members from the point
     * they were invited onwards.
     *
     * Events stop being accessible when the member's state changes to
     * something other than *invite* or *join*.
     */
    object Invited : RoomHistoryVisibility()
    
    
    /**
     * Previous events are accessible to newly joined members from the point
     * they joined the room onwards.
     * Events stop being accessible when the member's state changes to
     * something other than *join*.
     */
    object Joined : RoomHistoryVisibility()
    
    
    /**
     * Previous events are always accessible to newly joined members.
     *
     * All events in the room are accessible, even those sent when the member
     * was not a part of the room.
     */
    object Shared : RoomHistoryVisibility()
    
    
    /**
     * All events while this is the `HistoryVisibility` value may be shared by
     * any participating homeserver with anyone, regardless of whether they
     * have ever joined the room.
     */
    object WorldReadable : RoomHistoryVisibility()
    
    
    /**
     * A custom visibility value.
     */
    data class Custom(
        val `value`: kotlin.String) : RoomHistoryVisibility() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeRoomHistoryVisibility : FfiConverterRustBuffer<RoomHistoryVisibility>{
    override fun read(buf: ByteBuffer): RoomHistoryVisibility {
        return when(buf.getInt()) {
            1 -> RoomHistoryVisibility.Invited
            2 -> RoomHistoryVisibility.Joined
            3 -> RoomHistoryVisibility.Shared
            4 -> RoomHistoryVisibility.WorldReadable
            5 -> RoomHistoryVisibility.Custom(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: RoomHistoryVisibility) = when(value) {
        is RoomHistoryVisibility.Invited -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomHistoryVisibility.Joined -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomHistoryVisibility.Shared -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomHistoryVisibility.WorldReadable -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomHistoryVisibility.Custom -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: RoomHistoryVisibility, buf: ByteBuffer) {
        when(value) {
            is RoomHistoryVisibility.Invited -> {
                buf.putInt(1)
                Unit
            }
            is RoomHistoryVisibility.Joined -> {
                buf.putInt(2)
                Unit
            }
            is RoomHistoryVisibility.Shared -> {
                buf.putInt(3)
                Unit
            }
            is RoomHistoryVisibility.WorldReadable -> {
                buf.putInt(4)
                Unit
            }
            is RoomHistoryVisibility.Custom -> {
                buf.putInt(5)
                FfiConverterString.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class RoomListEntriesDynamicFilterKind {
    
    data class All(
        val `filters`: List<RoomListEntriesDynamicFilterKind>) : RoomListEntriesDynamicFilterKind() {
        companion object
    }
    
    data class Any(
        val `filters`: List<RoomListEntriesDynamicFilterKind>) : RoomListEntriesDynamicFilterKind() {
        companion object
    }
    
    object NonSpace : RoomListEntriesDynamicFilterKind()
    
    
    object Space : RoomListEntriesDynamicFilterKind()
    
    
    object NonLeft : RoomListEntriesDynamicFilterKind()
    
    
    object Joined : RoomListEntriesDynamicFilterKind()
    
    
    object Unread : RoomListEntriesDynamicFilterKind()
    
    
    object Favourite : RoomListEntriesDynamicFilterKind()
    
    
    object LowPriority : RoomListEntriesDynamicFilterKind()
    
    
    object NonLowPriority : RoomListEntriesDynamicFilterKind()
    
    
    object Invite : RoomListEntriesDynamicFilterKind()
    
    
    data class Category(
        val `expect`: RoomListFilterCategory) : RoomListEntriesDynamicFilterKind() {
        companion object
    }
    
    object None : RoomListEntriesDynamicFilterKind()
    
    
    data class NormalizedMatchRoomName(
        val `pattern`: kotlin.String) : RoomListEntriesDynamicFilterKind() {
        companion object
    }
    
    data class FuzzyMatchRoomName(
        val `pattern`: kotlin.String) : RoomListEntriesDynamicFilterKind() {
        companion object
    }
    
    object DeduplicateVersions : RoomListEntriesDynamicFilterKind()
    
    

    
    companion object
}

public object FfiConverterTypeRoomListEntriesDynamicFilterKind : FfiConverterRustBuffer<RoomListEntriesDynamicFilterKind>{
    override fun read(buf: ByteBuffer): RoomListEntriesDynamicFilterKind {
        return when(buf.getInt()) {
            1 -> RoomListEntriesDynamicFilterKind.All(
                FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind.read(buf),
                )
            2 -> RoomListEntriesDynamicFilterKind.Any(
                FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind.read(buf),
                )
            3 -> RoomListEntriesDynamicFilterKind.NonSpace
            4 -> RoomListEntriesDynamicFilterKind.Space
            5 -> RoomListEntriesDynamicFilterKind.NonLeft
            6 -> RoomListEntriesDynamicFilterKind.Joined
            7 -> RoomListEntriesDynamicFilterKind.Unread
            8 -> RoomListEntriesDynamicFilterKind.Favourite
            9 -> RoomListEntriesDynamicFilterKind.LowPriority
            10 -> RoomListEntriesDynamicFilterKind.NonLowPriority
            11 -> RoomListEntriesDynamicFilterKind.Invite
            12 -> RoomListEntriesDynamicFilterKind.Category(
                FfiConverterTypeRoomListFilterCategory.read(buf),
                )
            13 -> RoomListEntriesDynamicFilterKind.None
            14 -> RoomListEntriesDynamicFilterKind.NormalizedMatchRoomName(
                FfiConverterString.read(buf),
                )
            15 -> RoomListEntriesDynamicFilterKind.FuzzyMatchRoomName(
                FfiConverterString.read(buf),
                )
            16 -> RoomListEntriesDynamicFilterKind.DeduplicateVersions
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: RoomListEntriesDynamicFilterKind) = when(value) {
        is RoomListEntriesDynamicFilterKind.All -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind.allocationSize(value.`filters`)
            )
        }
        is RoomListEntriesDynamicFilterKind.Any -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind.allocationSize(value.`filters`)
            )
        }
        is RoomListEntriesDynamicFilterKind.NonSpace -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomListEntriesDynamicFilterKind.Space -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomListEntriesDynamicFilterKind.NonLeft -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomListEntriesDynamicFilterKind.Joined -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomListEntriesDynamicFilterKind.Unread -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomListEntriesDynamicFilterKind.Favourite -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomListEntriesDynamicFilterKind.LowPriority -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomListEntriesDynamicFilterKind.NonLowPriority -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomListEntriesDynamicFilterKind.Invite -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomListEntriesDynamicFilterKind.Category -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeRoomListFilterCategory.allocationSize(value.`expect`)
            )
        }
        is RoomListEntriesDynamicFilterKind.None -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomListEntriesDynamicFilterKind.NormalizedMatchRoomName -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`pattern`)
            )
        }
        is RoomListEntriesDynamicFilterKind.FuzzyMatchRoomName -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`pattern`)
            )
        }
        is RoomListEntriesDynamicFilterKind.DeduplicateVersions -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: RoomListEntriesDynamicFilterKind, buf: ByteBuffer) {
        when(value) {
            is RoomListEntriesDynamicFilterKind.All -> {
                buf.putInt(1)
                FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind.write(value.`filters`, buf)
                Unit
            }
            is RoomListEntriesDynamicFilterKind.Any -> {
                buf.putInt(2)
                FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind.write(value.`filters`, buf)
                Unit
            }
            is RoomListEntriesDynamicFilterKind.NonSpace -> {
                buf.putInt(3)
                Unit
            }
            is RoomListEntriesDynamicFilterKind.Space -> {
                buf.putInt(4)
                Unit
            }
            is RoomListEntriesDynamicFilterKind.NonLeft -> {
                buf.putInt(5)
                Unit
            }
            is RoomListEntriesDynamicFilterKind.Joined -> {
                buf.putInt(6)
                Unit
            }
            is RoomListEntriesDynamicFilterKind.Unread -> {
                buf.putInt(7)
                Unit
            }
            is RoomListEntriesDynamicFilterKind.Favourite -> {
                buf.putInt(8)
                Unit
            }
            is RoomListEntriesDynamicFilterKind.LowPriority -> {
                buf.putInt(9)
                Unit
            }
            is RoomListEntriesDynamicFilterKind.NonLowPriority -> {
                buf.putInt(10)
                Unit
            }
            is RoomListEntriesDynamicFilterKind.Invite -> {
                buf.putInt(11)
                Unit
            }
            is RoomListEntriesDynamicFilterKind.Category -> {
                buf.putInt(12)
                FfiConverterTypeRoomListFilterCategory.write(value.`expect`, buf)
                Unit
            }
            is RoomListEntriesDynamicFilterKind.None -> {
                buf.putInt(13)
                Unit
            }
            is RoomListEntriesDynamicFilterKind.NormalizedMatchRoomName -> {
                buf.putInt(14)
                FfiConverterString.write(value.`pattern`, buf)
                Unit
            }
            is RoomListEntriesDynamicFilterKind.FuzzyMatchRoomName -> {
                buf.putInt(15)
                FfiConverterString.write(value.`pattern`, buf)
                Unit
            }
            is RoomListEntriesDynamicFilterKind.DeduplicateVersions -> {
                buf.putInt(16)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class RoomListEntriesUpdate: Disposable  {
    
    data class Append(
        val `values`: List<Room>) : RoomListEntriesUpdate() {
        companion object
    }
    
    object Clear : RoomListEntriesUpdate()
    
    
    data class PushFront(
        val `value`: Room) : RoomListEntriesUpdate() {
        companion object
    }
    
    data class PushBack(
        val `value`: Room) : RoomListEntriesUpdate() {
        companion object
    }
    
    object PopFront : RoomListEntriesUpdate()
    
    
    object PopBack : RoomListEntriesUpdate()
    
    
    data class Insert(
        val `index`: kotlin.UInt, 
        val `value`: Room) : RoomListEntriesUpdate() {
        companion object
    }
    
    data class Set(
        val `index`: kotlin.UInt, 
        val `value`: Room) : RoomListEntriesUpdate() {
        companion object
    }
    
    data class Remove(
        val `index`: kotlin.UInt) : RoomListEntriesUpdate() {
        companion object
    }
    
    data class Truncate(
        val `length`: kotlin.UInt) : RoomListEntriesUpdate() {
        companion object
    }
    
    data class Reset(
        val `values`: List<Room>) : RoomListEntriesUpdate() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is RoomListEntriesUpdate.Append -> {
                
        Disposable.destroy(this.`values`)
    
                
            }
            is RoomListEntriesUpdate.Clear -> {// Nothing to destroy
            }
            is RoomListEntriesUpdate.PushFront -> {
                
        Disposable.destroy(this.`value`)
    
                
            }
            is RoomListEntriesUpdate.PushBack -> {
                
        Disposable.destroy(this.`value`)
    
                
            }
            is RoomListEntriesUpdate.PopFront -> {// Nothing to destroy
            }
            is RoomListEntriesUpdate.PopBack -> {// Nothing to destroy
            }
            is RoomListEntriesUpdate.Insert -> {
                
        Disposable.destroy(this.`index`)
    
        Disposable.destroy(this.`value`)
    
                
            }
            is RoomListEntriesUpdate.Set -> {
                
        Disposable.destroy(this.`index`)
    
        Disposable.destroy(this.`value`)
    
                
            }
            is RoomListEntriesUpdate.Remove -> {
                
        Disposable.destroy(this.`index`)
    
                
            }
            is RoomListEntriesUpdate.Truncate -> {
                
        Disposable.destroy(this.`length`)
    
                
            }
            is RoomListEntriesUpdate.Reset -> {
                
        Disposable.destroy(this.`values`)
    
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

public object FfiConverterTypeRoomListEntriesUpdate : FfiConverterRustBuffer<RoomListEntriesUpdate>{
    override fun read(buf: ByteBuffer): RoomListEntriesUpdate {
        return when(buf.getInt()) {
            1 -> RoomListEntriesUpdate.Append(
                FfiConverterSequenceTypeRoom.read(buf),
                )
            2 -> RoomListEntriesUpdate.Clear
            3 -> RoomListEntriesUpdate.PushFront(
                FfiConverterTypeRoom.read(buf),
                )
            4 -> RoomListEntriesUpdate.PushBack(
                FfiConverterTypeRoom.read(buf),
                )
            5 -> RoomListEntriesUpdate.PopFront
            6 -> RoomListEntriesUpdate.PopBack
            7 -> RoomListEntriesUpdate.Insert(
                FfiConverterUInt.read(buf),
                FfiConverterTypeRoom.read(buf),
                )
            8 -> RoomListEntriesUpdate.Set(
                FfiConverterUInt.read(buf),
                FfiConverterTypeRoom.read(buf),
                )
            9 -> RoomListEntriesUpdate.Remove(
                FfiConverterUInt.read(buf),
                )
            10 -> RoomListEntriesUpdate.Truncate(
                FfiConverterUInt.read(buf),
                )
            11 -> RoomListEntriesUpdate.Reset(
                FfiConverterSequenceTypeRoom.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: RoomListEntriesUpdate) = when(value) {
        is RoomListEntriesUpdate.Append -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeRoom.allocationSize(value.`values`)
            )
        }
        is RoomListEntriesUpdate.Clear -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomListEntriesUpdate.PushFront -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeRoom.allocationSize(value.`value`)
            )
        }
        is RoomListEntriesUpdate.PushBack -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeRoom.allocationSize(value.`value`)
            )
        }
        is RoomListEntriesUpdate.PopFront -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomListEntriesUpdate.PopBack -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomListEntriesUpdate.Insert -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUInt.allocationSize(value.`index`)
                + FfiConverterTypeRoom.allocationSize(value.`value`)
            )
        }
        is RoomListEntriesUpdate.Set -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUInt.allocationSize(value.`index`)
                + FfiConverterTypeRoom.allocationSize(value.`value`)
            )
        }
        is RoomListEntriesUpdate.Remove -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUInt.allocationSize(value.`index`)
            )
        }
        is RoomListEntriesUpdate.Truncate -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUInt.allocationSize(value.`length`)
            )
        }
        is RoomListEntriesUpdate.Reset -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeRoom.allocationSize(value.`values`)
            )
        }
    }

    override fun write(value: RoomListEntriesUpdate, buf: ByteBuffer) {
        when(value) {
            is RoomListEntriesUpdate.Append -> {
                buf.putInt(1)
                FfiConverterSequenceTypeRoom.write(value.`values`, buf)
                Unit
            }
            is RoomListEntriesUpdate.Clear -> {
                buf.putInt(2)
                Unit
            }
            is RoomListEntriesUpdate.PushFront -> {
                buf.putInt(3)
                FfiConverterTypeRoom.write(value.`value`, buf)
                Unit
            }
            is RoomListEntriesUpdate.PushBack -> {
                buf.putInt(4)
                FfiConverterTypeRoom.write(value.`value`, buf)
                Unit
            }
            is RoomListEntriesUpdate.PopFront -> {
                buf.putInt(5)
                Unit
            }
            is RoomListEntriesUpdate.PopBack -> {
                buf.putInt(6)
                Unit
            }
            is RoomListEntriesUpdate.Insert -> {
                buf.putInt(7)
                FfiConverterUInt.write(value.`index`, buf)
                FfiConverterTypeRoom.write(value.`value`, buf)
                Unit
            }
            is RoomListEntriesUpdate.Set -> {
                buf.putInt(8)
                FfiConverterUInt.write(value.`index`, buf)
                FfiConverterTypeRoom.write(value.`value`, buf)
                Unit
            }
            is RoomListEntriesUpdate.Remove -> {
                buf.putInt(9)
                FfiConverterUInt.write(value.`index`, buf)
                Unit
            }
            is RoomListEntriesUpdate.Truncate -> {
                buf.putInt(10)
                FfiConverterUInt.write(value.`length`, buf)
                Unit
            }
            is RoomListEntriesUpdate.Reset -> {
                buf.putInt(11)
                FfiConverterSequenceTypeRoom.write(value.`values`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class RoomListException: kotlin.Exception() {
    
    class SlidingSync(
        
        val `error`: kotlin.String
        ) : RoomListException() {
        override val message
            get() = "error=${ `error` }"
    }
    
    class UnknownList(
        
        val `listName`: kotlin.String
        ) : RoomListException() {
        override val message
            get() = "listName=${ `listName` }"
    }
    
    class InputCannotBeApplied(
        ) : RoomListException() {
        override val message
            get() = ""
    }
    
    class RoomNotFound(
        
        val `roomName`: kotlin.String
        ) : RoomListException() {
        override val message
            get() = "roomName=${ `roomName` }"
    }
    
    class InvalidRoomId(
        
        val `error`: kotlin.String
        ) : RoomListException() {
        override val message
            get() = "error=${ `error` }"
    }
    
    class EventCache(
        
        val `error`: kotlin.String
        ) : RoomListException() {
        override val message
            get() = "error=${ `error` }"
    }
    
    class IncorrectRoomMembership(
        
        val `expected`: List<Membership>, 
        
        val `actual`: Membership
        ) : RoomListException() {
        override val message
            get() = "expected=${ `expected` }, actual=${ `actual` }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<RoomListException> {
        override fun lift(error_buf: RustBuffer.ByValue): RoomListException = FfiConverterTypeRoomListError.lift(error_buf)
    }

    
}

public object FfiConverterTypeRoomListError : FfiConverterRustBuffer<RoomListException> {
    override fun read(buf: ByteBuffer): RoomListException {
        

        return when(buf.getInt()) {
            1 -> RoomListException.SlidingSync(
                FfiConverterString.read(buf),
                )
            2 -> RoomListException.UnknownList(
                FfiConverterString.read(buf),
                )
            3 -> RoomListException.InputCannotBeApplied()
            4 -> RoomListException.RoomNotFound(
                FfiConverterString.read(buf),
                )
            5 -> RoomListException.InvalidRoomId(
                FfiConverterString.read(buf),
                )
            6 -> RoomListException.EventCache(
                FfiConverterString.read(buf),
                )
            7 -> RoomListException.IncorrectRoomMembership(
                FfiConverterSequenceTypeMembership.read(buf),
                FfiConverterTypeMembership.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: RoomListException): ULong {
        return when(value) {
            is RoomListException.SlidingSync -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`error`)
            )
            is RoomListException.UnknownList -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`listName`)
            )
            is RoomListException.InputCannotBeApplied -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is RoomListException.RoomNotFound -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`roomName`)
            )
            is RoomListException.InvalidRoomId -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`error`)
            )
            is RoomListException.EventCache -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`error`)
            )
            is RoomListException.IncorrectRoomMembership -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterSequenceTypeMembership.allocationSize(value.`expected`)
                + FfiConverterTypeMembership.allocationSize(value.`actual`)
            )
        }
    }

    override fun write(value: RoomListException, buf: ByteBuffer) {
        when(value) {
            is RoomListException.SlidingSync -> {
                buf.putInt(1)
                FfiConverterString.write(value.`error`, buf)
                Unit
            }
            is RoomListException.UnknownList -> {
                buf.putInt(2)
                FfiConverterString.write(value.`listName`, buf)
                Unit
            }
            is RoomListException.InputCannotBeApplied -> {
                buf.putInt(3)
                Unit
            }
            is RoomListException.RoomNotFound -> {
                buf.putInt(4)
                FfiConverterString.write(value.`roomName`, buf)
                Unit
            }
            is RoomListException.InvalidRoomId -> {
                buf.putInt(5)
                FfiConverterString.write(value.`error`, buf)
                Unit
            }
            is RoomListException.EventCache -> {
                buf.putInt(6)
                FfiConverterString.write(value.`error`, buf)
                Unit
            }
            is RoomListException.IncorrectRoomMembership -> {
                buf.putInt(7)
                FfiConverterSequenceTypeMembership.write(value.`expected`, buf)
                FfiConverterTypeMembership.write(value.`actual`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




enum class RoomListFilterCategory {
    
    GROUP,
    PEOPLE;
    companion object
}


public object FfiConverterTypeRoomListFilterCategory: FfiConverterRustBuffer<RoomListFilterCategory> {
    override fun read(buf: ByteBuffer) = try {
        RoomListFilterCategory.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: RoomListFilterCategory) = 4UL

    override fun write(value: RoomListFilterCategory, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class RoomListLoadingState {
    
    object NotLoaded : RoomListLoadingState()
    
    
    data class Loaded(
        val `maximumNumberOfRooms`: kotlin.UInt?) : RoomListLoadingState() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeRoomListLoadingState : FfiConverterRustBuffer<RoomListLoadingState>{
    override fun read(buf: ByteBuffer): RoomListLoadingState {
        return when(buf.getInt()) {
            1 -> RoomListLoadingState.NotLoaded
            2 -> RoomListLoadingState.Loaded(
                FfiConverterOptionalUInt.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: RoomListLoadingState) = when(value) {
        is RoomListLoadingState.NotLoaded -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomListLoadingState.Loaded -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalUInt.allocationSize(value.`maximumNumberOfRooms`)
            )
        }
    }

    override fun write(value: RoomListLoadingState, buf: ByteBuffer) {
        when(value) {
            is RoomListLoadingState.NotLoaded -> {
                buf.putInt(1)
                Unit
            }
            is RoomListLoadingState.Loaded -> {
                buf.putInt(2)
                FfiConverterOptionalUInt.write(value.`maximumNumberOfRooms`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class RoomListServiceState {
    
    INITIAL,
    SETTING_UP,
    RECOVERING,
    RUNNING,
    ERROR,
    TERMINATED;
    companion object
}


public object FfiConverterTypeRoomListServiceState: FfiConverterRustBuffer<RoomListServiceState> {
    override fun read(buf: ByteBuffer) = try {
        RoomListServiceState.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: RoomListServiceState) = 4UL

    override fun write(value: RoomListServiceState, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class RoomListServiceSyncIndicator {
    
    SHOW,
    HIDE;
    companion object
}


public object FfiConverterTypeRoomListServiceSyncIndicator: FfiConverterRustBuffer<RoomListServiceSyncIndicator> {
    override fun read(buf: ByteBuffer) = try {
        RoomListServiceSyncIndicator.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: RoomListServiceSyncIndicator) = 4UL

    override fun write(value: RoomListServiceSyncIndicator, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Configure how many rooms will be restored when restoring the session with
 * [`Client::restore_session_with`].
 *
 * Please, see the documentation of [`matrix_sdk::store::RoomLoadSettings`] to
 * learn more.
 */
sealed class RoomLoadSettings {
    
    /**
     * Load all rooms from the `StateStore` into the in-memory state store
     * `BaseStateStore`.
     */
    object All : RoomLoadSettings()
    
    
    /**
     * Load a single room from the `StateStore` into the in-memory state
     * store `BaseStateStore`.
     *
     * Please, be careful with this option. Read the documentation of
     * [`RoomLoadSettings`].
     */
    data class One(
        val `roomId`: kotlin.String) : RoomLoadSettings() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeRoomLoadSettings : FfiConverterRustBuffer<RoomLoadSettings>{
    override fun read(buf: ByteBuffer): RoomLoadSettings {
        return when(buf.getInt()) {
            1 -> RoomLoadSettings.All
            2 -> RoomLoadSettings.One(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: RoomLoadSettings) = when(value) {
        is RoomLoadSettings.All -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomLoadSettings.One -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`roomId`)
            )
        }
    }

    override fun write(value: RoomLoadSettings, buf: ByteBuffer) {
        when(value) {
            is RoomLoadSettings.All -> {
                buf.putInt(1)
                Unit
            }
            is RoomLoadSettings.One -> {
                buf.putInt(2)
                FfiConverterString.write(value.`roomId`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class RoomMessageEventMessageType {
    
    AUDIO,
    EMOTE,
    FILE,
    GALLERY,
    IMAGE,
    LOCATION,
    NOTICE,
    SERVER_NOTICE,
    TEXT,
    VIDEO,
    VERIFICATION_REQUEST,
    OTHER;
    companion object
}


public object FfiConverterTypeRoomMessageEventMessageType: FfiConverterRustBuffer<RoomMessageEventMessageType> {
    override fun read(buf: ByteBuffer) = try {
        RoomMessageEventMessageType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: RoomMessageEventMessageType) = 4UL

    override fun write(value: RoomMessageEventMessageType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Enum representing the push notification modes for a room.
 */

enum class RoomNotificationMode {
    
    /**
     * Receive notifications for all messages.
     */
    ALL_MESSAGES,
    /**
     * Receive notifications for mentions and keywords only.
     */
    MENTIONS_AND_KEYWORDS_ONLY,
    /**
     * Do not receive any notifications.
     */
    MUTE;
    companion object
}


public object FfiConverterTypeRoomNotificationMode: FfiConverterRustBuffer<RoomNotificationMode> {
    override fun read(buf: ByteBuffer) = try {
        RoomNotificationMode.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: RoomNotificationMode) = 4UL

    override fun write(value: RoomNotificationMode, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class RoomPreset {
    
    /**
     * `join_rules` is set to `invite` and `history_visibility` is set to
     * `shared`.
     */
    PRIVATE_CHAT,
    /**
     * `join_rules` is set to `public` and `history_visibility` is set to
     * `shared`.
     */
    PUBLIC_CHAT,
    /**
     * Same as `PrivateChat`, but all initial invitees get the same power level
     * as the creator.
     */
    TRUSTED_PRIVATE_CHAT;
    companion object
}


public object FfiConverterTypeRoomPreset: FfiConverterRustBuffer<RoomPreset> {
    override fun read(buf: ByteBuffer) = try {
        RoomPreset.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: RoomPreset) = 4UL

    override fun write(value: RoomPreset, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * An update to a room send queue.
 */
sealed class RoomSendQueueUpdate: Disposable  {
    
    /**
     * A new local event is being sent.
     */
    data class NewLocalEvent(
        /**
         * Transaction id used to identify this event.
         */
        val `transactionId`: kotlin.String) : RoomSendQueueUpdate() {
        companion object
    }
    
    /**
     * A local event that hadn't been sent to the server yet has been cancelled
     * before sending.
     */
    data class CancelledLocalEvent(
        /**
         * Transaction id used to identify this event.
         */
        val `transactionId`: kotlin.String) : RoomSendQueueUpdate() {
        companion object
    }
    
    /**
     * A local event's content has been replaced with something else.
     */
    data class ReplacedLocalEvent(
        /**
         * Transaction id used to identify this event.
         */
        val `transactionId`: kotlin.String) : RoomSendQueueUpdate() {
        companion object
    }
    
    /**
     * An error happened when an event was being sent.
     *
     * The event has not been removed from the queue. All the send queues
     * will be disabled after this happens, and must be manually re-enabled.
     */
    data class SendError(
        /**
         * Transaction id used to identify this event.
         */
        val `transactionId`: kotlin.String, 
        /**
         * Error received while sending the event.
         */
        val `error`: QueueWedgeError, 
        /**
         * Whether the error is considered recoverable or not.
         *
         * An error that's recoverable will disable the room's send queue,
         * while an unrecoverable error will be parked, until the user
         * decides to cancel sending it.
         */
        val `isRecoverable`: kotlin.Boolean) : RoomSendQueueUpdate() {
        companion object
    }
    
    /**
     * The event has been unwedged and sending is now being retried.
     */
    data class RetryEvent(
        /**
         * Transaction id used to identify this event.
         */
        val `transactionId`: kotlin.String) : RoomSendQueueUpdate() {
        companion object
    }
    
    /**
     * The event has been sent to the server, and the query returned
     * successfully.
     */
    data class SentEvent(
        /**
         * Transaction id used to identify this event.
         */
        val `transactionId`: kotlin.String, 
        /**
         * Received event id from the send response.
         */
        val `eventId`: kotlin.String) : RoomSendQueueUpdate() {
        companion object
    }
    
    /**
     * A media upload (consisting of a file and possibly a thumbnail) has made
     * progress.
     */
    data class MediaUpload(
        /**
         * The media event this uploaded media relates to.
         */
        val `relatedTo`: kotlin.String, 
        /**
         * The final media source for the file if it has finished uploading.
         */
        val `file`: MediaSource?, 
        /**
         * The index of the media within the transaction. A file and its
         * thumbnail share the same index. Will always be 0 for non-gallery
         * media uploads.
         */
        val `index`: kotlin.ULong, 
        /**
         * The combined upload progress across the file and, if existing, its
         * thumbnail. For gallery uploads, the progress is reported per indexed
         * gallery item.
         */
        val `progress`: AbstractProgress) : RoomSendQueueUpdate() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is RoomSendQueueUpdate.NewLocalEvent -> {
                
        Disposable.destroy(this.`transactionId`)
    
                
            }
            is RoomSendQueueUpdate.CancelledLocalEvent -> {
                
        Disposable.destroy(this.`transactionId`)
    
                
            }
            is RoomSendQueueUpdate.ReplacedLocalEvent -> {
                
        Disposable.destroy(this.`transactionId`)
    
                
            }
            is RoomSendQueueUpdate.SendError -> {
                
        Disposable.destroy(this.`transactionId`)
    
        Disposable.destroy(this.`error`)
    
        Disposable.destroy(this.`isRecoverable`)
    
                
            }
            is RoomSendQueueUpdate.RetryEvent -> {
                
        Disposable.destroy(this.`transactionId`)
    
                
            }
            is RoomSendQueueUpdate.SentEvent -> {
                
        Disposable.destroy(this.`transactionId`)
    
        Disposable.destroy(this.`eventId`)
    
                
            }
            is RoomSendQueueUpdate.MediaUpload -> {
                
        Disposable.destroy(this.`relatedTo`)
    
        Disposable.destroy(this.`file`)
    
        Disposable.destroy(this.`index`)
    
        Disposable.destroy(this.`progress`)
    
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

public object FfiConverterTypeRoomSendQueueUpdate : FfiConverterRustBuffer<RoomSendQueueUpdate>{
    override fun read(buf: ByteBuffer): RoomSendQueueUpdate {
        return when(buf.getInt()) {
            1 -> RoomSendQueueUpdate.NewLocalEvent(
                FfiConverterString.read(buf),
                )
            2 -> RoomSendQueueUpdate.CancelledLocalEvent(
                FfiConverterString.read(buf),
                )
            3 -> RoomSendQueueUpdate.ReplacedLocalEvent(
                FfiConverterString.read(buf),
                )
            4 -> RoomSendQueueUpdate.SendError(
                FfiConverterString.read(buf),
                FfiConverterTypeQueueWedgeError.read(buf),
                FfiConverterBoolean.read(buf),
                )
            5 -> RoomSendQueueUpdate.RetryEvent(
                FfiConverterString.read(buf),
                )
            6 -> RoomSendQueueUpdate.SentEvent(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                )
            7 -> RoomSendQueueUpdate.MediaUpload(
                FfiConverterString.read(buf),
                FfiConverterOptionalTypeMediaSource.read(buf),
                FfiConverterULong.read(buf),
                FfiConverterTypeAbstractProgress.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: RoomSendQueueUpdate) = when(value) {
        is RoomSendQueueUpdate.NewLocalEvent -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`transactionId`)
            )
        }
        is RoomSendQueueUpdate.CancelledLocalEvent -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`transactionId`)
            )
        }
        is RoomSendQueueUpdate.ReplacedLocalEvent -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`transactionId`)
            )
        }
        is RoomSendQueueUpdate.SendError -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`transactionId`)
                + FfiConverterTypeQueueWedgeError.allocationSize(value.`error`)
                + FfiConverterBoolean.allocationSize(value.`isRecoverable`)
            )
        }
        is RoomSendQueueUpdate.RetryEvent -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`transactionId`)
            )
        }
        is RoomSendQueueUpdate.SentEvent -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`transactionId`)
                + FfiConverterString.allocationSize(value.`eventId`)
            )
        }
        is RoomSendQueueUpdate.MediaUpload -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`relatedTo`)
                + FfiConverterOptionalTypeMediaSource.allocationSize(value.`file`)
                + FfiConverterULong.allocationSize(value.`index`)
                + FfiConverterTypeAbstractProgress.allocationSize(value.`progress`)
            )
        }
    }

    override fun write(value: RoomSendQueueUpdate, buf: ByteBuffer) {
        when(value) {
            is RoomSendQueueUpdate.NewLocalEvent -> {
                buf.putInt(1)
                FfiConverterString.write(value.`transactionId`, buf)
                Unit
            }
            is RoomSendQueueUpdate.CancelledLocalEvent -> {
                buf.putInt(2)
                FfiConverterString.write(value.`transactionId`, buf)
                Unit
            }
            is RoomSendQueueUpdate.ReplacedLocalEvent -> {
                buf.putInt(3)
                FfiConverterString.write(value.`transactionId`, buf)
                Unit
            }
            is RoomSendQueueUpdate.SendError -> {
                buf.putInt(4)
                FfiConverterString.write(value.`transactionId`, buf)
                FfiConverterTypeQueueWedgeError.write(value.`error`, buf)
                FfiConverterBoolean.write(value.`isRecoverable`, buf)
                Unit
            }
            is RoomSendQueueUpdate.RetryEvent -> {
                buf.putInt(5)
                FfiConverterString.write(value.`transactionId`, buf)
                Unit
            }
            is RoomSendQueueUpdate.SentEvent -> {
                buf.putInt(6)
                FfiConverterString.write(value.`transactionId`, buf)
                FfiConverterString.write(value.`eventId`, buf)
                Unit
            }
            is RoomSendQueueUpdate.MediaUpload -> {
                buf.putInt(7)
                FfiConverterString.write(value.`relatedTo`, buf)
                FfiConverterOptionalTypeMediaSource.write(value.`file`, buf)
                FfiConverterULong.write(value.`index`, buf)
                FfiConverterTypeAbstractProgress.write(value.`progress`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * The type of room for a [`RoomPreviewInfo`].
 */
sealed class RoomType {
    
    /**
     * It's a plain chat room.
     */
    object Room : RoomType()
    
    
    /**
     * It's a space that can group several rooms.
     */
    object Space : RoomType()
    
    
    /**
     * It's a custom implementation.
     */
    data class Custom(
        val `value`: kotlin.String) : RoomType() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeRoomType : FfiConverterRustBuffer<RoomType>{
    override fun read(buf: ByteBuffer): RoomType {
        return when(buf.getInt()) {
            1 -> RoomType.Room
            2 -> RoomType.Space
            3 -> RoomType.Custom(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: RoomType) = when(value) {
        is RoomType.Room -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomType.Space -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomType.Custom -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: RoomType, buf: ByteBuffer) {
        when(value) {
            is RoomType.Room -> {
                buf.putInt(1)
                Unit
            }
            is RoomType.Space -> {
                buf.putInt(2)
                Unit
            }
            is RoomType.Custom -> {
                buf.putInt(3)
                FfiConverterString.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class RoomVisibility {
    
    /**
     * Indicates that the room will be shown in the published room list.
     */
    object Public : RoomVisibility()
    
    
    /**
     * Indicates that the room will not be shown in the published room list.
     */
    object Private : RoomVisibility()
    
    
    /**
     * A custom value that's not present in the spec.
     */
    data class Custom(
        val `value`: kotlin.String) : RoomVisibility() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeRoomVisibility : FfiConverterRustBuffer<RoomVisibility>{
    override fun read(buf: ByteBuffer): RoomVisibility {
        return when(buf.getInt()) {
            1 -> RoomVisibility.Public
            2 -> RoomVisibility.Private
            3 -> RoomVisibility.Custom(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: RoomVisibility) = when(value) {
        is RoomVisibility.Public -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomVisibility.Private -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RoomVisibility.Custom -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: RoomVisibility, buf: ByteBuffer) {
        when(value) {
            is RoomVisibility.Public -> {
                buf.putInt(1)
                Unit
            }
            is RoomVisibility.Private -> {
                buf.putInt(2)
                Unit
            }
            is RoomVisibility.Custom -> {
                buf.putInt(3)
                FfiConverterString.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class RtcNotificationType {
    
    RING,
    NOTIFICATION;
    companion object
}


public object FfiConverterTypeRtcNotificationType: FfiConverterRustBuffer<RtcNotificationType> {
    override fun read(buf: ByteBuffer) = try {
        RtcNotificationType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: RtcNotificationType) = 4UL

    override fun write(value: RtcNotificationType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class RuleKind {
    
    /**
     * User-configured rules that override all other kinds.
     */
    object Override : RuleKind()
    
    
    /**
     * Lowest priority user-defined rules.
     */
    object Underride : RuleKind()
    
    
    /**
     * Sender-specific rules.
     */
    object Sender : RuleKind()
    
    
    /**
     * Room-specific rules.
     */
    object Room : RuleKind()
    
    
    /**
     * Content-specific rules.
     */
    object Content : RuleKind()
    
    
    data class Custom(
        val `value`: kotlin.String) : RuleKind() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeRuleKind : FfiConverterRustBuffer<RuleKind>{
    override fun read(buf: ByteBuffer): RuleKind {
        return when(buf.getInt()) {
            1 -> RuleKind.Override
            2 -> RuleKind.Underride
            3 -> RuleKind.Sender
            4 -> RuleKind.Room
            5 -> RuleKind.Content
            6 -> RuleKind.Custom(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: RuleKind) = when(value) {
        is RuleKind.Override -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RuleKind.Underride -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RuleKind.Sender -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RuleKind.Room -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RuleKind.Content -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is RuleKind.Custom -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: RuleKind, buf: ByteBuffer) {
        when(value) {
            is RuleKind.Override -> {
                buf.putInt(1)
                Unit
            }
            is RuleKind.Underride -> {
                buf.putInt(2)
                Unit
            }
            is RuleKind.Sender -> {
                buf.putInt(3)
                Unit
            }
            is RuleKind.Room -> {
                buf.putInt(4)
                Unit
            }
            is RuleKind.Content -> {
                buf.putInt(5)
                Unit
            }
            is RuleKind.Custom -> {
                buf.putInt(6)
                FfiConverterString.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * An algorithm and its properties, used to encrypt a secret.
 */
sealed class SecretStorageEncryptionAlgorithm {
    
    /**
     * Encrypted using the `m.secret_storage.v1.aes-hmac-sha2` algorithm.
     *
     * Secrets using this method are encrypted using AES-CTR-256 and
     * authenticated using HMAC-SHA-256.
     */
    data class V1AesHmacSha2(
        val `properties`: SecretStorageV1AesHmacSha2Properties) : SecretStorageEncryptionAlgorithm() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeSecretStorageEncryptionAlgorithm : FfiConverterRustBuffer<SecretStorageEncryptionAlgorithm>{
    override fun read(buf: ByteBuffer): SecretStorageEncryptionAlgorithm {
        return when(buf.getInt()) {
            1 -> SecretStorageEncryptionAlgorithm.V1AesHmacSha2(
                FfiConverterTypeSecretStorageV1AesHmacSha2Properties.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SecretStorageEncryptionAlgorithm) = when(value) {
        is SecretStorageEncryptionAlgorithm.V1AesHmacSha2 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSecretStorageV1AesHmacSha2Properties.allocationSize(value.`properties`)
            )
        }
    }

    override fun write(value: SecretStorageEncryptionAlgorithm, buf: ByteBuffer) {
        when(value) {
            is SecretStorageEncryptionAlgorithm.V1AesHmacSha2 -> {
                buf.putInt(1)
                FfiConverterTypeSecretStorageV1AesHmacSha2Properties.write(value.`properties`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SessionVerificationData: Disposable  {
    
    data class Emojis(
        val `emojis`: List<SessionVerificationEmoji>, 
        val `indices`: kotlin.ByteArray) : SessionVerificationData() {
        companion object
    }
    
    data class Decimals(
        val `values`: List<kotlin.UShort>) : SessionVerificationData() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is SessionVerificationData.Emojis -> {
                
        Disposable.destroy(this.`emojis`)
    
        Disposable.destroy(this.`indices`)
    
                
            }
            is SessionVerificationData.Decimals -> {
                
        Disposable.destroy(this.`values`)
    
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

public object FfiConverterTypeSessionVerificationData : FfiConverterRustBuffer<SessionVerificationData>{
    override fun read(buf: ByteBuffer): SessionVerificationData {
        return when(buf.getInt()) {
            1 -> SessionVerificationData.Emojis(
                FfiConverterSequenceTypeSessionVerificationEmoji.read(buf),
                FfiConverterByteArray.read(buf),
                )
            2 -> SessionVerificationData.Decimals(
                FfiConverterSequenceUShort.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SessionVerificationData) = when(value) {
        is SessionVerificationData.Emojis -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeSessionVerificationEmoji.allocationSize(value.`emojis`)
                + FfiConverterByteArray.allocationSize(value.`indices`)
            )
        }
        is SessionVerificationData.Decimals -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceUShort.allocationSize(value.`values`)
            )
        }
    }

    override fun write(value: SessionVerificationData, buf: ByteBuffer) {
        when(value) {
            is SessionVerificationData.Emojis -> {
                buf.putInt(1)
                FfiConverterSequenceTypeSessionVerificationEmoji.write(value.`emojis`, buf)
                FfiConverterByteArray.write(value.`indices`, buf)
                Unit
            }
            is SessionVerificationData.Decimals -> {
                buf.putInt(2)
                FfiConverterSequenceUShort.write(value.`values`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Recommended decorations for decrypted messages, representing the message's
 * authenticity properties.
 */
sealed class ShieldState {
    
    /**
     * A red shield with a tooltip containing the associated message should be
     * presented.
     */
    data class Red(
        val `code`: ShieldStateCode, 
        val `message`: kotlin.String) : ShieldState() {
        companion object
    }
    
    /**
     * A grey shield with a tooltip containing the associated message should be
     * presented.
     */
    data class Grey(
        val `code`: ShieldStateCode, 
        val `message`: kotlin.String) : ShieldState() {
        companion object
    }
    
    /**
     * No shield should be presented.
     */
    object None : ShieldState()
    
    

    
    companion object
}

public object FfiConverterTypeShieldState : FfiConverterRustBuffer<ShieldState>{
    override fun read(buf: ByteBuffer): ShieldState {
        return when(buf.getInt()) {
            1 -> ShieldState.Red(
                FfiConverterTypeShieldStateCode.read(buf),
                FfiConverterString.read(buf),
                )
            2 -> ShieldState.Grey(
                FfiConverterTypeShieldStateCode.read(buf),
                FfiConverterString.read(buf),
                )
            3 -> ShieldState.None
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ShieldState) = when(value) {
        is ShieldState.Red -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeShieldStateCode.allocationSize(value.`code`)
                + FfiConverterString.allocationSize(value.`message`)
            )
        }
        is ShieldState.Grey -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeShieldStateCode.allocationSize(value.`code`)
                + FfiConverterString.allocationSize(value.`message`)
            )
        }
        is ShieldState.None -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: ShieldState, buf: ByteBuffer) {
        when(value) {
            is ShieldState.Red -> {
                buf.putInt(1)
                FfiConverterTypeShieldStateCode.write(value.`code`, buf)
                FfiConverterString.write(value.`message`, buf)
                Unit
            }
            is ShieldState.Grey -> {
                buf.putInt(2)
                FfiConverterTypeShieldStateCode.write(value.`code`, buf)
                FfiConverterString.write(value.`message`, buf)
                Unit
            }
            is ShieldState.None -> {
                buf.putInt(3)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class SlidingSyncVersion {
    
    NONE,
    NATIVE;
    companion object
}


public object FfiConverterTypeSlidingSyncVersion: FfiConverterRustBuffer<SlidingSyncVersion> {
    override fun read(buf: ByteBuffer) = try {
        SlidingSyncVersion.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: SlidingSyncVersion) = 4UL

    override fun write(value: SlidingSyncVersion, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class SlidingSyncVersionBuilder {
    
    NONE,
    NATIVE,
    DISCOVER_NATIVE;
    companion object
}


public object FfiConverterTypeSlidingSyncVersionBuilder: FfiConverterRustBuffer<SlidingSyncVersionBuilder> {
    override fun read(buf: ByteBuffer) = try {
        SlidingSyncVersionBuilder.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: SlidingSyncVersionBuilder) = 4UL

    override fun write(value: SlidingSyncVersionBuilder, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class SpaceListUpdate {
    
    data class Append(
        val `values`: List<SpaceRoom>) : SpaceListUpdate() {
        companion object
    }
    
    object Clear : SpaceListUpdate()
    
    
    data class PushFront(
        val `value`: SpaceRoom) : SpaceListUpdate() {
        companion object
    }
    
    data class PushBack(
        val `value`: SpaceRoom) : SpaceListUpdate() {
        companion object
    }
    
    object PopFront : SpaceListUpdate()
    
    
    object PopBack : SpaceListUpdate()
    
    
    data class Insert(
        val `index`: kotlin.UInt, 
        val `value`: SpaceRoom) : SpaceListUpdate() {
        companion object
    }
    
    data class Set(
        val `index`: kotlin.UInt, 
        val `value`: SpaceRoom) : SpaceListUpdate() {
        companion object
    }
    
    data class Remove(
        val `index`: kotlin.UInt) : SpaceListUpdate() {
        companion object
    }
    
    data class Truncate(
        val `length`: kotlin.UInt) : SpaceListUpdate() {
        companion object
    }
    
    data class Reset(
        val `values`: List<SpaceRoom>) : SpaceListUpdate() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeSpaceListUpdate : FfiConverterRustBuffer<SpaceListUpdate>{
    override fun read(buf: ByteBuffer): SpaceListUpdate {
        return when(buf.getInt()) {
            1 -> SpaceListUpdate.Append(
                FfiConverterSequenceTypeSpaceRoom.read(buf),
                )
            2 -> SpaceListUpdate.Clear
            3 -> SpaceListUpdate.PushFront(
                FfiConverterTypeSpaceRoom.read(buf),
                )
            4 -> SpaceListUpdate.PushBack(
                FfiConverterTypeSpaceRoom.read(buf),
                )
            5 -> SpaceListUpdate.PopFront
            6 -> SpaceListUpdate.PopBack
            7 -> SpaceListUpdate.Insert(
                FfiConverterUInt.read(buf),
                FfiConverterTypeSpaceRoom.read(buf),
                )
            8 -> SpaceListUpdate.Set(
                FfiConverterUInt.read(buf),
                FfiConverterTypeSpaceRoom.read(buf),
                )
            9 -> SpaceListUpdate.Remove(
                FfiConverterUInt.read(buf),
                )
            10 -> SpaceListUpdate.Truncate(
                FfiConverterUInt.read(buf),
                )
            11 -> SpaceListUpdate.Reset(
                FfiConverterSequenceTypeSpaceRoom.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SpaceListUpdate) = when(value) {
        is SpaceListUpdate.Append -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeSpaceRoom.allocationSize(value.`values`)
            )
        }
        is SpaceListUpdate.Clear -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SpaceListUpdate.PushFront -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSpaceRoom.allocationSize(value.`value`)
            )
        }
        is SpaceListUpdate.PushBack -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSpaceRoom.allocationSize(value.`value`)
            )
        }
        is SpaceListUpdate.PopFront -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SpaceListUpdate.PopBack -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SpaceListUpdate.Insert -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUInt.allocationSize(value.`index`)
                + FfiConverterTypeSpaceRoom.allocationSize(value.`value`)
            )
        }
        is SpaceListUpdate.Set -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUInt.allocationSize(value.`index`)
                + FfiConverterTypeSpaceRoom.allocationSize(value.`value`)
            )
        }
        is SpaceListUpdate.Remove -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUInt.allocationSize(value.`index`)
            )
        }
        is SpaceListUpdate.Truncate -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUInt.allocationSize(value.`length`)
            )
        }
        is SpaceListUpdate.Reset -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeSpaceRoom.allocationSize(value.`values`)
            )
        }
    }

    override fun write(value: SpaceListUpdate, buf: ByteBuffer) {
        when(value) {
            is SpaceListUpdate.Append -> {
                buf.putInt(1)
                FfiConverterSequenceTypeSpaceRoom.write(value.`values`, buf)
                Unit
            }
            is SpaceListUpdate.Clear -> {
                buf.putInt(2)
                Unit
            }
            is SpaceListUpdate.PushFront -> {
                buf.putInt(3)
                FfiConverterTypeSpaceRoom.write(value.`value`, buf)
                Unit
            }
            is SpaceListUpdate.PushBack -> {
                buf.putInt(4)
                FfiConverterTypeSpaceRoom.write(value.`value`, buf)
                Unit
            }
            is SpaceListUpdate.PopFront -> {
                buf.putInt(5)
                Unit
            }
            is SpaceListUpdate.PopBack -> {
                buf.putInt(6)
                Unit
            }
            is SpaceListUpdate.Insert -> {
                buf.putInt(7)
                FfiConverterUInt.write(value.`index`, buf)
                FfiConverterTypeSpaceRoom.write(value.`value`, buf)
                Unit
            }
            is SpaceListUpdate.Set -> {
                buf.putInt(8)
                FfiConverterUInt.write(value.`index`, buf)
                FfiConverterTypeSpaceRoom.write(value.`value`, buf)
                Unit
            }
            is SpaceListUpdate.Remove -> {
                buf.putInt(9)
                FfiConverterUInt.write(value.`index`, buf)
                Unit
            }
            is SpaceListUpdate.Truncate -> {
                buf.putInt(10)
                FfiConverterUInt.write(value.`length`, buf)
                Unit
            }
            is SpaceListUpdate.Reset -> {
                buf.putInt(11)
                FfiConverterSequenceTypeSpaceRoom.write(value.`values`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class SsoException(message: String): kotlin.Exception(message) {
        
        class CallbackUrlInvalid(message: String) : SsoException(message)
        
        class LoginWithTokenFailed(message: String) : SsoException(message)
        
        class Generic(message: String) : SsoException(message)
        

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<SsoException> {
        override fun lift(error_buf: RustBuffer.ByValue): SsoException = FfiConverterTypeSsoError.lift(error_buf)
    }
}

public object FfiConverterTypeSsoError : FfiConverterRustBuffer<SsoException> {
    override fun read(buf: ByteBuffer): SsoException {
        
            return when(buf.getInt()) {
            1 -> SsoException.CallbackUrlInvalid(FfiConverterString.read(buf))
            2 -> SsoException.LoginWithTokenFailed(FfiConverterString.read(buf))
            3 -> SsoException.Generic(FfiConverterString.read(buf))
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
        
    }

    override fun allocationSize(value: SsoException): ULong {
        return 4UL
    }

    override fun write(value: SsoException, buf: ByteBuffer) {
        when(value) {
            is SsoException.CallbackUrlInvalid -> {
                buf.putInt(1)
                Unit
            }
            is SsoException.LoginWithTokenFailed -> {
                buf.putInt(2)
                Unit
            }
            is SsoException.Generic -> {
                buf.putInt(3)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class StateEventContent {
    
    object PolicyRuleRoom : StateEventContent()
    
    
    object PolicyRuleServer : StateEventContent()
    
    
    object PolicyRuleUser : StateEventContent()
    
    
    object RoomAliases : StateEventContent()
    
    
    object RoomAvatar : StateEventContent()
    
    
    object RoomCanonicalAlias : StateEventContent()
    
    
    object RoomCreate : StateEventContent()
    
    
    object RoomEncryption : StateEventContent()
    
    
    object RoomGuestAccess : StateEventContent()
    
    
    object RoomHistoryVisibility : StateEventContent()
    
    
    object RoomJoinRules : StateEventContent()
    
    
    data class RoomMemberContent(
        val `userId`: kotlin.String, 
        val `membershipState`: MembershipState) : StateEventContent() {
        companion object
    }
    
    object RoomName : StateEventContent()
    
    
    object RoomPinnedEvents : StateEventContent()
    
    
    object RoomPowerLevels : StateEventContent()
    
    
    object RoomServerAcl : StateEventContent()
    
    
    object RoomThirdPartyInvite : StateEventContent()
    
    
    object RoomTombstone : StateEventContent()
    
    
    data class RoomTopic(
        val `topic`: kotlin.String) : StateEventContent() {
        companion object
    }
    
    object SpaceChild : StateEventContent()
    
    
    object SpaceParent : StateEventContent()
    
    

    
    companion object
}

public object FfiConverterTypeStateEventContent : FfiConverterRustBuffer<StateEventContent>{
    override fun read(buf: ByteBuffer): StateEventContent {
        return when(buf.getInt()) {
            1 -> StateEventContent.PolicyRuleRoom
            2 -> StateEventContent.PolicyRuleServer
            3 -> StateEventContent.PolicyRuleUser
            4 -> StateEventContent.RoomAliases
            5 -> StateEventContent.RoomAvatar
            6 -> StateEventContent.RoomCanonicalAlias
            7 -> StateEventContent.RoomCreate
            8 -> StateEventContent.RoomEncryption
            9 -> StateEventContent.RoomGuestAccess
            10 -> StateEventContent.RoomHistoryVisibility
            11 -> StateEventContent.RoomJoinRules
            12 -> StateEventContent.RoomMemberContent(
                FfiConverterString.read(buf),
                FfiConverterTypeMembershipState.read(buf),
                )
            13 -> StateEventContent.RoomName
            14 -> StateEventContent.RoomPinnedEvents
            15 -> StateEventContent.RoomPowerLevels
            16 -> StateEventContent.RoomServerAcl
            17 -> StateEventContent.RoomThirdPartyInvite
            18 -> StateEventContent.RoomTombstone
            19 -> StateEventContent.RoomTopic(
                FfiConverterString.read(buf),
                )
            20 -> StateEventContent.SpaceChild
            21 -> StateEventContent.SpaceParent
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: StateEventContent) = when(value) {
        is StateEventContent.PolicyRuleRoom -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is StateEventContent.PolicyRuleServer -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is StateEventContent.PolicyRuleUser -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is StateEventContent.RoomAliases -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is StateEventContent.RoomAvatar -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is StateEventContent.RoomCanonicalAlias -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is StateEventContent.RoomCreate -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is StateEventContent.RoomEncryption -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is StateEventContent.RoomGuestAccess -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is StateEventContent.RoomHistoryVisibility -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is StateEventContent.RoomJoinRules -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is StateEventContent.RoomMemberContent -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`userId`)
                + FfiConverterTypeMembershipState.allocationSize(value.`membershipState`)
            )
        }
        is StateEventContent.RoomName -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is StateEventContent.RoomPinnedEvents -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is StateEventContent.RoomPowerLevels -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is StateEventContent.RoomServerAcl -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is StateEventContent.RoomThirdPartyInvite -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is StateEventContent.RoomTombstone -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is StateEventContent.RoomTopic -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`topic`)
            )
        }
        is StateEventContent.SpaceChild -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is StateEventContent.SpaceParent -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: StateEventContent, buf: ByteBuffer) {
        when(value) {
            is StateEventContent.PolicyRuleRoom -> {
                buf.putInt(1)
                Unit
            }
            is StateEventContent.PolicyRuleServer -> {
                buf.putInt(2)
                Unit
            }
            is StateEventContent.PolicyRuleUser -> {
                buf.putInt(3)
                Unit
            }
            is StateEventContent.RoomAliases -> {
                buf.putInt(4)
                Unit
            }
            is StateEventContent.RoomAvatar -> {
                buf.putInt(5)
                Unit
            }
            is StateEventContent.RoomCanonicalAlias -> {
                buf.putInt(6)
                Unit
            }
            is StateEventContent.RoomCreate -> {
                buf.putInt(7)
                Unit
            }
            is StateEventContent.RoomEncryption -> {
                buf.putInt(8)
                Unit
            }
            is StateEventContent.RoomGuestAccess -> {
                buf.putInt(9)
                Unit
            }
            is StateEventContent.RoomHistoryVisibility -> {
                buf.putInt(10)
                Unit
            }
            is StateEventContent.RoomJoinRules -> {
                buf.putInt(11)
                Unit
            }
            is StateEventContent.RoomMemberContent -> {
                buf.putInt(12)
                FfiConverterString.write(value.`userId`, buf)
                FfiConverterTypeMembershipState.write(value.`membershipState`, buf)
                Unit
            }
            is StateEventContent.RoomName -> {
                buf.putInt(13)
                Unit
            }
            is StateEventContent.RoomPinnedEvents -> {
                buf.putInt(14)
                Unit
            }
            is StateEventContent.RoomPowerLevels -> {
                buf.putInt(15)
                Unit
            }
            is StateEventContent.RoomServerAcl -> {
                buf.putInt(16)
                Unit
            }
            is StateEventContent.RoomThirdPartyInvite -> {
                buf.putInt(17)
                Unit
            }
            is StateEventContent.RoomTombstone -> {
                buf.putInt(18)
                Unit
            }
            is StateEventContent.RoomTopic -> {
                buf.putInt(19)
                FfiConverterString.write(value.`topic`, buf)
                Unit
            }
            is StateEventContent.SpaceChild -> {
                buf.putInt(20)
                Unit
            }
            is StateEventContent.SpaceParent -> {
                buf.putInt(21)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class StateEventType {
    
    CALL_MEMBER,
    POLICY_RULE_ROOM,
    POLICY_RULE_SERVER,
    POLICY_RULE_USER,
    ROOM_ALIASES,
    ROOM_AVATAR,
    ROOM_CANONICAL_ALIAS,
    ROOM_CREATE,
    ROOM_ENCRYPTION,
    ROOM_GUEST_ACCESS,
    ROOM_HISTORY_VISIBILITY,
    ROOM_JOIN_RULES,
    ROOM_MEMBER_EVENT,
    ROOM_NAME,
    ROOM_PINNED_EVENTS,
    ROOM_POWER_LEVELS,
    ROOM_SERVER_ACL,
    ROOM_THIRD_PARTY_INVITE,
    ROOM_TOMBSTONE,
    ROOM_TOPIC,
    SPACE_CHILD,
    SPACE_PARENT;
    companion object
}


public object FfiConverterTypeStateEventType: FfiConverterRustBuffer<StateEventType> {
    override fun read(buf: ByteBuffer) = try {
        StateEventType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: StateEventType) = 4UL

    override fun write(value: StateEventType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







sealed class SteadyStateException(message: String): kotlin.Exception(message) {
        
        class BackupDisabled(message: String) : SteadyStateException(message)
        
        class Connection(message: String) : SteadyStateException(message)
        
        class Lagged(message: String) : SteadyStateException(message)
        

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<SteadyStateException> {
        override fun lift(error_buf: RustBuffer.ByValue): SteadyStateException = FfiConverterTypeSteadyStateError.lift(error_buf)
    }
}

public object FfiConverterTypeSteadyStateError : FfiConverterRustBuffer<SteadyStateException> {
    override fun read(buf: ByteBuffer): SteadyStateException {
        
            return when(buf.getInt()) {
            1 -> SteadyStateException.BackupDisabled(FfiConverterString.read(buf))
            2 -> SteadyStateException.Connection(FfiConverterString.read(buf))
            3 -> SteadyStateException.Lagged(FfiConverterString.read(buf))
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
        
    }

    override fun allocationSize(value: SteadyStateException): ULong {
        return 4UL
    }

    override fun write(value: SteadyStateException, buf: ByteBuffer) {
        when(value) {
            is SteadyStateException.BackupDisabled -> {
                buf.putInt(1)
                Unit
            }
            is SteadyStateException.Connection -> {
                buf.putInt(2)
                Unit
            }
            is SteadyStateException.Lagged -> {
                buf.putInt(3)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




enum class SyncServiceState {
    
    IDLE,
    RUNNING,
    TERMINATED,
    ERROR,
    OFFLINE;
    companion object
}


public object FfiConverterTypeSyncServiceState: FfiConverterRustBuffer<SyncServiceState> {
    override fun read(buf: ByteBuffer) = try {
        SyncServiceState.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: SyncServiceState) = 4UL

    override fun write(value: SyncServiceState, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * The name of a tag.
 */
sealed class TagName {
    
    /**
     * `m.favourite`: The user's favorite rooms.
     */
    object Favorite : TagName()
    
    
    /**
     * `m.lowpriority`: These should be shown with lower precedence than
     * others.
     */
    object LowPriority : TagName()
    
    
    /**
     * `m.server_notice`: Used to identify
     */
    object ServerNotice : TagName()
    
    
    /**
     * `u.*`: User-defined tag
     */
    data class User(
        val `name`: UserTagName) : TagName() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeTagName : FfiConverterRustBuffer<TagName>{
    override fun read(buf: ByteBuffer): TagName {
        return when(buf.getInt()) {
            1 -> TagName.Favorite
            2 -> TagName.LowPriority
            3 -> TagName.ServerNotice
            4 -> TagName.User(
                FfiConverterTypeUserTagName.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TagName) = when(value) {
        is TagName.Favorite -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is TagName.LowPriority -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is TagName.ServerNotice -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is TagName.User -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUserTagName.allocationSize(value.`name`)
            )
        }
    }

    override fun write(value: TagName, buf: ByteBuffer) {
        when(value) {
            is TagName.Favorite -> {
                buf.putInt(1)
                Unit
            }
            is TagName.LowPriority -> {
                buf.putInt(2)
                Unit
            }
            is TagName.ServerNotice -> {
                buf.putInt(3)
                Unit
            }
            is TagName.User -> {
                buf.putInt(4)
                FfiConverterTypeUserTagName.write(value.`name`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class TimelineDiff: Disposable  {
    
    data class Append(
        val `values`: List<TimelineItem>) : TimelineDiff() {
        companion object
    }
    
    object Clear : TimelineDiff()
    
    
    data class PushFront(
        val `value`: TimelineItem) : TimelineDiff() {
        companion object
    }
    
    data class PushBack(
        val `value`: TimelineItem) : TimelineDiff() {
        companion object
    }
    
    object PopFront : TimelineDiff()
    
    
    object PopBack : TimelineDiff()
    
    
    data class Insert(
        val `index`: kotlin.UInt, 
        val `value`: TimelineItem) : TimelineDiff() {
        companion object
    }
    
    data class Set(
        val `index`: kotlin.UInt, 
        val `value`: TimelineItem) : TimelineDiff() {
        companion object
    }
    
    data class Remove(
        val `index`: kotlin.UInt) : TimelineDiff() {
        companion object
    }
    
    data class Truncate(
        val `length`: kotlin.UInt) : TimelineDiff() {
        companion object
    }
    
    data class Reset(
        val `values`: List<TimelineItem>) : TimelineDiff() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TimelineDiff.Append -> {
                
        Disposable.destroy(this.`values`)
    
                
            }
            is TimelineDiff.Clear -> {// Nothing to destroy
            }
            is TimelineDiff.PushFront -> {
                
        Disposable.destroy(this.`value`)
    
                
            }
            is TimelineDiff.PushBack -> {
                
        Disposable.destroy(this.`value`)
    
                
            }
            is TimelineDiff.PopFront -> {// Nothing to destroy
            }
            is TimelineDiff.PopBack -> {// Nothing to destroy
            }
            is TimelineDiff.Insert -> {
                
        Disposable.destroy(this.`index`)
    
        Disposable.destroy(this.`value`)
    
                
            }
            is TimelineDiff.Set -> {
                
        Disposable.destroy(this.`index`)
    
        Disposable.destroy(this.`value`)
    
                
            }
            is TimelineDiff.Remove -> {
                
        Disposable.destroy(this.`index`)
    
                
            }
            is TimelineDiff.Truncate -> {
                
        Disposable.destroy(this.`length`)
    
                
            }
            is TimelineDiff.Reset -> {
                
        Disposable.destroy(this.`values`)
    
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

public object FfiConverterTypeTimelineDiff : FfiConverterRustBuffer<TimelineDiff>{
    override fun read(buf: ByteBuffer): TimelineDiff {
        return when(buf.getInt()) {
            1 -> TimelineDiff.Append(
                FfiConverterSequenceTypeTimelineItem.read(buf),
                )
            2 -> TimelineDiff.Clear
            3 -> TimelineDiff.PushFront(
                FfiConverterTypeTimelineItem.read(buf),
                )
            4 -> TimelineDiff.PushBack(
                FfiConverterTypeTimelineItem.read(buf),
                )
            5 -> TimelineDiff.PopFront
            6 -> TimelineDiff.PopBack
            7 -> TimelineDiff.Insert(
                FfiConverterUInt.read(buf),
                FfiConverterTypeTimelineItem.read(buf),
                )
            8 -> TimelineDiff.Set(
                FfiConverterUInt.read(buf),
                FfiConverterTypeTimelineItem.read(buf),
                )
            9 -> TimelineDiff.Remove(
                FfiConverterUInt.read(buf),
                )
            10 -> TimelineDiff.Truncate(
                FfiConverterUInt.read(buf),
                )
            11 -> TimelineDiff.Reset(
                FfiConverterSequenceTypeTimelineItem.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TimelineDiff) = when(value) {
        is TimelineDiff.Append -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeTimelineItem.allocationSize(value.`values`)
            )
        }
        is TimelineDiff.Clear -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is TimelineDiff.PushFront -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTimelineItem.allocationSize(value.`value`)
            )
        }
        is TimelineDiff.PushBack -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTimelineItem.allocationSize(value.`value`)
            )
        }
        is TimelineDiff.PopFront -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is TimelineDiff.PopBack -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is TimelineDiff.Insert -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUInt.allocationSize(value.`index`)
                + FfiConverterTypeTimelineItem.allocationSize(value.`value`)
            )
        }
        is TimelineDiff.Set -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUInt.allocationSize(value.`index`)
                + FfiConverterTypeTimelineItem.allocationSize(value.`value`)
            )
        }
        is TimelineDiff.Remove -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUInt.allocationSize(value.`index`)
            )
        }
        is TimelineDiff.Truncate -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUInt.allocationSize(value.`length`)
            )
        }
        is TimelineDiff.Reset -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeTimelineItem.allocationSize(value.`values`)
            )
        }
    }

    override fun write(value: TimelineDiff, buf: ByteBuffer) {
        when(value) {
            is TimelineDiff.Append -> {
                buf.putInt(1)
                FfiConverterSequenceTypeTimelineItem.write(value.`values`, buf)
                Unit
            }
            is TimelineDiff.Clear -> {
                buf.putInt(2)
                Unit
            }
            is TimelineDiff.PushFront -> {
                buf.putInt(3)
                FfiConverterTypeTimelineItem.write(value.`value`, buf)
                Unit
            }
            is TimelineDiff.PushBack -> {
                buf.putInt(4)
                FfiConverterTypeTimelineItem.write(value.`value`, buf)
                Unit
            }
            is TimelineDiff.PopFront -> {
                buf.putInt(5)
                Unit
            }
            is TimelineDiff.PopBack -> {
                buf.putInt(6)
                Unit
            }
            is TimelineDiff.Insert -> {
                buf.putInt(7)
                FfiConverterUInt.write(value.`index`, buf)
                FfiConverterTypeTimelineItem.write(value.`value`, buf)
                Unit
            }
            is TimelineDiff.Set -> {
                buf.putInt(8)
                FfiConverterUInt.write(value.`index`, buf)
                FfiConverterTypeTimelineItem.write(value.`value`, buf)
                Unit
            }
            is TimelineDiff.Remove -> {
                buf.putInt(9)
                FfiConverterUInt.write(value.`index`, buf)
                Unit
            }
            is TimelineDiff.Truncate -> {
                buf.putInt(10)
                FfiConverterUInt.write(value.`length`, buf)
                Unit
            }
            is TimelineDiff.Reset -> {
                buf.putInt(11)
                FfiConverterSequenceTypeTimelineItem.write(value.`values`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class TimelineEventType: Disposable  {
    
    data class MessageLike(
        val `content`: MessageLikeEventContent) : TimelineEventType() {
        companion object
    }
    
    data class State(
        val `content`: StateEventContent) : TimelineEventType() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TimelineEventType.MessageLike -> {
                
        Disposable.destroy(this.`content`)
    
                
            }
            is TimelineEventType.State -> {
                
        Disposable.destroy(this.`content`)
    
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

public object FfiConverterTypeTimelineEventType : FfiConverterRustBuffer<TimelineEventType>{
    override fun read(buf: ByteBuffer): TimelineEventType {
        return when(buf.getInt()) {
            1 -> TimelineEventType.MessageLike(
                FfiConverterTypeMessageLikeEventContent.read(buf),
                )
            2 -> TimelineEventType.State(
                FfiConverterTypeStateEventContent.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TimelineEventType) = when(value) {
        is TimelineEventType.MessageLike -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMessageLikeEventContent.allocationSize(value.`content`)
            )
        }
        is TimelineEventType.State -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeStateEventContent.allocationSize(value.`content`)
            )
        }
    }

    override fun write(value: TimelineEventType, buf: ByteBuffer) {
        when(value) {
            is TimelineEventType.MessageLike -> {
                buf.putInt(1)
                FfiConverterTypeMessageLikeEventContent.write(value.`content`, buf)
                Unit
            }
            is TimelineEventType.State -> {
                buf.putInt(2)
                FfiConverterTypeStateEventContent.write(value.`content`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class TimelineFilter: Disposable  {
    
    /**
     * Show all the events in the timeline, independent of their type.
     */
    object All : TimelineFilter()
    
    
    /**
     * Show only `m.room.messages` of the given room message types.
     */
    data class OnlyMessage(
        /**
         * A list of [`RoomMessageEventMessageType`] that will be allowed to
         * appear in the timeline.
         */
        val `types`: List<RoomMessageEventMessageType>) : TimelineFilter() {
        companion object
    }
    
    /**
     * Show only events which match this filter.
     */
    data class EventTypeFilter(
        val `filter`: TimelineEventTypeFilter) : TimelineFilter() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TimelineFilter.All -> {// Nothing to destroy
            }
            is TimelineFilter.OnlyMessage -> {
                
        Disposable.destroy(this.`types`)
    
                
            }
            is TimelineFilter.EventTypeFilter -> {
                
        Disposable.destroy(this.`filter`)
    
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

public object FfiConverterTypeTimelineFilter : FfiConverterRustBuffer<TimelineFilter>{
    override fun read(buf: ByteBuffer): TimelineFilter {
        return when(buf.getInt()) {
            1 -> TimelineFilter.All
            2 -> TimelineFilter.OnlyMessage(
                FfiConverterSequenceTypeRoomMessageEventMessageType.read(buf),
                )
            3 -> TimelineFilter.EventTypeFilter(
                FfiConverterTypeTimelineEventTypeFilter.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TimelineFilter) = when(value) {
        is TimelineFilter.All -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is TimelineFilter.OnlyMessage -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeRoomMessageEventMessageType.allocationSize(value.`types`)
            )
        }
        is TimelineFilter.EventTypeFilter -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTimelineEventTypeFilter.allocationSize(value.`filter`)
            )
        }
    }

    override fun write(value: TimelineFilter, buf: ByteBuffer) {
        when(value) {
            is TimelineFilter.All -> {
                buf.putInt(1)
                Unit
            }
            is TimelineFilter.OnlyMessage -> {
                buf.putInt(2)
                FfiConverterSequenceTypeRoomMessageEventMessageType.write(value.`types`, buf)
                Unit
            }
            is TimelineFilter.EventTypeFilter -> {
                buf.putInt(3)
                FfiConverterTypeTimelineEventTypeFilter.write(value.`filter`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class TimelineFocus {
    
    data class Live(
        /**
         * Whether to hide in-thread replies from the live timeline.
         */
        val `hideThreadedEvents`: kotlin.Boolean) : TimelineFocus() {
        companion object
    }
    
    data class Event(
        /**
         * The initial event to focus on. This is usually the target of a
         * permalink.
         */
        val `eventId`: kotlin.String, 
        /**
         * The number of context events to load around the focused event.
         */
        val `numContextEvents`: kotlin.UShort, 
        /**
         * Whether to hide in-thread replies from the live timeline.
         */
        val `hideThreadedEvents`: kotlin.Boolean) : TimelineFocus() {
        companion object
    }
    
    data class Thread(
        /**
         * The thread root event ID to focus on.
         */
        val `rootEventId`: kotlin.String) : TimelineFocus() {
        companion object
    }
    
    data class PinnedEvents(
        val `maxEventsToLoad`: kotlin.UShort, 
        val `maxConcurrentRequests`: kotlin.UShort) : TimelineFocus() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeTimelineFocus : FfiConverterRustBuffer<TimelineFocus>{
    override fun read(buf: ByteBuffer): TimelineFocus {
        return when(buf.getInt()) {
            1 -> TimelineFocus.Live(
                FfiConverterBoolean.read(buf),
                )
            2 -> TimelineFocus.Event(
                FfiConverterString.read(buf),
                FfiConverterUShort.read(buf),
                FfiConverterBoolean.read(buf),
                )
            3 -> TimelineFocus.Thread(
                FfiConverterString.read(buf),
                )
            4 -> TimelineFocus.PinnedEvents(
                FfiConverterUShort.read(buf),
                FfiConverterUShort.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TimelineFocus) = when(value) {
        is TimelineFocus.Live -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterBoolean.allocationSize(value.`hideThreadedEvents`)
            )
        }
        is TimelineFocus.Event -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`eventId`)
                + FfiConverterUShort.allocationSize(value.`numContextEvents`)
                + FfiConverterBoolean.allocationSize(value.`hideThreadedEvents`)
            )
        }
        is TimelineFocus.Thread -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`rootEventId`)
            )
        }
        is TimelineFocus.PinnedEvents -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUShort.allocationSize(value.`maxEventsToLoad`)
                + FfiConverterUShort.allocationSize(value.`maxConcurrentRequests`)
            )
        }
    }

    override fun write(value: TimelineFocus, buf: ByteBuffer) {
        when(value) {
            is TimelineFocus.Live -> {
                buf.putInt(1)
                FfiConverterBoolean.write(value.`hideThreadedEvents`, buf)
                Unit
            }
            is TimelineFocus.Event -> {
                buf.putInt(2)
                FfiConverterString.write(value.`eventId`, buf)
                FfiConverterUShort.write(value.`numContextEvents`, buf)
                FfiConverterBoolean.write(value.`hideThreadedEvents`, buf)
                Unit
            }
            is TimelineFocus.Thread -> {
                buf.putInt(3)
                FfiConverterString.write(value.`rootEventId`, buf)
                Unit
            }
            is TimelineFocus.PinnedEvents -> {
                buf.putInt(4)
                FfiConverterUShort.write(value.`maxEventsToLoad`, buf)
                FfiConverterUShort.write(value.`maxConcurrentRequests`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class TimelineItemContent: Disposable  {
    
    data class MsgLike(
        val `content`: MsgLikeContent) : TimelineItemContent() {
        companion object
    }
    
    object CallInvite : TimelineItemContent()
    
    
    object RtcNotification : TimelineItemContent()
    
    
    data class RoomMembership(
        val `userId`: kotlin.String, 
        val `userDisplayName`: kotlin.String?, 
        val `change`: MembershipChange?, 
        val `reason`: kotlin.String?) : TimelineItemContent() {
        companion object
    }
    
    data class ProfileChange(
        val `displayName`: kotlin.String?, 
        val `prevDisplayName`: kotlin.String?, 
        val `avatarUrl`: kotlin.String?, 
        val `prevAvatarUrl`: kotlin.String?) : TimelineItemContent() {
        companion object
    }
    
    data class State(
        val `stateKey`: kotlin.String, 
        val `content`: OtherState) : TimelineItemContent() {
        companion object
    }
    
    data class FailedToParseMessageLike(
        val `eventType`: kotlin.String, 
        val `error`: kotlin.String) : TimelineItemContent() {
        companion object
    }
    
    data class FailedToParseState(
        val `eventType`: kotlin.String, 
        val `stateKey`: kotlin.String, 
        val `error`: kotlin.String) : TimelineItemContent() {
        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TimelineItemContent.MsgLike -> {
                
        Disposable.destroy(this.`content`)
    
                
            }
            is TimelineItemContent.CallInvite -> {// Nothing to destroy
            }
            is TimelineItemContent.RtcNotification -> {// Nothing to destroy
            }
            is TimelineItemContent.RoomMembership -> {
                
        Disposable.destroy(this.`userId`)
    
        Disposable.destroy(this.`userDisplayName`)
    
        Disposable.destroy(this.`change`)
    
        Disposable.destroy(this.`reason`)
    
                
            }
            is TimelineItemContent.ProfileChange -> {
                
        Disposable.destroy(this.`displayName`)
    
        Disposable.destroy(this.`prevDisplayName`)
    
        Disposable.destroy(this.`avatarUrl`)
    
        Disposable.destroy(this.`prevAvatarUrl`)
    
                
            }
            is TimelineItemContent.State -> {
                
        Disposable.destroy(this.`stateKey`)
    
        Disposable.destroy(this.`content`)
    
                
            }
            is TimelineItemContent.FailedToParseMessageLike -> {
                
        Disposable.destroy(this.`eventType`)
    
        Disposable.destroy(this.`error`)
    
                
            }
            is TimelineItemContent.FailedToParseState -> {
                
        Disposable.destroy(this.`eventType`)
    
        Disposable.destroy(this.`stateKey`)
    
        Disposable.destroy(this.`error`)
    
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

public object FfiConverterTypeTimelineItemContent : FfiConverterRustBuffer<TimelineItemContent>{
    override fun read(buf: ByteBuffer): TimelineItemContent {
        return when(buf.getInt()) {
            1 -> TimelineItemContent.MsgLike(
                FfiConverterTypeMsgLikeContent.read(buf),
                )
            2 -> TimelineItemContent.CallInvite
            3 -> TimelineItemContent.RtcNotification
            4 -> TimelineItemContent.RoomMembership(
                FfiConverterString.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalTypeMembershipChange.read(buf),
                FfiConverterOptionalString.read(buf),
                )
            5 -> TimelineItemContent.ProfileChange(
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalString.read(buf),
                )
            6 -> TimelineItemContent.State(
                FfiConverterString.read(buf),
                FfiConverterTypeOtherState.read(buf),
                )
            7 -> TimelineItemContent.FailedToParseMessageLike(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                )
            8 -> TimelineItemContent.FailedToParseState(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TimelineItemContent) = when(value) {
        is TimelineItemContent.MsgLike -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMsgLikeContent.allocationSize(value.`content`)
            )
        }
        is TimelineItemContent.CallInvite -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is TimelineItemContent.RtcNotification -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is TimelineItemContent.RoomMembership -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`userId`)
                + FfiConverterOptionalString.allocationSize(value.`userDisplayName`)
                + FfiConverterOptionalTypeMembershipChange.allocationSize(value.`change`)
                + FfiConverterOptionalString.allocationSize(value.`reason`)
            )
        }
        is TimelineItemContent.ProfileChange -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalString.allocationSize(value.`displayName`)
                + FfiConverterOptionalString.allocationSize(value.`prevDisplayName`)
                + FfiConverterOptionalString.allocationSize(value.`avatarUrl`)
                + FfiConverterOptionalString.allocationSize(value.`prevAvatarUrl`)
            )
        }
        is TimelineItemContent.State -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`stateKey`)
                + FfiConverterTypeOtherState.allocationSize(value.`content`)
            )
        }
        is TimelineItemContent.FailedToParseMessageLike -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`eventType`)
                + FfiConverterString.allocationSize(value.`error`)
            )
        }
        is TimelineItemContent.FailedToParseState -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`eventType`)
                + FfiConverterString.allocationSize(value.`stateKey`)
                + FfiConverterString.allocationSize(value.`error`)
            )
        }
    }

    override fun write(value: TimelineItemContent, buf: ByteBuffer) {
        when(value) {
            is TimelineItemContent.MsgLike -> {
                buf.putInt(1)
                FfiConverterTypeMsgLikeContent.write(value.`content`, buf)
                Unit
            }
            is TimelineItemContent.CallInvite -> {
                buf.putInt(2)
                Unit
            }
            is TimelineItemContent.RtcNotification -> {
                buf.putInt(3)
                Unit
            }
            is TimelineItemContent.RoomMembership -> {
                buf.putInt(4)
                FfiConverterString.write(value.`userId`, buf)
                FfiConverterOptionalString.write(value.`userDisplayName`, buf)
                FfiConverterOptionalTypeMembershipChange.write(value.`change`, buf)
                FfiConverterOptionalString.write(value.`reason`, buf)
                Unit
            }
            is TimelineItemContent.ProfileChange -> {
                buf.putInt(5)
                FfiConverterOptionalString.write(value.`displayName`, buf)
                FfiConverterOptionalString.write(value.`prevDisplayName`, buf)
                FfiConverterOptionalString.write(value.`avatarUrl`, buf)
                FfiConverterOptionalString.write(value.`prevAvatarUrl`, buf)
                Unit
            }
            is TimelineItemContent.State -> {
                buf.putInt(6)
                FfiConverterString.write(value.`stateKey`, buf)
                FfiConverterTypeOtherState.write(value.`content`, buf)
                Unit
            }
            is TimelineItemContent.FailedToParseMessageLike -> {
                buf.putInt(7)
                FfiConverterString.write(value.`eventType`, buf)
                FfiConverterString.write(value.`error`, buf)
                Unit
            }
            is TimelineItemContent.FailedToParseState -> {
                buf.putInt(8)
                FfiConverterString.write(value.`eventType`, buf)
                FfiConverterString.write(value.`stateKey`, buf)
                FfiConverterString.write(value.`error`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * A log pack can be used to set the trace log level for a group of multiple
 * log targets at once, for debugging purposes.
 */

enum class TraceLogPacks {
    
    /**
     * Enables all the logs relevant to the event cache.
     */
    EVENT_CACHE,
    /**
     * Enables all the logs relevant to the send queue.
     */
    SEND_QUEUE,
    /**
     * Enables all the logs relevant to the timeline.
     */
    TIMELINE,
    /**
     * Enables all the logs relevant to the notification client.
     */
    NOTIFICATION_CLIENT,
    /**
     * Enables all the logs relevant to sync profiling.
     */
    SYNC_PROFILING;
    companion object
}


public object FfiConverterTypeTraceLogPacks: FfiConverterRustBuffer<TraceLogPacks> {
    override fun read(buf: ByteBuffer) = try {
        TraceLogPacks.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: TraceLogPacks) = 4UL

    override fun write(value: TraceLogPacks, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * Enum representing the push notification tweaks for a rule.
 */
sealed class Tweak {
    
    /**
     * A string representing the sound to be played when this notification
     * arrives.
     *
     * A value of "default" means to play a default sound. A device may choose
     * to alert the user by some other means if appropriate, eg. vibration.
     */
    data class Sound(
        val `value`: kotlin.String) : Tweak() {
        companion object
    }
    
    /**
     * A boolean representing whether or not this message should be highlighted
     * in the UI.
     */
    data class Highlight(
        val `value`: kotlin.Boolean) : Tweak() {
        companion object
    }
    
    /**
     * A custom tweak
     */
    data class Custom(
        /**
         * The name of the custom tweak (`set_tweak` field)
         */
        val `name`: kotlin.String, 
        /**
         * The value of the custom tweak as an encoded JSON string
         */
        val `value`: kotlin.String) : Tweak() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeTweak : FfiConverterRustBuffer<Tweak>{
    override fun read(buf: ByteBuffer): Tweak {
        return when(buf.getInt()) {
            1 -> Tweak.Sound(
                FfiConverterString.read(buf),
                )
            2 -> Tweak.Highlight(
                FfiConverterBoolean.read(buf),
                )
            3 -> Tweak.Custom(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: Tweak) = when(value) {
        is Tweak.Sound -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`value`)
            )
        }
        is Tweak.Highlight -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterBoolean.allocationSize(value.`value`)
            )
        }
        is Tweak.Custom -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`name`)
                + FfiConverterString.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: Tweak, buf: ByteBuffer) {
        when(value) {
            is Tweak.Sound -> {
                buf.putInt(1)
                FfiConverterString.write(value.`value`, buf)
                Unit
            }
            is Tweak.Highlight -> {
                buf.putInt(2)
                FfiConverterBoolean.write(value.`value`, buf)
                Unit
            }
            is Tweak.Custom -> {
                buf.putInt(3)
                FfiConverterString.write(value.`name`, buf)
                FfiConverterString.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * A source for uploading a file
 */
sealed class UploadSource {
    
    /**
     * Upload source is a file on disk
     */
    data class File(
        /**
         * Path to file
         */
        val `filename`: kotlin.String) : UploadSource() {
        companion object
    }
    
    /**
     * Upload source is data in memory
     */
    data class Data(
        /**
         * Bytes being uploaded
         */
        val `bytes`: kotlin.ByteArray, 
        /**
         * Filename to associate with bytes
         */
        val `filename`: kotlin.String) : UploadSource() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeUploadSource : FfiConverterRustBuffer<UploadSource>{
    override fun read(buf: ByteBuffer): UploadSource {
        return when(buf.getInt()) {
            1 -> UploadSource.File(
                FfiConverterString.read(buf),
                )
            2 -> UploadSource.Data(
                FfiConverterByteArray.read(buf),
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: UploadSource) = when(value) {
        is UploadSource.File -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`filename`)
            )
        }
        is UploadSource.Data -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterByteArray.allocationSize(value.`bytes`)
                + FfiConverterString.allocationSize(value.`filename`)
            )
        }
    }

    override fun write(value: UploadSource, buf: ByteBuffer) {
        when(value) {
            is UploadSource.File -> {
                buf.putInt(1)
                FfiConverterString.write(value.`filename`, buf)
                Unit
            }
            is UploadSource.Data -> {
                buf.putInt(2)
                FfiConverterByteArray.write(value.`bytes`, buf)
                FfiConverterString.write(value.`filename`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class VerificationState {
    
    UNKNOWN,
    VERIFIED,
    UNVERIFIED;
    companion object
}


public object FfiConverterTypeVerificationState: FfiConverterRustBuffer<VerificationState> {
    override fun read(buf: ByteBuffer) = try {
        VerificationState.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: VerificationState) = 4UL

    override fun write(value: VerificationState, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * A [`TimelineItem`](super::TimelineItem) that doesn't correspond to an event.
 */
sealed class VirtualTimelineItem {
    
    /**
     * A divider between messages of different day or month depending on
     * timeline settings.
     */
    data class DateDivider(
        /**
         * A timestamp in milliseconds since Unix Epoch on that day in local
         * time.
         */
        val `ts`: Timestamp) : VirtualTimelineItem() {
        companion object
    }
    
    /**
     * The user's own read marker.
     */
    object ReadMarker : VirtualTimelineItem()
    
    
    /**
     * The timeline start, that is, the *oldest* event in time for that room.
     */
    object TimelineStart : VirtualTimelineItem()
    
    

    
    companion object
}

public object FfiConverterTypeVirtualTimelineItem : FfiConverterRustBuffer<VirtualTimelineItem>{
    override fun read(buf: ByteBuffer): VirtualTimelineItem {
        return when(buf.getInt()) {
            1 -> VirtualTimelineItem.DateDivider(
                FfiConverterTypeTimestamp.read(buf),
                )
            2 -> VirtualTimelineItem.ReadMarker
            3 -> VirtualTimelineItem.TimelineStart
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: VirtualTimelineItem) = when(value) {
        is VirtualTimelineItem.DateDivider -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTimestamp.allocationSize(value.`ts`)
            )
        }
        is VirtualTimelineItem.ReadMarker -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is VirtualTimelineItem.TimelineStart -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: VirtualTimelineItem, buf: ByteBuffer) {
        when(value) {
            is VirtualTimelineItem.DateDivider -> {
                buf.putInt(1)
                FfiConverterTypeTimestamp.write(value.`ts`, buf)
                Unit
            }
            is VirtualTimelineItem.ReadMarker -> {
                buf.putInt(2)
                Unit
            }
            is VirtualTimelineItem.TimelineStart -> {
                buf.putInt(3)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * Different kinds of filters that could be applied to the timeline events.
 */
sealed class WidgetEventFilter {
    
    /**
     * Matches message-like events with the given `type`.
     */
    data class MessageLikeWithType(
        val `eventType`: kotlin.String) : WidgetEventFilter() {
        companion object
    }
    
    /**
     * Matches `m.room.message` events with the given `msgtype`.
     */
    data class RoomMessageWithMsgtype(
        val `msgtype`: kotlin.String) : WidgetEventFilter() {
        companion object
    }
    
    /**
     * Matches state events with the given `type`, regardless of `state_key`.
     */
    data class StateWithType(
        val `eventType`: kotlin.String) : WidgetEventFilter() {
        companion object
    }
    
    /**
     * Matches state events with the given `type` and `state_key`.
     */
    data class StateWithTypeAndStateKey(
        val `eventType`: kotlin.String, 
        val `stateKey`: kotlin.String) : WidgetEventFilter() {
        companion object
    }
    
    /**
     * Matches to-device events with the given `event_type`.
     */
    data class ToDevice(
        val `eventType`: kotlin.String) : WidgetEventFilter() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeWidgetEventFilter : FfiConverterRustBuffer<WidgetEventFilter>{
    override fun read(buf: ByteBuffer): WidgetEventFilter {
        return when(buf.getInt()) {
            1 -> WidgetEventFilter.MessageLikeWithType(
                FfiConverterString.read(buf),
                )
            2 -> WidgetEventFilter.RoomMessageWithMsgtype(
                FfiConverterString.read(buf),
                )
            3 -> WidgetEventFilter.StateWithType(
                FfiConverterString.read(buf),
                )
            4 -> WidgetEventFilter.StateWithTypeAndStateKey(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                )
            5 -> WidgetEventFilter.ToDevice(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: WidgetEventFilter) = when(value) {
        is WidgetEventFilter.MessageLikeWithType -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`eventType`)
            )
        }
        is WidgetEventFilter.RoomMessageWithMsgtype -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`msgtype`)
            )
        }
        is WidgetEventFilter.StateWithType -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`eventType`)
            )
        }
        is WidgetEventFilter.StateWithTypeAndStateKey -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`eventType`)
                + FfiConverterString.allocationSize(value.`stateKey`)
            )
        }
        is WidgetEventFilter.ToDevice -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`eventType`)
            )
        }
    }

    override fun write(value: WidgetEventFilter, buf: ByteBuffer) {
        when(value) {
            is WidgetEventFilter.MessageLikeWithType -> {
                buf.putInt(1)
                FfiConverterString.write(value.`eventType`, buf)
                Unit
            }
            is WidgetEventFilter.RoomMessageWithMsgtype -> {
                buf.putInt(2)
                FfiConverterString.write(value.`msgtype`, buf)
                Unit
            }
            is WidgetEventFilter.StateWithType -> {
                buf.putInt(3)
                FfiConverterString.write(value.`eventType`, buf)
                Unit
            }
            is WidgetEventFilter.StateWithTypeAndStateKey -> {
                buf.putInt(4)
                FfiConverterString.write(value.`eventType`, buf)
                FfiConverterString.write(value.`stateKey`, buf)
                Unit
            }
            is WidgetEventFilter.ToDevice -> {
                buf.putInt(5)
                FfiConverterString.write(value.`eventType`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







/**
 * A listener for changes of global account data events.
 */
public interface AccountDataListener {
    
    /**
     * Called when a global account data event has changed.
     */
    fun `onChange`(`event`: AccountDataEvent)
    
    companion object
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
internal const val IDX_CALLBACK_FREE = 0
// Callback return codes
internal const val UNIFFI_CALLBACK_SUCCESS = 0
internal const val UNIFFI_CALLBACK_ERROR = 1
internal const val UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

public abstract class FfiConverterCallbackInterface<CallbackInterface: Any>: FfiConverter<CallbackInterface, Long> {
    internal val handleMap = UniffiHandleMap<CallbackInterface>()

    internal fun drop(handle: Long) {
        handleMap.remove(handle)
    }

    override fun lift(value: Long): CallbackInterface {
        return handleMap.get(value)
    }

    override fun read(buf: ByteBuffer) = lift(buf.getLong())

    override fun lower(value: CallbackInterface) = handleMap.insert(value)

    override fun allocationSize(value: CallbackInterface) = 8UL

    override fun write(value: CallbackInterface, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}

// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceAccountDataListener {
    internal object `onChange`: UniffiCallbackInterfaceAccountDataListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`event`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeAccountDataListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onChange`(
                    FfiConverterTypeAccountDataEvent.lift(`event`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeAccountDataListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceAccountDataListener.UniffiByValue(
        `onChange`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_accountdatalistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeAccountDataListener: FfiConverterCallbackInterface<AccountDataListener>()





public interface BackupStateListener {
    
    fun `onUpdate`(`status`: BackupState)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceBackupStateListener {
    internal object `onUpdate`: UniffiCallbackInterfaceBackupStateListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`status`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeBackupStateListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                    FfiConverterTypeBackupState.lift(`status`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeBackupStateListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceBackupStateListener.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_backupstatelistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeBackupStateListener: FfiConverterCallbackInterface<BackupStateListener>()





public interface BackupSteadyStateListener {
    
    fun `onUpdate`(`status`: BackupUploadState)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceBackupSteadyStateListener {
    internal object `onUpdate`: UniffiCallbackInterfaceBackupSteadyStateListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`status`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeBackupSteadyStateListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                    FfiConverterTypeBackupUploadState.lift(`status`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeBackupSteadyStateListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceBackupSteadyStateListener.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_backupsteadystatelistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeBackupSteadyStateListener: FfiConverterCallbackInterface<BackupSteadyStateListener>()





/**
 * A listener for receiving call decline events in a room.
 */
public interface CallDeclineListener {
    
    fun `call`(`declinerUserId`: kotlin.String)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceCallDeclineListener {
    internal object `call`: UniffiCallbackInterfaceCallDeclineListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`declinerUserId`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeCallDeclineListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`call`(
                    FfiConverterString.lift(`declinerUserId`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeCallDeclineListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceCallDeclineListener.UniffiByValue(
        `call`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_calldeclinelistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeCallDeclineListener: FfiConverterCallbackInterface<CallDeclineListener>()





public interface ClientDelegate {
    
    fun `didReceiveAuthError`(`isSoftLogout`: kotlin.Boolean)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceClientDelegate {
    internal object `didReceiveAuthError`: UniffiCallbackInterfaceClientDelegateMethod0 {
        override fun callback(`uniffiHandle`: Long,`isSoftLogout`: Byte,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeClientDelegate.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`didReceiveAuthError`(
                    FfiConverterBoolean.lift(`isSoftLogout`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeClientDelegate.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceClientDelegate.UniffiByValue(
        `didReceiveAuthError`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_clientdelegate(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeClientDelegate: FfiConverterCallbackInterface<ClientDelegate>()





public interface ClientSessionDelegate {
    
    fun `retrieveSessionFromKeychain`(`userId`: kotlin.String): Session
    
    fun `saveSessionInKeychain`(`session`: Session)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceClientSessionDelegate {
    internal object `retrieveSessionFromKeychain`: UniffiCallbackInterfaceClientSessionDelegateMethod0 {
        override fun callback(`uniffiHandle`: Long,`userId`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeClientSessionDelegate.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`retrieveSessionFromKeychain`(
                    FfiConverterString.lift(`userId`),
                )
            }
            val writeReturn = { value: Session -> uniffiOutReturn.setValue(FfiConverterTypeSession.lower(value)) }
            uniffiTraitInterfaceCallWithError(
                uniffiCallStatus,
                makeCall,
                writeReturn,
                { e: ClientException -> FfiConverterTypeClientError.lower(e) }
            )
        }
    }
    internal object `saveSessionInKeychain`: UniffiCallbackInterfaceClientSessionDelegateMethod1 {
        override fun callback(`uniffiHandle`: Long,`session`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeClientSessionDelegate.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`saveSessionInKeychain`(
                    FfiConverterTypeSession.lift(`session`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeClientSessionDelegate.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceClientSessionDelegate.UniffiByValue(
        `retrieveSessionFromKeychain`,
        `saveSessionInKeychain`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_clientsessiondelegate(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeClientSessionDelegate: FfiConverterCallbackInterface<ClientSessionDelegate>()





public interface EnableRecoveryProgressListener {
    
    fun `onUpdate`(`status`: EnableRecoveryProgress)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceEnableRecoveryProgressListener {
    internal object `onUpdate`: UniffiCallbackInterfaceEnableRecoveryProgressListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`status`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeEnableRecoveryProgressListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                    FfiConverterTypeEnableRecoveryProgress.lift(`status`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeEnableRecoveryProgressListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceEnableRecoveryProgressListener.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_enablerecoveryprogresslistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeEnableRecoveryProgressListener: FfiConverterCallbackInterface<EnableRecoveryProgressListener>()





public interface GeneratedQrLoginProgressListener {
    
    fun `onUpdate`(`state`: GeneratedQrLoginProgress)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceGeneratedQrLoginProgressListener {
    internal object `onUpdate`: UniffiCallbackInterfaceGeneratedQrLoginProgressListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`state`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeGeneratedQrLoginProgressListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                    FfiConverterTypeGeneratedQrLoginProgress.lift(`state`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeGeneratedQrLoginProgressListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceGeneratedQrLoginProgressListener.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_generatedqrloginprogresslistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeGeneratedQrLoginProgressListener: FfiConverterCallbackInterface<GeneratedQrLoginProgressListener>()





public interface IdentityStatusChangeListener {
    
    fun `call`(`identityStatusChange`: List<IdentityStatusChange>)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceIdentityStatusChangeListener {
    internal object `call`: UniffiCallbackInterfaceIdentityStatusChangeListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`identityStatusChange`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeIdentityStatusChangeListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`call`(
                    FfiConverterSequenceTypeIdentityStatusChange.lift(`identityStatusChange`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeIdentityStatusChangeListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceIdentityStatusChangeListener.UniffiByValue(
        `call`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_identitystatuschangelistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeIdentityStatusChangeListener: FfiConverterCallbackInterface<IdentityStatusChangeListener>()





public interface IgnoredUsersListener {
    
    fun `call`(`ignoredUserIds`: List<kotlin.String>)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceIgnoredUsersListener {
    internal object `call`: UniffiCallbackInterfaceIgnoredUsersListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`ignoredUserIds`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeIgnoredUsersListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`call`(
                    FfiConverterSequenceString.lift(`ignoredUserIds`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeIgnoredUsersListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceIgnoredUsersListener.UniffiByValue(
        `call`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_ignoreduserslistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeIgnoredUsersListener: FfiConverterCallbackInterface<IgnoredUsersListener>()





/**
 * A listener for receiving new requests to a join a room.
 */
public interface KnockRequestsListener {
    
    fun `call`(`joinRequests`: List<KnockRequest>)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceKnockRequestsListener {
    internal object `call`: UniffiCallbackInterfaceKnockRequestsListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`joinRequests`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeKnockRequestsListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`call`(
                    FfiConverterSequenceTypeKnockRequest.lift(`joinRequests`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeKnockRequestsListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceKnockRequestsListener.UniffiByValue(
        `call`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_knockrequestslistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeKnockRequestsListener: FfiConverterCallbackInterface<KnockRequestsListener>()





/**
 * A listener for receiving new live location shares in a room.
 */
public interface LiveLocationShareListener {
    
    fun `call`(`liveLocationShares`: List<LiveLocationShare>)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceLiveLocationShareListener {
    internal object `call`: UniffiCallbackInterfaceLiveLocationShareListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`liveLocationShares`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeLiveLocationShareListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`call`(
                    FfiConverterSequenceTypeLiveLocationShare.lift(`liveLocationShares`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeLiveLocationShareListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceLiveLocationShareListener.UniffiByValue(
        `call`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_livelocationsharelistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeLiveLocationShareListener: FfiConverterCallbackInterface<LiveLocationShareListener>()





public interface MediaPreviewConfigListener {
    
    fun `onChange`(`mediaPreviewConfig`: MediaPreviewConfig?)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceMediaPreviewConfigListener {
    internal object `onChange`: UniffiCallbackInterfaceMediaPreviewConfigListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`mediaPreviewConfig`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeMediaPreviewConfigListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onChange`(
                    FfiConverterOptionalTypeMediaPreviewConfig.lift(`mediaPreviewConfig`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeMediaPreviewConfigListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceMediaPreviewConfigListener.UniffiByValue(
        `onChange`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_mediapreviewconfiglistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeMediaPreviewConfigListener: FfiConverterCallbackInterface<MediaPreviewConfigListener>()





/**
 * Delegate to notify of changes in push rules
 */
public interface NotificationSettingsDelegate {
    
    fun `settingsDidChange`()
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceNotificationSettingsDelegate {
    internal object `settingsDidChange`: UniffiCallbackInterfaceNotificationSettingsDelegateMethod0 {
        override fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeNotificationSettingsDelegate.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`settingsDidChange`(
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeNotificationSettingsDelegate.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceNotificationSettingsDelegate.UniffiByValue(
        `settingsDidChange`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_notificationsettingsdelegate(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeNotificationSettingsDelegate: FfiConverterCallbackInterface<NotificationSettingsDelegate>()





public interface PaginationStatusListener {
    
    fun `onUpdate`(`status`: RoomPaginationStatus)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfacePaginationStatusListener {
    internal object `onUpdate`: UniffiCallbackInterfacePaginationStatusListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`status`: RustBufferRoomPaginationStatus.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypePaginationStatusListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                    FfiConverterTypeRoomPaginationStatus.lift(`status`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypePaginationStatusListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfacePaginationStatusListener.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_paginationstatuslistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypePaginationStatusListener: FfiConverterCallbackInterface<PaginationStatusListener>()





public interface ProgressWatcher {
    
    fun `transmissionProgress`(`progress`: TransmissionProgress)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceProgressWatcher {
    internal object `transmissionProgress`: UniffiCallbackInterfaceProgressWatcherMethod0 {
        override fun callback(`uniffiHandle`: Long,`progress`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeProgressWatcher.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`transmissionProgress`(
                    FfiConverterTypeTransmissionProgress.lift(`progress`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeProgressWatcher.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceProgressWatcher.UniffiByValue(
        `transmissionProgress`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_progresswatcher(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeProgressWatcher: FfiConverterCallbackInterface<ProgressWatcher>()





public interface QrLoginProgressListener {
    
    fun `onUpdate`(`state`: QrLoginProgress)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceQrLoginProgressListener {
    internal object `onUpdate`: UniffiCallbackInterfaceQrLoginProgressListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`state`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeQrLoginProgressListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                    FfiConverterTypeQrLoginProgress.lift(`state`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeQrLoginProgressListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceQrLoginProgressListener.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_qrloginprogresslistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeQrLoginProgressListener: FfiConverterCallbackInterface<QrLoginProgressListener>()





public interface RecoveryStateListener {
    
    fun `onUpdate`(`status`: RecoveryState)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceRecoveryStateListener {
    internal object `onUpdate`: UniffiCallbackInterfaceRecoveryStateListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`status`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeRecoveryStateListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                    FfiConverterTypeRecoveryState.lift(`status`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeRecoveryStateListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceRecoveryStateListener.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_recoverystatelistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeRecoveryStateListener: FfiConverterCallbackInterface<RecoveryStateListener>()





/**
 * A listener for changes of room account data events.
 */
public interface RoomAccountDataListener {
    
    /**
     * Called when a room account data event was changed.
     */
    fun `onChange`(`event`: RoomAccountDataEvent, `roomId`: kotlin.String)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceRoomAccountDataListener {
    internal object `onChange`: UniffiCallbackInterfaceRoomAccountDataListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`event`: RustBuffer.ByValue,`roomId`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeRoomAccountDataListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onChange`(
                    FfiConverterTypeRoomAccountDataEvent.lift(`event`),
                    FfiConverterString.lift(`roomId`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeRoomAccountDataListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceRoomAccountDataListener.UniffiByValue(
        `onChange`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomaccountdatalistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeRoomAccountDataListener: FfiConverterCallbackInterface<RoomAccountDataListener>()





public interface RoomDirectorySearchEntriesListener {
    
    fun `onUpdate`(`roomEntriesUpdate`: List<RoomDirectorySearchEntryUpdate>)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceRoomDirectorySearchEntriesListener {
    internal object `onUpdate`: UniffiCallbackInterfaceRoomDirectorySearchEntriesListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`roomEntriesUpdate`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeRoomDirectorySearchEntriesListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                    FfiConverterSequenceTypeRoomDirectorySearchEntryUpdate.lift(`roomEntriesUpdate`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeRoomDirectorySearchEntriesListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceRoomDirectorySearchEntriesListener.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomdirectorysearchentrieslistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeRoomDirectorySearchEntriesListener: FfiConverterCallbackInterface<RoomDirectorySearchEntriesListener>()





public interface RoomInfoListener {
    
    fun `call`(`roomInfo`: RoomInfo)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceRoomInfoListener {
    internal object `call`: UniffiCallbackInterfaceRoomInfoListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`roomInfo`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeRoomInfoListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`call`(
                    FfiConverterTypeRoomInfo.lift(`roomInfo`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeRoomInfoListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceRoomInfoListener.UniffiByValue(
        `call`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roominfolistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeRoomInfoListener: FfiConverterCallbackInterface<RoomInfoListener>()





public interface RoomListEntriesListener {
    
    fun `onUpdate`(`roomEntriesUpdate`: List<RoomListEntriesUpdate>)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceRoomListEntriesListener {
    internal object `onUpdate`: UniffiCallbackInterfaceRoomListEntriesListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`roomEntriesUpdate`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeRoomListEntriesListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                    FfiConverterSequenceTypeRoomListEntriesUpdate.lift(`roomEntriesUpdate`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeRoomListEntriesListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceRoomListEntriesListener.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistentrieslistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeRoomListEntriesListener: FfiConverterCallbackInterface<RoomListEntriesListener>()





public interface RoomListLoadingStateListener {
    
    fun `onUpdate`(`state`: RoomListLoadingState)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceRoomListLoadingStateListener {
    internal object `onUpdate`: UniffiCallbackInterfaceRoomListLoadingStateListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`state`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeRoomListLoadingStateListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                    FfiConverterTypeRoomListLoadingState.lift(`state`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeRoomListLoadingStateListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceRoomListLoadingStateListener.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistloadingstatelistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeRoomListLoadingStateListener: FfiConverterCallbackInterface<RoomListLoadingStateListener>()





public interface RoomListServiceStateListener {
    
    fun `onUpdate`(`state`: RoomListServiceState)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceRoomListServiceStateListener {
    internal object `onUpdate`: UniffiCallbackInterfaceRoomListServiceStateListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`state`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeRoomListServiceStateListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                    FfiConverterTypeRoomListServiceState.lift(`state`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeRoomListServiceStateListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceRoomListServiceStateListener.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistservicestatelistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeRoomListServiceStateListener: FfiConverterCallbackInterface<RoomListServiceStateListener>()





public interface RoomListServiceSyncIndicatorListener {
    
    fun `onUpdate`(`syncIndicator`: RoomListServiceSyncIndicator)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceRoomListServiceSyncIndicatorListener {
    internal object `onUpdate`: UniffiCallbackInterfaceRoomListServiceSyncIndicatorListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`syncIndicator`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeRoomListServiceSyncIndicatorListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                    FfiConverterTypeRoomListServiceSyncIndicator.lift(`syncIndicator`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeRoomListServiceSyncIndicatorListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceRoomListServiceSyncIndicatorListener.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistservicesyncindicatorlistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeRoomListServiceSyncIndicatorListener: FfiConverterCallbackInterface<RoomListServiceSyncIndicatorListener>()





/**
 * A listener to send queue updates in a specific room.
 */
public interface SendQueueListener {
    
    /**
     * Called every time the send queue dispatches an update for the given
     * room.
     */
    fun `onUpdate`(`update`: RoomSendQueueUpdate)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceSendQueueListener {
    internal object `onUpdate`: UniffiCallbackInterfaceSendQueueListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`update`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSendQueueListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                    FfiConverterTypeRoomSendQueueUpdate.lift(`update`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeSendQueueListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceSendQueueListener.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sendqueuelistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeSendQueueListener: FfiConverterCallbackInterface<SendQueueListener>()





/**
 * A listener to the global (client-wide) error reporter of the send queue.
 */
public interface SendQueueRoomErrorListener {
    
    /**
     * Called every time the send queue has ran into an error for a given room,
     * which will disable the send queue for that particular room.
     */
    fun `onError`(`roomId`: kotlin.String, `error`: ClientException)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceSendQueueRoomErrorListener {
    internal object `onError`: UniffiCallbackInterfaceSendQueueRoomErrorListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`roomId`: RustBuffer.ByValue,`error`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSendQueueRoomErrorListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onError`(
                    FfiConverterString.lift(`roomId`),
                    FfiConverterTypeClientError.lift(`error`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeSendQueueRoomErrorListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceSendQueueRoomErrorListener.UniffiByValue(
        `onError`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sendqueueroomerrorlistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeSendQueueRoomErrorListener: FfiConverterCallbackInterface<SendQueueRoomErrorListener>()





/**
 * A listener to the global (client-wide) update reporter of the send queue.
 */
public interface SendQueueRoomUpdateListener {
    
    /**
     * Called every time the send queue emits an update for a given room.
     */
    fun `onUpdate`(`roomId`: kotlin.String, `update`: RoomSendQueueUpdate)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceSendQueueRoomUpdateListener {
    internal object `onUpdate`: UniffiCallbackInterfaceSendQueueRoomUpdateListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`roomId`: RustBuffer.ByValue,`update`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSendQueueRoomUpdateListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                    FfiConverterString.lift(`roomId`),
                    FfiConverterTypeRoomSendQueueUpdate.lift(`update`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeSendQueueRoomUpdateListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceSendQueueRoomUpdateListener.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sendqueueroomupdatelistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeSendQueueRoomUpdateListener: FfiConverterCallbackInterface<SendQueueRoomUpdateListener>()





public interface SessionVerificationControllerDelegate {
    
    fun `didReceiveVerificationRequest`(`details`: SessionVerificationRequestDetails)
    
    fun `didAcceptVerificationRequest`()
    
    fun `didStartSasVerification`()
    
    fun `didReceiveVerificationData`(`data`: SessionVerificationData)
    
    fun `didFail`()
    
    fun `didCancel`()
    
    fun `didFinish`()
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceSessionVerificationControllerDelegate {
    internal object `didReceiveVerificationRequest`: UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod0 {
        override fun callback(`uniffiHandle`: Long,`details`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSessionVerificationControllerDelegate.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`didReceiveVerificationRequest`(
                    FfiConverterTypeSessionVerificationRequestDetails.lift(`details`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `didAcceptVerificationRequest`: UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod1 {
        override fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSessionVerificationControllerDelegate.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`didAcceptVerificationRequest`(
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `didStartSasVerification`: UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod2 {
        override fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSessionVerificationControllerDelegate.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`didStartSasVerification`(
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `didReceiveVerificationData`: UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod3 {
        override fun callback(`uniffiHandle`: Long,`data`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSessionVerificationControllerDelegate.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`didReceiveVerificationData`(
                    FfiConverterTypeSessionVerificationData.lift(`data`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `didFail`: UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod4 {
        override fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSessionVerificationControllerDelegate.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`didFail`(
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `didCancel`: UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod5 {
        override fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSessionVerificationControllerDelegate.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`didCancel`(
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `didFinish`: UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod6 {
        override fun callback(`uniffiHandle`: Long,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSessionVerificationControllerDelegate.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`didFinish`(
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeSessionVerificationControllerDelegate.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceSessionVerificationControllerDelegate.UniffiByValue(
        `didReceiveVerificationRequest`,
        `didAcceptVerificationRequest`,
        `didStartSasVerification`,
        `didReceiveVerificationData`,
        `didFail`,
        `didCancel`,
        `didFinish`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sessionverificationcontrollerdelegate(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeSessionVerificationControllerDelegate: FfiConverterCallbackInterface<SessionVerificationControllerDelegate>()





public interface SpaceRoomListEntriesListener {
    
    fun `onUpdate`(`rooms`: List<SpaceListUpdate>)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceSpaceRoomListEntriesListener {
    internal object `onUpdate`: UniffiCallbackInterfaceSpaceRoomListEntriesListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`rooms`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSpaceRoomListEntriesListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                    FfiConverterSequenceTypeSpaceListUpdate.lift(`rooms`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeSpaceRoomListEntriesListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceSpaceRoomListEntriesListener.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_spaceroomlistentrieslistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeSpaceRoomListEntriesListener: FfiConverterCallbackInterface<SpaceRoomListEntriesListener>()





public interface SpaceRoomListPaginationStateListener {
    
    fun `onUpdate`(`paginationState`: SpaceRoomListPaginationState)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceSpaceRoomListPaginationStateListener {
    internal object `onUpdate`: UniffiCallbackInterfaceSpaceRoomListPaginationStateListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`paginationState`: RustBufferSpaceRoomListPaginationState.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSpaceRoomListPaginationStateListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                    FfiConverterTypeSpaceRoomListPaginationState.lift(`paginationState`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeSpaceRoomListPaginationStateListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceSpaceRoomListPaginationStateListener.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_spaceroomlistpaginationstatelistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeSpaceRoomListPaginationStateListener: FfiConverterCallbackInterface<SpaceRoomListPaginationStateListener>()





public interface SpaceRoomListSpaceListener {
    
    fun `onUpdate`(`space`: SpaceRoom?)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceSpaceRoomListSpaceListener {
    internal object `onUpdate`: UniffiCallbackInterfaceSpaceRoomListSpaceListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`space`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSpaceRoomListSpaceListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                    FfiConverterOptionalTypeSpaceRoom.lift(`space`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeSpaceRoomListSpaceListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceSpaceRoomListSpaceListener.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_spaceroomlistspacelistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeSpaceRoomListSpaceListener: FfiConverterCallbackInterface<SpaceRoomListSpaceListener>()





public interface SpaceServiceJoinedSpacesListener {
    
    fun `onUpdate`(`roomUpdates`: List<SpaceListUpdate>)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceSpaceServiceJoinedSpacesListener {
    internal object `onUpdate`: UniffiCallbackInterfaceSpaceServiceJoinedSpacesListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`roomUpdates`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSpaceServiceJoinedSpacesListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                    FfiConverterSequenceTypeSpaceListUpdate.lift(`roomUpdates`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeSpaceServiceJoinedSpacesListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceSpaceServiceJoinedSpacesListener.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_spaceservicejoinedspaceslistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeSpaceServiceJoinedSpacesListener: FfiConverterCallbackInterface<SpaceServiceJoinedSpacesListener>()





public interface SyncServiceStateObserver {
    
    fun `onUpdate`(`state`: SyncServiceState)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceSyncServiceStateObserver {
    internal object `onUpdate`: UniffiCallbackInterfaceSyncServiceStateObserverMethod0 {
        override fun callback(`uniffiHandle`: Long,`state`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSyncServiceStateObserver.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                    FfiConverterTypeSyncServiceState.lift(`state`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeSyncServiceStateObserver.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceSyncServiceStateObserver.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_syncservicestateobserver(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeSyncServiceStateObserver: FfiConverterCallbackInterface<SyncServiceStateObserver>()





public interface TimelineListener {
    
    fun `onUpdate`(`diff`: List<TimelineDiff>)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceTimelineListener {
    internal object `onUpdate`: UniffiCallbackInterfaceTimelineListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`diff`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeTimelineListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                    FfiConverterSequenceTypeTimelineDiff.lift(`diff`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeTimelineListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceTimelineListener.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_timelinelistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeTimelineListener: FfiConverterCallbackInterface<TimelineListener>()





public interface TypingNotificationsListener {
    
    fun `call`(`typingUserIds`: List<kotlin.String>)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceTypingNotificationsListener {
    internal object `call`: UniffiCallbackInterfaceTypingNotificationsListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`typingUserIds`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeTypingNotificationsListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`call`(
                    FfiConverterSequenceString.lift(`typingUserIds`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeTypingNotificationsListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceTypingNotificationsListener.UniffiByValue(
        `call`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_typingnotificationslistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeTypingNotificationsListener: FfiConverterCallbackInterface<TypingNotificationsListener>()





public interface UnableToDecryptDelegate {
    
    fun `onUtd`(`info`: UnableToDecryptInfo)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceUnableToDecryptDelegate {
    internal object `onUtd`: UniffiCallbackInterfaceUnableToDecryptDelegateMethod0 {
        override fun callback(`uniffiHandle`: Long,`info`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeUnableToDecryptDelegate.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUtd`(
                    FfiConverterTypeUnableToDecryptInfo.lift(`info`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeUnableToDecryptDelegate.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceUnableToDecryptDelegate.UniffiByValue(
        `onUtd`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_unabletodecryptdelegate(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeUnableToDecryptDelegate: FfiConverterCallbackInterface<UnableToDecryptDelegate>()





public interface VerificationStateListener {
    
    fun `onUpdate`(`status`: VerificationState)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceVerificationStateListener {
    internal object `onUpdate`: UniffiCallbackInterfaceVerificationStateListenerMethod0 {
        override fun callback(`uniffiHandle`: Long,`status`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeVerificationStateListener.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`onUpdate`(
                    FfiConverterTypeVerificationState.lift(`status`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeVerificationStateListener.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceVerificationStateListener.UniffiByValue(
        `onUpdate`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_verificationstatelistener(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeVerificationStateListener: FfiConverterCallbackInterface<VerificationStateListener>()





public interface WidgetCapabilitiesProvider {
    
    fun `acquireCapabilities`(`capabilities`: WidgetCapabilities): WidgetCapabilities
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceWidgetCapabilitiesProvider {
    internal object `acquireCapabilities`: UniffiCallbackInterfaceWidgetCapabilitiesProviderMethod0 {
        override fun callback(`uniffiHandle`: Long,`capabilities`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeWidgetCapabilitiesProvider.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`acquireCapabilities`(
                    FfiConverterTypeWidgetCapabilities.lift(`capabilities`),
                )
            }
            val writeReturn = { value: WidgetCapabilities -> uniffiOutReturn.setValue(FfiConverterTypeWidgetCapabilities.lower(value)) }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeWidgetCapabilitiesProvider.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceWidgetCapabilitiesProvider.UniffiByValue(
        `acquireCapabilities`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_widgetcapabilitiesprovider(vtable)
    }
}

// The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
public object FfiConverterTypeWidgetCapabilitiesProvider: FfiConverterCallbackInterface<WidgetCapabilitiesProvider>()




public object FfiConverterOptionalUByte: FfiConverterRustBuffer<kotlin.UByte?> {
    override fun read(buf: ByteBuffer): kotlin.UByte? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterUByte.read(buf)
    }

    override fun allocationSize(value: kotlin.UByte?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterUByte.allocationSize(value)
        }
    }

    override fun write(value: kotlin.UByte?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterUByte.write(value, buf)
        }
    }
}




public object FfiConverterOptionalUShort: FfiConverterRustBuffer<kotlin.UShort?> {
    override fun read(buf: ByteBuffer): kotlin.UShort? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterUShort.read(buf)
    }

    override fun allocationSize(value: kotlin.UShort?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterUShort.allocationSize(value)
        }
    }

    override fun write(value: kotlin.UShort?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterUShort.write(value, buf)
        }
    }
}




public object FfiConverterOptionalUInt: FfiConverterRustBuffer<kotlin.UInt?> {
    override fun read(buf: ByteBuffer): kotlin.UInt? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterUInt.read(buf)
    }

    override fun allocationSize(value: kotlin.UInt?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterUInt.allocationSize(value)
        }
    }

    override fun write(value: kotlin.UInt?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterUInt.write(value, buf)
        }
    }
}




public object FfiConverterOptionalInt: FfiConverterRustBuffer<kotlin.Int?> {
    override fun read(buf: ByteBuffer): kotlin.Int? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterInt.read(buf)
    }

    override fun allocationSize(value: kotlin.Int?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterInt.allocationSize(value)
        }
    }

    override fun write(value: kotlin.Int?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterInt.write(value, buf)
        }
    }
}




public object FfiConverterOptionalULong: FfiConverterRustBuffer<kotlin.ULong?> {
    override fun read(buf: ByteBuffer): kotlin.ULong? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterULong.read(buf)
    }

    override fun allocationSize(value: kotlin.ULong?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterULong.allocationSize(value)
        }
    }

    override fun write(value: kotlin.ULong?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterULong.write(value, buf)
        }
    }
}




public object FfiConverterOptionalDouble: FfiConverterRustBuffer<kotlin.Double?> {
    override fun read(buf: ByteBuffer): kotlin.Double? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterDouble.read(buf)
    }

    override fun allocationSize(value: kotlin.Double?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterDouble.allocationSize(value)
        }
    }

    override fun write(value: kotlin.Double?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterDouble.write(value, buf)
        }
    }
}




public object FfiConverterOptionalBoolean: FfiConverterRustBuffer<kotlin.Boolean?> {
    override fun read(buf: ByteBuffer): kotlin.Boolean? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterBoolean.read(buf)
    }

    override fun allocationSize(value: kotlin.Boolean?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterBoolean.allocationSize(value)
        }
    }

    override fun write(value: kotlin.Boolean?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterBoolean.write(value, buf)
        }
    }
}




public object FfiConverterOptionalString: FfiConverterRustBuffer<kotlin.String?> {
    override fun read(buf: ByteBuffer): kotlin.String? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterString.read(buf)
    }

    override fun allocationSize(value: kotlin.String?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterString.allocationSize(value)
        }
    }

    override fun write(value: kotlin.String?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterString.write(value, buf)
        }
    }
}




public object FfiConverterOptionalDuration: FfiConverterRustBuffer<java.time.Duration?> {
    override fun read(buf: ByteBuffer): java.time.Duration? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterDuration.read(buf)
    }

    override fun allocationSize(value: java.time.Duration?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterDuration.allocationSize(value)
        }
    }

    override fun write(value: java.time.Duration?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterDuration.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeIdentityResetHandle: FfiConverterRustBuffer<IdentityResetHandle?> {
    override fun read(buf: ByteBuffer): IdentityResetHandle? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeIdentityResetHandle.read(buf)
    }

    override fun allocationSize(value: IdentityResetHandle?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeIdentityResetHandle.allocationSize(value)
        }
    }

    override fun write(value: IdentityResetHandle?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeIdentityResetHandle.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeInReplyToDetails: FfiConverterRustBuffer<InReplyToDetails?> {
    override fun read(buf: ByteBuffer): InReplyToDetails? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeInReplyToDetails.read(buf)
    }

    override fun allocationSize(value: InReplyToDetails?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeInReplyToDetails.allocationSize(value)
        }
    }

    override fun write(value: InReplyToDetails?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeInReplyToDetails.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeMediaSource: FfiConverterRustBuffer<MediaSource?> {
    override fun read(buf: ByteBuffer): MediaSource? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeMediaSource.read(buf)
    }

    override fun allocationSize(value: MediaSource?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeMediaSource.allocationSize(value)
        }
    }

    override fun write(value: MediaSource?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeMediaSource.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeRoom: FfiConverterRustBuffer<Room?> {
    override fun read(buf: ByteBuffer): Room? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeRoom.read(buf)
    }

    override fun allocationSize(value: Room?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeRoom.allocationSize(value)
        }
    }

    override fun write(value: Room?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeRoom.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeRoomMessageEventContentWithoutRelation: FfiConverterRustBuffer<RoomMessageEventContentWithoutRelation?> {
    override fun read(buf: ByteBuffer): RoomMessageEventContentWithoutRelation? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeRoomMessageEventContentWithoutRelation.read(buf)
    }

    override fun allocationSize(value: RoomMessageEventContentWithoutRelation?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeRoomMessageEventContentWithoutRelation.allocationSize(value)
        }
    }

    override fun write(value: RoomMessageEventContentWithoutRelation?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeRoomMessageEventContentWithoutRelation.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeRoomPowerLevels: FfiConverterRustBuffer<RoomPowerLevels?> {
    override fun read(buf: ByteBuffer): RoomPowerLevels? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeRoomPowerLevels.read(buf)
    }

    override fun allocationSize(value: RoomPowerLevels?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeRoomPowerLevels.allocationSize(value)
        }
    }

    override fun write(value: RoomPowerLevels?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeRoomPowerLevels.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeSendHandle: FfiConverterRustBuffer<SendHandle?> {
    override fun read(buf: ByteBuffer): SendHandle? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeSendHandle.read(buf)
    }

    override fun allocationSize(value: SendHandle?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeSendHandle.allocationSize(value)
        }
    }

    override fun write(value: SendHandle?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeSendHandle.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeSyncService: FfiConverterRustBuffer<SyncService?> {
    override fun read(buf: ByteBuffer): SyncService? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeSyncService.read(buf)
    }

    override fun allocationSize(value: SyncService?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeSyncService.allocationSize(value)
        }
    }

    override fun write(value: SyncService?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeSyncService.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeTaskHandle: FfiConverterRustBuffer<TaskHandle?> {
    override fun read(buf: ByteBuffer): TaskHandle? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeTaskHandle.read(buf)
    }

    override fun allocationSize(value: TaskHandle?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeTaskHandle.allocationSize(value)
        }
    }

    override fun write(value: TaskHandle?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeTaskHandle.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeThreadSummary: FfiConverterRustBuffer<ThreadSummary?> {
    override fun read(buf: ByteBuffer): ThreadSummary? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeThreadSummary.read(buf)
    }

    override fun allocationSize(value: ThreadSummary?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeThreadSummary.allocationSize(value)
        }
    }

    override fun write(value: ThreadSummary?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeThreadSummary.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeUserIdentity: FfiConverterRustBuffer<UserIdentity?> {
    override fun read(buf: ByteBuffer): UserIdentity? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeUserIdentity.read(buf)
    }

    override fun allocationSize(value: UserIdentity?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeUserIdentity.allocationSize(value)
        }
    }

    override fun write(value: UserIdentity?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeUserIdentity.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeAudioInfo: FfiConverterRustBuffer<AudioInfo?> {
    override fun read(buf: ByteBuffer): AudioInfo? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeAudioInfo.read(buf)
    }

    override fun allocationSize(value: AudioInfo?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeAudioInfo.allocationSize(value)
        }
    }

    override fun write(value: AudioInfo?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeAudioInfo.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeComposerDraft: FfiConverterRustBuffer<ComposerDraft?> {
    override fun read(buf: ByteBuffer): ComposerDraft? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeComposerDraft.read(buf)
    }

    override fun allocationSize(value: ComposerDraft?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeComposerDraft.allocationSize(value)
        }
    }

    override fun write(value: ComposerDraft?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeComposerDraft.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeEventTimelineItem: FfiConverterRustBuffer<EventTimelineItem?> {
    override fun read(buf: ByteBuffer): EventTimelineItem? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeEventTimelineItem.read(buf)
    }

    override fun allocationSize(value: EventTimelineItem?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeEventTimelineItem.allocationSize(value)
        }
    }

    override fun write(value: EventTimelineItem?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeEventTimelineItem.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeFileInfo: FfiConverterRustBuffer<FileInfo?> {
    override fun read(buf: ByteBuffer): FileInfo? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeFileInfo.read(buf)
    }

    override fun allocationSize(value: FileInfo?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeFileInfo.allocationSize(value)
        }
    }

    override fun write(value: FileInfo?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeFileInfo.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeFormattedBody: FfiConverterRustBuffer<FormattedBody?> {
    override fun read(buf: ByteBuffer): FormattedBody? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeFormattedBody.read(buf)
    }

    override fun allocationSize(value: FormattedBody?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeFormattedBody.allocationSize(value)
        }
    }

    override fun write(value: FormattedBody?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeFormattedBody.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeImageInfo: FfiConverterRustBuffer<ImageInfo?> {
    override fun read(buf: ByteBuffer): ImageInfo? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeImageInfo.read(buf)
    }

    override fun allocationSize(value: ImageInfo?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeImageInfo.allocationSize(value)
        }
    }

    override fun write(value: ImageInfo?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeImageInfo.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeMatrixEntity: FfiConverterRustBuffer<MatrixEntity?> {
    override fun read(buf: ByteBuffer): MatrixEntity? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeMatrixEntity.read(buf)
    }

    override fun allocationSize(value: MatrixEntity?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeMatrixEntity.allocationSize(value)
        }
    }

    override fun write(value: MatrixEntity?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeMatrixEntity.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeMediaPreviewConfig: FfiConverterRustBuffer<MediaPreviewConfig?> {
    override fun read(buf: ByteBuffer): MediaPreviewConfig? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeMediaPreviewConfig.read(buf)
    }

    override fun allocationSize(value: MediaPreviewConfig?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeMediaPreviewConfig.allocationSize(value)
        }
    }

    override fun write(value: MediaPreviewConfig?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeMediaPreviewConfig.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeMediaUploadProgress: FfiConverterRustBuffer<MediaUploadProgress?> {
    override fun read(buf: ByteBuffer): MediaUploadProgress? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeMediaUploadProgress.read(buf)
    }

    override fun allocationSize(value: MediaUploadProgress?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeMediaUploadProgress.allocationSize(value)
        }
    }

    override fun write(value: MediaUploadProgress?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeMediaUploadProgress.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeMentions: FfiConverterRustBuffer<Mentions?> {
    override fun read(buf: ByteBuffer): Mentions? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeMentions.read(buf)
    }

    override fun allocationSize(value: Mentions?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeMentions.allocationSize(value)
        }
    }

    override fun write(value: Mentions?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeMentions.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeNotificationPowerLevels: FfiConverterRustBuffer<NotificationPowerLevels?> {
    override fun read(buf: ByteBuffer): NotificationPowerLevels? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeNotificationPowerLevels.read(buf)
    }

    override fun allocationSize(value: NotificationPowerLevels?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeNotificationPowerLevels.allocationSize(value)
        }
    }

    override fun write(value: NotificationPowerLevels?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeNotificationPowerLevels.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypePassPhrase: FfiConverterRustBuffer<PassPhrase?> {
    override fun read(buf: ByteBuffer): PassPhrase? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypePassPhrase.read(buf)
    }

    override fun allocationSize(value: PassPhrase?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypePassPhrase.allocationSize(value)
        }
    }

    override fun write(value: PassPhrase?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypePassPhrase.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypePowerLevels: FfiConverterRustBuffer<PowerLevels?> {
    override fun read(buf: ByteBuffer): PowerLevels? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypePowerLevels.read(buf)
    }

    override fun allocationSize(value: PowerLevels?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypePowerLevels.allocationSize(value)
        }
    }

    override fun write(value: PowerLevels?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypePowerLevels.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypePredecessorRoom: FfiConverterRustBuffer<PredecessorRoom?> {
    override fun read(buf: ByteBuffer): PredecessorRoom? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypePredecessorRoom.read(buf)
    }

    override fun allocationSize(value: PredecessorRoom?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypePredecessorRoom.allocationSize(value)
        }
    }

    override fun write(value: PredecessorRoom?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypePredecessorRoom.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeResolvedRoomAlias: FfiConverterRustBuffer<ResolvedRoomAlias?> {
    override fun read(buf: ByteBuffer): ResolvedRoomAlias? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeResolvedRoomAlias.read(buf)
    }

    override fun allocationSize(value: ResolvedRoomAlias?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeResolvedRoomAlias.allocationSize(value)
        }
    }

    override fun write(value: ResolvedRoomAlias?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeResolvedRoomAlias.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeRoomMember: FfiConverterRustBuffer<RoomMember?> {
    override fun read(buf: ByteBuffer): RoomMember? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeRoomMember.read(buf)
    }

    override fun allocationSize(value: RoomMember?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeRoomMember.allocationSize(value)
        }
    }

    override fun write(value: RoomMember?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeRoomMember.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeRoomMemberWithSenderInfo: FfiConverterRustBuffer<RoomMemberWithSenderInfo?> {
    override fun read(buf: ByteBuffer): RoomMemberWithSenderInfo? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeRoomMemberWithSenderInfo.read(buf)
    }

    override fun allocationSize(value: RoomMemberWithSenderInfo?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeRoomMemberWithSenderInfo.allocationSize(value)
        }
    }

    override fun write(value: RoomMemberWithSenderInfo?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeRoomMemberWithSenderInfo.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeSpaceRoom: FfiConverterRustBuffer<SpaceRoom?> {
    override fun read(buf: ByteBuffer): SpaceRoom? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeSpaceRoom.read(buf)
    }

    override fun allocationSize(value: SpaceRoom?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeSpaceRoom.allocationSize(value)
        }
    }

    override fun write(value: SpaceRoom?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeSpaceRoom.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeSuccessorRoom: FfiConverterRustBuffer<SuccessorRoom?> {
    override fun read(buf: ByteBuffer): SuccessorRoom? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeSuccessorRoom.read(buf)
    }

    override fun allocationSize(value: SuccessorRoom?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeSuccessorRoom.allocationSize(value)
        }
    }

    override fun write(value: SuccessorRoom?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeSuccessorRoom.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeThreadSubscription: FfiConverterRustBuffer<ThreadSubscription?> {
    override fun read(buf: ByteBuffer): ThreadSubscription? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeThreadSubscription.read(buf)
    }

    override fun allocationSize(value: ThreadSubscription?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeThreadSubscription.allocationSize(value)
        }
    }

    override fun write(value: ThreadSubscription?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeThreadSubscription.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeThumbnailInfo: FfiConverterRustBuffer<ThumbnailInfo?> {
    override fun read(buf: ByteBuffer): ThumbnailInfo? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeThumbnailInfo.read(buf)
    }

    override fun allocationSize(value: ThumbnailInfo?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeThumbnailInfo.allocationSize(value)
        }
    }

    override fun write(value: ThumbnailInfo?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeThumbnailInfo.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeTracingFileConfiguration: FfiConverterRustBuffer<TracingFileConfiguration?> {
    override fun read(buf: ByteBuffer): TracingFileConfiguration? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeTracingFileConfiguration.read(buf)
    }

    override fun allocationSize(value: TracingFileConfiguration?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeTracingFileConfiguration.allocationSize(value)
        }
    }

    override fun write(value: TracingFileConfiguration?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeTracingFileConfiguration.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeUnstableAudioDetailsContent: FfiConverterRustBuffer<UnstableAudioDetailsContent?> {
    override fun read(buf: ByteBuffer): UnstableAudioDetailsContent? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeUnstableAudioDetailsContent.read(buf)
    }

    override fun allocationSize(value: UnstableAudioDetailsContent?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeUnstableAudioDetailsContent.allocationSize(value)
        }
    }

    override fun write(value: UnstableAudioDetailsContent?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeUnstableAudioDetailsContent.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeUnstableVoiceContent: FfiConverterRustBuffer<UnstableVoiceContent?> {
    override fun read(buf: ByteBuffer): UnstableVoiceContent? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeUnstableVoiceContent.read(buf)
    }

    override fun allocationSize(value: UnstableVoiceContent?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeUnstableVoiceContent.allocationSize(value)
        }
    }

    override fun write(value: UnstableVoiceContent?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeUnstableVoiceContent.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeVideoInfo: FfiConverterRustBuffer<VideoInfo?> {
    override fun read(buf: ByteBuffer): VideoInfo? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeVideoInfo.read(buf)
    }

    override fun allocationSize(value: VideoInfo?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeVideoInfo.allocationSize(value)
        }
    }

    override fun write(value: VideoInfo?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeVideoInfo.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeAccountManagementAction: FfiConverterRustBuffer<AccountManagementAction?> {
    override fun read(buf: ByteBuffer): AccountManagementAction? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeAccountManagementAction.read(buf)
    }

    override fun allocationSize(value: AccountManagementAction?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeAccountManagementAction.allocationSize(value)
        }
    }

    override fun write(value: AccountManagementAction?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeAccountManagementAction.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeAssetType: FfiConverterRustBuffer<AssetType?> {
    override fun read(buf: ByteBuffer): AssetType? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeAssetType.read(buf)
    }

    override fun allocationSize(value: AssetType?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeAssetType.allocationSize(value)
        }
    }

    override fun write(value: AssetType?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeAssetType.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeAuthData: FfiConverterRustBuffer<AuthData?> {
    override fun read(buf: ByteBuffer): AuthData? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeAuthData.read(buf)
    }

    override fun allocationSize(value: AuthData?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeAuthData.allocationSize(value)
        }
    }

    override fun write(value: AuthData?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeAuthData.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeEventSendState: FfiConverterRustBuffer<EventSendState?> {
    override fun read(buf: ByteBuffer): EventSendState? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeEventSendState.read(buf)
    }

    override fun allocationSize(value: EventSendState?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeEventSendState.allocationSize(value)
        }
    }

    override fun write(value: EventSendState?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeEventSendState.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeInviteAvatars: FfiConverterRustBuffer<InviteAvatars?> {
    override fun read(buf: ByteBuffer): InviteAvatars? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeInviteAvatars.read(buf)
    }

    override fun allocationSize(value: InviteAvatars?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeInviteAvatars.allocationSize(value)
        }
    }

    override fun write(value: InviteAvatars?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeInviteAvatars.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeJoinRule: FfiConverterRustBuffer<JoinRule?> {
    override fun read(buf: ByteBuffer): JoinRule? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeJoinRule.read(buf)
    }

    override fun allocationSize(value: JoinRule?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeJoinRule.allocationSize(value)
        }
    }

    override fun write(value: JoinRule?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeJoinRule.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeMediaPreviews: FfiConverterRustBuffer<MediaPreviews?> {
    override fun read(buf: ByteBuffer): MediaPreviews? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeMediaPreviews.read(buf)
    }

    override fun allocationSize(value: MediaPreviews?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeMediaPreviews.allocationSize(value)
        }
    }

    override fun write(value: MediaPreviews?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeMediaPreviews.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeMembership: FfiConverterRustBuffer<Membership?> {
    override fun read(buf: ByteBuffer): Membership? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeMembership.read(buf)
    }

    override fun allocationSize(value: Membership?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeMembership.allocationSize(value)
        }
    }

    override fun write(value: Membership?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeMembership.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeMembershipChange: FfiConverterRustBuffer<MembershipChange?> {
    override fun read(buf: ByteBuffer): MembershipChange? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeMembershipChange.read(buf)
    }

    override fun allocationSize(value: MembershipChange?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeMembershipChange.allocationSize(value)
        }
    }

    override fun write(value: MembershipChange?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeMembershipChange.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeOidcPrompt: FfiConverterRustBuffer<OidcPrompt?> {
    override fun read(buf: ByteBuffer): OidcPrompt? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeOidcPrompt.read(buf)
    }

    override fun allocationSize(value: OidcPrompt?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeOidcPrompt.allocationSize(value)
        }
    }

    override fun write(value: OidcPrompt?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeOidcPrompt.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypePublicRoomJoinRule: FfiConverterRustBuffer<PublicRoomJoinRule?> {
    override fun read(buf: ByteBuffer): PublicRoomJoinRule? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypePublicRoomJoinRule.read(buf)
    }

    override fun allocationSize(value: PublicRoomJoinRule?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypePublicRoomJoinRule.allocationSize(value)
        }
    }

    override fun write(value: PublicRoomJoinRule?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypePublicRoomJoinRule.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypePushFormat: FfiConverterRustBuffer<PushFormat?> {
    override fun read(buf: ByteBuffer): PushFormat? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypePushFormat.read(buf)
    }

    override fun allocationSize(value: PushFormat?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypePushFormat.allocationSize(value)
        }
    }

    override fun write(value: PushFormat?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypePushFormat.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeRoomHistoryVisibility: FfiConverterRustBuffer<RoomHistoryVisibility?> {
    override fun read(buf: ByteBuffer): RoomHistoryVisibility? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeRoomHistoryVisibility.read(buf)
    }

    override fun allocationSize(value: RoomHistoryVisibility?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeRoomHistoryVisibility.allocationSize(value)
        }
    }

    override fun write(value: RoomHistoryVisibility?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeRoomHistoryVisibility.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeRoomNotificationMode: FfiConverterRustBuffer<RoomNotificationMode?> {
    override fun read(buf: ByteBuffer): RoomNotificationMode? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeRoomNotificationMode.read(buf)
    }

    override fun allocationSize(value: RoomNotificationMode?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeRoomNotificationMode.allocationSize(value)
        }
    }

    override fun write(value: RoomNotificationMode?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeRoomNotificationMode.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeShieldState: FfiConverterRustBuffer<ShieldState?> {
    override fun read(buf: ByteBuffer): ShieldState? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeShieldState.read(buf)
    }

    override fun allocationSize(value: ShieldState?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeShieldState.allocationSize(value)
        }
    }

    override fun write(value: ShieldState?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeShieldState.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeUploadSource: FfiConverterRustBuffer<UploadSource?> {
    override fun read(buf: ByteBuffer): UploadSource? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeUploadSource.read(buf)
    }

    override fun allocationSize(value: UploadSource?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeUploadSource.allocationSize(value)
        }
    }

    override fun write(value: UploadSource?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeUploadSource.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeVirtualTimelineItem: FfiConverterRustBuffer<VirtualTimelineItem?> {
    override fun read(buf: ByteBuffer): VirtualTimelineItem? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeVirtualTimelineItem.read(buf)
    }

    override fun allocationSize(value: VirtualTimelineItem?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeVirtualTimelineItem.allocationSize(value)
        }
    }

    override fun write(value: VirtualTimelineItem?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeVirtualTimelineItem.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeBackupSteadyStateListener: FfiConverterRustBuffer<BackupSteadyStateListener?> {
    override fun read(buf: ByteBuffer): BackupSteadyStateListener? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeBackupSteadyStateListener.read(buf)
    }

    override fun allocationSize(value: BackupSteadyStateListener?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeBackupSteadyStateListener.allocationSize(value)
        }
    }

    override fun write(value: BackupSteadyStateListener?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeBackupSteadyStateListener.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeClientDelegate: FfiConverterRustBuffer<ClientDelegate?> {
    override fun read(buf: ByteBuffer): ClientDelegate? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeClientDelegate.read(buf)
    }

    override fun allocationSize(value: ClientDelegate?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeClientDelegate.allocationSize(value)
        }
    }

    override fun write(value: ClientDelegate?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeClientDelegate.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeNotificationSettingsDelegate: FfiConverterRustBuffer<NotificationSettingsDelegate?> {
    override fun read(buf: ByteBuffer): NotificationSettingsDelegate? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeNotificationSettingsDelegate.read(buf)
    }

    override fun allocationSize(value: NotificationSettingsDelegate?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeNotificationSettingsDelegate.allocationSize(value)
        }
    }

    override fun write(value: NotificationSettingsDelegate?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeNotificationSettingsDelegate.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeProgressWatcher: FfiConverterRustBuffer<ProgressWatcher?> {
    override fun read(buf: ByteBuffer): ProgressWatcher? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeProgressWatcher.read(buf)
    }

    override fun allocationSize(value: ProgressWatcher?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeProgressWatcher.allocationSize(value)
        }
    }

    override fun write(value: ProgressWatcher?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeProgressWatcher.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeSessionVerificationControllerDelegate: FfiConverterRustBuffer<SessionVerificationControllerDelegate?> {
    override fun read(buf: ByteBuffer): SessionVerificationControllerDelegate? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeSessionVerificationControllerDelegate.read(buf)
    }

    override fun allocationSize(value: SessionVerificationControllerDelegate?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeSessionVerificationControllerDelegate.allocationSize(value)
        }
    }

    override fun write(value: SessionVerificationControllerDelegate?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeSessionVerificationControllerDelegate.write(value, buf)
        }
    }
}




public object FfiConverterOptionalSequenceString: FfiConverterRustBuffer<List<kotlin.String>?> {
    override fun read(buf: ByteBuffer): List<kotlin.String>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterSequenceString.read(buf)
    }

    override fun allocationSize(value: List<kotlin.String>?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterSequenceString.allocationSize(value)
        }
    }

    override fun write(value: List<kotlin.String>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterSequenceString.write(value, buf)
        }
    }
}




public object FfiConverterOptionalSequenceTypeRoomHero: FfiConverterRustBuffer<List<RoomHero>?> {
    override fun read(buf: ByteBuffer): List<RoomHero>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterSequenceTypeRoomHero.read(buf)
    }

    override fun allocationSize(value: List<RoomHero>?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterSequenceTypeRoomHero.allocationSize(value)
        }
    }

    override fun write(value: List<RoomHero>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterSequenceTypeRoomHero.write(value, buf)
        }
    }
}




public object FfiConverterOptionalSequenceTypeRoomMember: FfiConverterRustBuffer<List<RoomMember>?> {
    override fun read(buf: ByteBuffer): List<RoomMember>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterSequenceTypeRoomMember.read(buf)
    }

    override fun allocationSize(value: List<RoomMember>?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterSequenceTypeRoomMember.allocationSize(value)
        }
    }

    override fun write(value: List<RoomMember>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterSequenceTypeRoomMember.write(value, buf)
        }
    }
}




public object FfiConverterOptionalMapStringLong: FfiConverterRustBuffer<Map<kotlin.String, kotlin.Long>?> {
    override fun read(buf: ByteBuffer): Map<kotlin.String, kotlin.Long>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterMapStringLong.read(buf)
    }

    override fun allocationSize(value: Map<kotlin.String, kotlin.Long>?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterMapStringLong.allocationSize(value)
        }
    }

    override fun write(value: Map<kotlin.String, kotlin.Long>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterMapStringLong.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeEventItemOrigin: FfiConverterRustBuffer<EventItemOrigin?> {
    override fun read(buf: ByteBuffer): EventItemOrigin? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeEventItemOrigin.read(buf)
    }

    override fun allocationSize(value: EventItemOrigin?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeEventItemOrigin.allocationSize(value)
        }
    }

    override fun write(value: EventItemOrigin?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeEventItemOrigin.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeTimestamp: FfiConverterRustBuffer<Timestamp?> {
    override fun read(buf: ByteBuffer): Timestamp? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeTimestamp.read(buf)
    }

    override fun allocationSize(value: Timestamp?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeTimestamp.allocationSize(value)
        }
    }

    override fun write(value: Timestamp?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeTimestamp.write(value, buf)
        }
    }
}




public object FfiConverterSequenceUShort: FfiConverterRustBuffer<List<kotlin.UShort>> {
    override fun read(buf: ByteBuffer): List<kotlin.UShort> {
        val len = buf.getInt()
        return List<kotlin.UShort>(len) {
            FfiConverterUShort.read(buf)
        }
    }

    override fun allocationSize(value: List<kotlin.UShort>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterUShort.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<kotlin.UShort>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterUShort.write(it, buf)
        }
    }
}




public object FfiConverterSequenceFloat: FfiConverterRustBuffer<List<kotlin.Float>> {
    override fun read(buf: ByteBuffer): List<kotlin.Float> {
        val len = buf.getInt()
        return List<kotlin.Float>(len) {
            FfiConverterFloat.read(buf)
        }
    }

    override fun allocationSize(value: List<kotlin.Float>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterFloat.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<kotlin.Float>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterFloat.write(it, buf)
        }
    }
}




public object FfiConverterSequenceString: FfiConverterRustBuffer<List<kotlin.String>> {
    override fun read(buf: ByteBuffer): List<kotlin.String> {
        val len = buf.getInt()
        return List<kotlin.String>(len) {
            FfiConverterString.read(buf)
        }
    }

    override fun allocationSize(value: List<kotlin.String>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterString.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<kotlin.String>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterString.write(it, buf)
        }
    }
}




public object FfiConverterSequenceByteArray: FfiConverterRustBuffer<List<kotlin.ByteArray>> {
    override fun read(buf: ByteBuffer): List<kotlin.ByteArray> {
        val len = buf.getInt()
        return List<kotlin.ByteArray>(len) {
            FfiConverterByteArray.read(buf)
        }
    }

    override fun allocationSize(value: List<kotlin.ByteArray>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterByteArray.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<kotlin.ByteArray>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterByteArray.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeRoom: FfiConverterRustBuffer<List<Room>> {
    override fun read(buf: ByteBuffer): List<Room> {
        val len = buf.getInt()
        return List<Room>(len) {
            FfiConverterTypeRoom.read(buf)
        }
    }

    override fun allocationSize(value: List<Room>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeRoom.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Room>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeRoom.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeSessionVerificationEmoji: FfiConverterRustBuffer<List<SessionVerificationEmoji>> {
    override fun read(buf: ByteBuffer): List<SessionVerificationEmoji> {
        val len = buf.getInt()
        return List<SessionVerificationEmoji>(len) {
            FfiConverterTypeSessionVerificationEmoji.read(buf)
        }
    }

    override fun allocationSize(value: List<SessionVerificationEmoji>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeSessionVerificationEmoji.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<SessionVerificationEmoji>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeSessionVerificationEmoji.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeTimelineItem: FfiConverterRustBuffer<List<TimelineItem>> {
    override fun read(buf: ByteBuffer): List<TimelineItem> {
        val len = buf.getInt()
        return List<TimelineItem>(len) {
            FfiConverterTypeTimelineItem.read(buf)
        }
    }

    override fun allocationSize(value: List<TimelineItem>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeTimelineItem.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<TimelineItem>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeTimelineItem.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeConditionalPushRule: FfiConverterRustBuffer<List<ConditionalPushRule>> {
    override fun read(buf: ByteBuffer): List<ConditionalPushRule> {
        val len = buf.getInt()
        return List<ConditionalPushRule>(len) {
            FfiConverterTypeConditionalPushRule.read(buf)
        }
    }

    override fun allocationSize(value: List<ConditionalPushRule>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeConditionalPushRule.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ConditionalPushRule>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeConditionalPushRule.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeIdentityStatusChange: FfiConverterRustBuffer<List<IdentityStatusChange>> {
    override fun read(buf: ByteBuffer): List<IdentityStatusChange> {
        val len = buf.getInt()
        return List<IdentityStatusChange>(len) {
            FfiConverterTypeIdentityStatusChange.read(buf)
        }
    }

    override fun allocationSize(value: List<IdentityStatusChange>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeIdentityStatusChange.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<IdentityStatusChange>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeIdentityStatusChange.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeKnockRequest: FfiConverterRustBuffer<List<KnockRequest>> {
    override fun read(buf: ByteBuffer): List<KnockRequest> {
        val len = buf.getInt()
        return List<KnockRequest>(len) {
            FfiConverterTypeKnockRequest.read(buf)
        }
    }

    override fun allocationSize(value: List<KnockRequest>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeKnockRequest.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<KnockRequest>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeKnockRequest.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeLeaveSpaceRoom: FfiConverterRustBuffer<List<LeaveSpaceRoom>> {
    override fun read(buf: ByteBuffer): List<LeaveSpaceRoom> {
        val len = buf.getInt()
        return List<LeaveSpaceRoom>(len) {
            FfiConverterTypeLeaveSpaceRoom.read(buf)
        }
    }

    override fun allocationSize(value: List<LeaveSpaceRoom>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeLeaveSpaceRoom.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<LeaveSpaceRoom>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeLeaveSpaceRoom.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeLiveLocationShare: FfiConverterRustBuffer<List<LiveLocationShare>> {
    override fun read(buf: ByteBuffer): List<LiveLocationShare> {
        val len = buf.getInt()
        return List<LiveLocationShare>(len) {
            FfiConverterTypeLiveLocationShare.read(buf)
        }
    }

    override fun allocationSize(value: List<LiveLocationShare>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeLiveLocationShare.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<LiveLocationShare>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeLiveLocationShare.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeNotificationItemsRequest: FfiConverterRustBuffer<List<NotificationItemsRequest>> {
    override fun read(buf: ByteBuffer): List<NotificationItemsRequest> {
        val len = buf.getInt()
        return List<NotificationItemsRequest>(len) {
            FfiConverterTypeNotificationItemsRequest.read(buf)
        }
    }

    override fun allocationSize(value: List<NotificationItemsRequest>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeNotificationItemsRequest.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<NotificationItemsRequest>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeNotificationItemsRequest.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypePatternedPushRule: FfiConverterRustBuffer<List<PatternedPushRule>> {
    override fun read(buf: ByteBuffer): List<PatternedPushRule> {
        val len = buf.getInt()
        return List<PatternedPushRule>(len) {
            FfiConverterTypePatternedPushRule.read(buf)
        }
    }

    override fun allocationSize(value: List<PatternedPushRule>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypePatternedPushRule.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<PatternedPushRule>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypePatternedPushRule.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypePollAnswer: FfiConverterRustBuffer<List<PollAnswer>> {
    override fun read(buf: ByteBuffer): List<PollAnswer> {
        val len = buf.getInt()
        return List<PollAnswer>(len) {
            FfiConverterTypePollAnswer.read(buf)
        }
    }

    override fun allocationSize(value: List<PollAnswer>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypePollAnswer.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<PollAnswer>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypePollAnswer.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeReaction: FfiConverterRustBuffer<List<Reaction>> {
    override fun read(buf: ByteBuffer): List<Reaction> {
        val len = buf.getInt()
        return List<Reaction>(len) {
            FfiConverterTypeReaction.read(buf)
        }
    }

    override fun allocationSize(value: List<Reaction>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeReaction.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Reaction>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeReaction.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeReactionSenderData: FfiConverterRustBuffer<List<ReactionSenderData>> {
    override fun read(buf: ByteBuffer): List<ReactionSenderData> {
        val len = buf.getInt()
        return List<ReactionSenderData>(len) {
            FfiConverterTypeReactionSenderData.read(buf)
        }
    }

    override fun allocationSize(value: List<ReactionSenderData>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeReactionSenderData.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ReactionSenderData>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeReactionSenderData.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeRecentEmoji: FfiConverterRustBuffer<List<RecentEmoji>> {
    override fun read(buf: ByteBuffer): List<RecentEmoji> {
        val len = buf.getInt()
        return List<RecentEmoji>(len) {
            FfiConverterTypeRecentEmoji.read(buf)
        }
    }

    override fun allocationSize(value: List<RecentEmoji>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeRecentEmoji.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<RecentEmoji>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeRecentEmoji.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeRoomDescription: FfiConverterRustBuffer<List<RoomDescription>> {
    override fun read(buf: ByteBuffer): List<RoomDescription> {
        val len = buf.getInt()
        return List<RoomDescription>(len) {
            FfiConverterTypeRoomDescription.read(buf)
        }
    }

    override fun allocationSize(value: List<RoomDescription>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeRoomDescription.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<RoomDescription>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeRoomDescription.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeRoomHero: FfiConverterRustBuffer<List<RoomHero>> {
    override fun read(buf: ByteBuffer): List<RoomHero> {
        val len = buf.getInt()
        return List<RoomHero>(len) {
            FfiConverterTypeRoomHero.read(buf)
        }
    }

    override fun allocationSize(value: List<RoomHero>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeRoomHero.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<RoomHero>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeRoomHero.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeRoomMember: FfiConverterRustBuffer<List<RoomMember>> {
    override fun read(buf: ByteBuffer): List<RoomMember> {
        val len = buf.getInt()
        return List<RoomMember>(len) {
            FfiConverterTypeRoomMember.read(buf)
        }
    }

    override fun allocationSize(value: List<RoomMember>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeRoomMember.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<RoomMember>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeRoomMember.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeSimplePushRule: FfiConverterRustBuffer<List<SimplePushRule>> {
    override fun read(buf: ByteBuffer): List<SimplePushRule> {
        val len = buf.getInt()
        return List<SimplePushRule>(len) {
            FfiConverterTypeSimplePushRule.read(buf)
        }
    }

    override fun allocationSize(value: List<SimplePushRule>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeSimplePushRule.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<SimplePushRule>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeSimplePushRule.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeSpaceRoom: FfiConverterRustBuffer<List<SpaceRoom>> {
    override fun read(buf: ByteBuffer): List<SpaceRoom> {
        val len = buf.getInt()
        return List<SpaceRoom>(len) {
            FfiConverterTypeSpaceRoom.read(buf)
        }
    }

    override fun allocationSize(value: List<SpaceRoom>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeSpaceRoom.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<SpaceRoom>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeSpaceRoom.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeUserPowerLevelUpdate: FfiConverterRustBuffer<List<UserPowerLevelUpdate>> {
    override fun read(buf: ByteBuffer): List<UserPowerLevelUpdate> {
        val len = buf.getInt()
        return List<UserPowerLevelUpdate>(len) {
            FfiConverterTypeUserPowerLevelUpdate.read(buf)
        }
    }

    override fun allocationSize(value: List<UserPowerLevelUpdate>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeUserPowerLevelUpdate.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<UserPowerLevelUpdate>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeUserPowerLevelUpdate.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeUserProfile: FfiConverterRustBuffer<List<UserProfile>> {
    override fun read(buf: ByteBuffer): List<UserProfile> {
        val len = buf.getInt()
        return List<UserProfile>(len) {
            FfiConverterTypeUserProfile.read(buf)
        }
    }

    override fun allocationSize(value: List<UserProfile>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeUserProfile.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<UserProfile>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeUserProfile.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeAction: FfiConverterRustBuffer<List<Action>> {
    override fun read(buf: ByteBuffer): List<Action> {
        val len = buf.getInt()
        return List<Action>(len) {
            FfiConverterTypeAction.read(buf)
        }
    }

    override fun allocationSize(value: List<Action>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeAction.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Action>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeAction.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeAllowRule: FfiConverterRustBuffer<List<AllowRule>> {
    override fun read(buf: ByteBuffer): List<AllowRule> {
        val len = buf.getInt()
        return List<AllowRule>(len) {
            FfiConverterTypeAllowRule.read(buf)
        }
    }

    override fun allocationSize(value: List<AllowRule>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeAllowRule.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<AllowRule>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeAllowRule.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeDraftAttachment: FfiConverterRustBuffer<List<DraftAttachment>> {
    override fun read(buf: ByteBuffer): List<DraftAttachment> {
        val len = buf.getInt()
        return List<DraftAttachment>(len) {
            FfiConverterTypeDraftAttachment.read(buf)
        }
    }

    override fun allocationSize(value: List<DraftAttachment>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeDraftAttachment.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<DraftAttachment>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeDraftAttachment.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeFilterTimelineEventType: FfiConverterRustBuffer<List<FilterTimelineEventType>> {
    override fun read(buf: ByteBuffer): List<FilterTimelineEventType> {
        val len = buf.getInt()
        return List<FilterTimelineEventType>(len) {
            FfiConverterTypeFilterTimelineEventType.read(buf)
        }
    }

    override fun allocationSize(value: List<FilterTimelineEventType>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeFilterTimelineEventType.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<FilterTimelineEventType>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeFilterTimelineEventType.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeGalleryItemInfo: FfiConverterRustBuffer<List<GalleryItemInfo>> {
    override fun read(buf: ByteBuffer): List<GalleryItemInfo> {
        val len = buf.getInt()
        return List<GalleryItemInfo>(len) {
            FfiConverterTypeGalleryItemInfo.read(buf)
        }
    }

    override fun allocationSize(value: List<GalleryItemInfo>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeGalleryItemInfo.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<GalleryItemInfo>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeGalleryItemInfo.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeGalleryItemType: FfiConverterRustBuffer<List<GalleryItemType>> {
    override fun read(buf: ByteBuffer): List<GalleryItemType> {
        val len = buf.getInt()
        return List<GalleryItemType>(len) {
            FfiConverterTypeGalleryItemType.read(buf)
        }
    }

    override fun allocationSize(value: List<GalleryItemType>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeGalleryItemType.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<GalleryItemType>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeGalleryItemType.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeMembership: FfiConverterRustBuffer<List<Membership>> {
    override fun read(buf: ByteBuffer): List<Membership> {
        val len = buf.getInt()
        return List<Membership>(len) {
            FfiConverterTypeMembership.read(buf)
        }
    }

    override fun allocationSize(value: List<Membership>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeMembership.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Membership>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeMembership.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeOidcPrompt: FfiConverterRustBuffer<List<OidcPrompt>> {
    override fun read(buf: ByteBuffer): List<OidcPrompt> {
        val len = buf.getInt()
        return List<OidcPrompt>(len) {
            FfiConverterTypeOidcPrompt.read(buf)
        }
    }

    override fun allocationSize(value: List<OidcPrompt>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeOidcPrompt.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<OidcPrompt>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeOidcPrompt.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypePushCondition: FfiConverterRustBuffer<List<PushCondition>> {
    override fun read(buf: ByteBuffer): List<PushCondition> {
        val len = buf.getInt()
        return List<PushCondition>(len) {
            FfiConverterTypePushCondition.read(buf)
        }
    }

    override fun allocationSize(value: List<PushCondition>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypePushCondition.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<PushCondition>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypePushCondition.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeRoomDirectorySearchEntryUpdate: FfiConverterRustBuffer<List<RoomDirectorySearchEntryUpdate>> {
    override fun read(buf: ByteBuffer): List<RoomDirectorySearchEntryUpdate> {
        val len = buf.getInt()
        return List<RoomDirectorySearchEntryUpdate>(len) {
            FfiConverterTypeRoomDirectorySearchEntryUpdate.read(buf)
        }
    }

    override fun allocationSize(value: List<RoomDirectorySearchEntryUpdate>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeRoomDirectorySearchEntryUpdate.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<RoomDirectorySearchEntryUpdate>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeRoomDirectorySearchEntryUpdate.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind: FfiConverterRustBuffer<List<RoomListEntriesDynamicFilterKind>> {
    override fun read(buf: ByteBuffer): List<RoomListEntriesDynamicFilterKind> {
        val len = buf.getInt()
        return List<RoomListEntriesDynamicFilterKind>(len) {
            FfiConverterTypeRoomListEntriesDynamicFilterKind.read(buf)
        }
    }

    override fun allocationSize(value: List<RoomListEntriesDynamicFilterKind>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeRoomListEntriesDynamicFilterKind.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<RoomListEntriesDynamicFilterKind>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeRoomListEntriesDynamicFilterKind.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeRoomListEntriesUpdate: FfiConverterRustBuffer<List<RoomListEntriesUpdate>> {
    override fun read(buf: ByteBuffer): List<RoomListEntriesUpdate> {
        val len = buf.getInt()
        return List<RoomListEntriesUpdate>(len) {
            FfiConverterTypeRoomListEntriesUpdate.read(buf)
        }
    }

    override fun allocationSize(value: List<RoomListEntriesUpdate>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeRoomListEntriesUpdate.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<RoomListEntriesUpdate>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeRoomListEntriesUpdate.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeRoomMessageEventMessageType: FfiConverterRustBuffer<List<RoomMessageEventMessageType>> {
    override fun read(buf: ByteBuffer): List<RoomMessageEventMessageType> {
        val len = buf.getInt()
        return List<RoomMessageEventMessageType>(len) {
            FfiConverterTypeRoomMessageEventMessageType.read(buf)
        }
    }

    override fun allocationSize(value: List<RoomMessageEventMessageType>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeRoomMessageEventMessageType.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<RoomMessageEventMessageType>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeRoomMessageEventMessageType.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeSlidingSyncVersion: FfiConverterRustBuffer<List<SlidingSyncVersion>> {
    override fun read(buf: ByteBuffer): List<SlidingSyncVersion> {
        val len = buf.getInt()
        return List<SlidingSyncVersion>(len) {
            FfiConverterTypeSlidingSyncVersion.read(buf)
        }
    }

    override fun allocationSize(value: List<SlidingSyncVersion>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeSlidingSyncVersion.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<SlidingSyncVersion>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeSlidingSyncVersion.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeSpaceListUpdate: FfiConverterRustBuffer<List<SpaceListUpdate>> {
    override fun read(buf: ByteBuffer): List<SpaceListUpdate> {
        val len = buf.getInt()
        return List<SpaceListUpdate>(len) {
            FfiConverterTypeSpaceListUpdate.read(buf)
        }
    }

    override fun allocationSize(value: List<SpaceListUpdate>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeSpaceListUpdate.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<SpaceListUpdate>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeSpaceListUpdate.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeTimelineDiff: FfiConverterRustBuffer<List<TimelineDiff>> {
    override fun read(buf: ByteBuffer): List<TimelineDiff> {
        val len = buf.getInt()
        return List<TimelineDiff>(len) {
            FfiConverterTypeTimelineDiff.read(buf)
        }
    }

    override fun allocationSize(value: List<TimelineDiff>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeTimelineDiff.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<TimelineDiff>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeTimelineDiff.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeTraceLogPacks: FfiConverterRustBuffer<List<TraceLogPacks>> {
    override fun read(buf: ByteBuffer): List<TraceLogPacks> {
        val len = buf.getInt()
        return List<TraceLogPacks>(len) {
            FfiConverterTypeTraceLogPacks.read(buf)
        }
    }

    override fun allocationSize(value: List<TraceLogPacks>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeTraceLogPacks.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<TraceLogPacks>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeTraceLogPacks.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeWidgetEventFilter: FfiConverterRustBuffer<List<WidgetEventFilter>> {
    override fun read(buf: ByteBuffer): List<WidgetEventFilter> {
        val len = buf.getInt()
        return List<WidgetEventFilter>(len) {
            FfiConverterTypeWidgetEventFilter.read(buf)
        }
    }

    override fun allocationSize(value: List<WidgetEventFilter>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeWidgetEventFilter.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<WidgetEventFilter>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeWidgetEventFilter.write(it, buf)
        }
    }
}



public object FfiConverterMapStringInt: FfiConverterRustBuffer<Map<kotlin.String, kotlin.Int>> {
    override fun read(buf: ByteBuffer): Map<kotlin.String, kotlin.Int> {
        val len = buf.getInt()
        return buildMap<kotlin.String, kotlin.Int>(len) {
            repeat(len) {
                val k = FfiConverterString.read(buf)
                val v = FfiConverterInt.read(buf)
                this[k] = v
            }
        }
    }

    override fun allocationSize(value: Map<kotlin.String, kotlin.Int>): ULong {
        val spaceForMapSize = 4UL
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterInt.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<kotlin.String, kotlin.Int>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterInt.write(v, buf)
        }
    }
}



public object FfiConverterMapStringLong: FfiConverterRustBuffer<Map<kotlin.String, kotlin.Long>> {
    override fun read(buf: ByteBuffer): Map<kotlin.String, kotlin.Long> {
        val len = buf.getInt()
        return buildMap<kotlin.String, kotlin.Long>(len) {
            repeat(len) {
                val k = FfiConverterString.read(buf)
                val v = FfiConverterLong.read(buf)
                this[k] = v
            }
        }
    }

    override fun allocationSize(value: Map<kotlin.String, kotlin.Long>): ULong {
        val spaceForMapSize = 4UL
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterLong.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<kotlin.String, kotlin.Long>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterLong.write(v, buf)
        }
    }
}



public object FfiConverterMapStringString: FfiConverterRustBuffer<Map<kotlin.String, kotlin.String>> {
    override fun read(buf: ByteBuffer): Map<kotlin.String, kotlin.String> {
        val len = buf.getInt()
        return buildMap<kotlin.String, kotlin.String>(len) {
            repeat(len) {
                val k = FfiConverterString.read(buf)
                val v = FfiConverterString.read(buf)
                this[k] = v
            }
        }
    }

    override fun allocationSize(value: Map<kotlin.String, kotlin.String>): ULong {
        val spaceForMapSize = 4UL
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterString.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<kotlin.String, kotlin.String>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterString.write(v, buf)
        }
    }
}



public object FfiConverterMapStringTypeIgnoredUser: FfiConverterRustBuffer<Map<kotlin.String, IgnoredUser>> {
    override fun read(buf: ByteBuffer): Map<kotlin.String, IgnoredUser> {
        val len = buf.getInt()
        return buildMap<kotlin.String, IgnoredUser>(len) {
            repeat(len) {
                val k = FfiConverterString.read(buf)
                val v = FfiConverterTypeIgnoredUser.read(buf)
                this[k] = v
            }
        }
    }

    override fun allocationSize(value: Map<kotlin.String, IgnoredUser>): ULong {
        val spaceForMapSize = 4UL
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterTypeIgnoredUser.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<kotlin.String, IgnoredUser>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterTypeIgnoredUser.write(v, buf)
        }
    }
}



public object FfiConverterMapStringTypeReceipt: FfiConverterRustBuffer<Map<kotlin.String, Receipt>> {
    override fun read(buf: ByteBuffer): Map<kotlin.String, Receipt> {
        val len = buf.getInt()
        return buildMap<kotlin.String, Receipt>(len) {
            repeat(len) {
                val k = FfiConverterString.read(buf)
                val v = FfiConverterTypeReceipt.read(buf)
                this[k] = v
            }
        }
    }

    override fun allocationSize(value: Map<kotlin.String, Receipt>): ULong {
        val spaceForMapSize = 4UL
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterTypeReceipt.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<kotlin.String, Receipt>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterTypeReceipt.write(v, buf)
        }
    }
}



public object FfiConverterMapStringTypeBatchNotificationResult: FfiConverterRustBuffer<Map<kotlin.String, BatchNotificationResult>> {
    override fun read(buf: ByteBuffer): Map<kotlin.String, BatchNotificationResult> {
        val len = buf.getInt()
        return buildMap<kotlin.String, BatchNotificationResult>(len) {
            repeat(len) {
                val k = FfiConverterString.read(buf)
                val v = FfiConverterTypeBatchNotificationResult.read(buf)
                this[k] = v
            }
        }
    }

    override fun allocationSize(value: Map<kotlin.String, BatchNotificationResult>): ULong {
        val spaceForMapSize = 4UL
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterTypeBatchNotificationResult.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<kotlin.String, BatchNotificationResult>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterTypeBatchNotificationResult.write(v, buf)
        }
    }
}



public object FfiConverterMapStringSequenceString: FfiConverterRustBuffer<Map<kotlin.String, List<kotlin.String>>> {
    override fun read(buf: ByteBuffer): Map<kotlin.String, List<kotlin.String>> {
        val len = buf.getInt()
        return buildMap<kotlin.String, List<kotlin.String>>(len) {
            repeat(len) {
                val k = FfiConverterString.read(buf)
                val v = FfiConverterSequenceString.read(buf)
                this[k] = v
            }
        }
    }

    override fun allocationSize(value: Map<kotlin.String, List<kotlin.String>>): ULong {
        val spaceForMapSize = 4UL
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterSequenceString.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<kotlin.String, List<kotlin.String>>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterSequenceString.write(v, buf)
        }
    }
}



public object FfiConverterMapTypeTagNameTypeTagInfo: FfiConverterRustBuffer<Map<TagName, TagInfo>> {
    override fun read(buf: ByteBuffer): Map<TagName, TagInfo> {
        val len = buf.getInt()
        return buildMap<TagName, TagInfo>(len) {
            repeat(len) {
                val k = FfiConverterTypeTagName.read(buf)
                val v = FfiConverterTypeTagInfo.read(buf)
                this[k] = v
            }
        }
    }

    override fun allocationSize(value: Map<TagName, TagInfo>): ULong {
        val spaceForMapSize = 4UL
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterTypeTagName.allocationSize(k) +
            FfiConverterTypeTagInfo.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<TagName, TagInfo>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterTypeTagName.write(k, buf)
            FfiConverterTypeTagInfo.write(v, buf)
        }
    }
}











































































/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias Timestamp = kotlin.ULong
public typealias FfiConverterTypeTimestamp = FfiConverterULong








        /**
         * Creates a [`RoomMessageEventContentWithoutRelation`] given a
         * [`MessageContent`] value.
         */
    @Throws(ClientException::class) fun `contentWithoutRelationFromMessage`(`message`: MessageContent): RoomMessageEventContentWithoutRelation {
            return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_func_content_without_relation_from_message(
        FfiConverterTypeMessageContent.lower(`message`),_status)
}
    )
    }
    

        /**
         * Create a caption edit.
         *
         * If no `formatted_caption` is provided, then it's assumed the `caption`
         * represents valid Markdown that can be used as the formatted caption.
         */ fun `createCaptionEdit`(`caption`: kotlin.String?, `formattedCaption`: FormattedBody?, `mentions`: Mentions?): EditedContent {
            return FfiConverterTypeEditedContent.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_func_create_caption_edit(
        FfiConverterOptionalString.lower(`caption`),FfiConverterOptionalTypeFormattedBody.lower(`formattedCaption`),FfiConverterOptionalTypeMentions.lower(`mentions`),_status)
}
    )
    }
    

        /**
         * Set the global enablement level for the Sentry layer (after the logs have
         * been set up).
         */ fun `enableSentryLogging`(`enabled`: kotlin.Boolean)
        = 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_func_enable_sentry_logging(
        FfiConverterBoolean.lower(`enabled`),_status)
}
    
    
 fun `genTransactionId`(): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_func_gen_transaction_id(
        _status)
}
    )
    }
    

        /**
         * Create the actual url that can be used to setup the WebView or IFrame
         * that contains the widget.
         *
         * # Arguments
         * * `widget_settings` - The widget settings to generate the url for.
         * * `room` - A Matrix room which is used to query the logged in username
         * * `props` - Properties from the client that can be used by a widget to adapt
         * to the client. e.g. language, font-scale...
         */
    @Throws(ParseException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `generateWebviewUrl`(`widgetSettings`: WidgetSettings, `room`: Room, `props`: ClientProperties) : kotlin.String {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_func_generate_webview_url(FfiConverterTypeWidgetSettings.lower(`widgetSettings`),FfiConverterTypeRoom.lower(`room`),FfiConverterTypeClientProperties.lower(`props`),),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterString.lift(it) },
        // Error FFI converter
        ParseException.ErrorHandler,
    )
    }

        /**
         * The Capabilities required to run a element call widget.
         *
         * This is intended to be used in combination with: `acquire_capabilities` of
         * the `CapabilitiesProvider`.
         *
         * `acquire_capabilities` can simply return the `WidgetCapabilities` from this
         * function. Even if there are non intersecting permissions to what the widget
         * requested.
         *
         * Editing and extending the capabilities from this function is also possible,
         * but should only be done as temporal workarounds until this function is
         * adjusted
         */ fun `getElementCallRequiredPermissions`(`ownUserId`: kotlin.String, `ownDeviceId`: kotlin.String): WidgetCapabilities {
            return FfiConverterTypeWidgetCapabilities.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_func_get_element_call_required_permissions(
        FfiConverterString.lower(`ownUserId`),FfiConverterString.lower(`ownDeviceId`),_status)
}
    )
    }
    

        /**
         * Sets up logs and the tokio runtime for the current application.
         *
         * If `use_lightweight_tokio_runtime` is set to true, this will set up a
         * lightweight tokio runtime, for processes that have memory limitations (like
         * the NSE process on iOS). Otherwise, this can remain false, in which case a
         * multithreaded tokio runtime will be set up.
         */
    @Throws(ClientException::class) fun `initPlatform`(`config`: TracingConfiguration, `useLightweightTokioRuntime`: kotlin.Boolean)
        = 
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_func_init_platform(
        FfiConverterTypeTracingConfiguration.lower(`config`),FfiConverterBoolean.lower(`useLightweightTokioRuntime`),_status)
}
    
    

        /**
         * Verifies the passed `String` matches the expected room alias format:
         *
         * This means it's lowercase, with no whitespace chars, has a single leading
         * `#` char and a single `:` separator between the local and domain parts, and
         * the local part only contains characters that can't be percent encoded.
         */ fun `isRoomAliasFormatValid`(`alias`: kotlin.String): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_func_is_room_alias_format_valid(
        FfiConverterString.lower(`alias`),_status)
}
    )
    }
    

        /**
         * Log an event.
         *
         * The target should be something like a module path, and can be referenced in
         * the filter string given to `init_platform`. `level` and `target` for a
         * callsite are fixed at the first `log_event` call for that callsite and can
         * not be changed afterwards, i.e. the level and target passed for second and
         * following `log_event`s with the same callsite will be ignored.
         *
         * This function leaks a little bit of memory for each unique (file + line +
         * level + target) it is called with. Please make sure that the number of
         * different combinations of those parameters this can be called with is
         * constant in the final executable.
         */ fun `logEvent`(`file`: kotlin.String, `line`: kotlin.UInt?, `level`: LogLevel, `target`: kotlin.String, `message`: kotlin.String)
        = 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_func_log_event(
        FfiConverterString.lower(`file`),FfiConverterOptionalUInt.lower(`line`),FfiConverterTypeLogLevel.lower(`level`),FfiConverterString.lower(`target`),FfiConverterString.lower(`message`),_status)
}
    
    

    @Throws(ParseException::class) fun `makeWidgetDriver`(`settings`: WidgetSettings): WidgetDriverAndHandle {
            return FfiConverterTypeWidgetDriverAndHandle.lift(
    uniffiRustCallWithError(ParseException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_func_make_widget_driver(
        FfiConverterTypeWidgetSettings.lower(`settings`),_status)
}
    )
    }
    

        /**
         * Generates a `matrix.to` permalink to the given room alias.
         */
    @Throws(ClientException::class) fun `matrixToRoomAliasPermalink`(`roomAlias`: kotlin.String): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_func_matrix_to_room_alias_permalink(
        FfiConverterString.lower(`roomAlias`),_status)
}
    )
    }
    

        /**
         * Generates a `matrix.to` permalink to the given userID.
         */
    @Throws(ClientException::class) fun `matrixToUserPermalink`(`userId`: kotlin.String): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_func_matrix_to_user_permalink(
        FfiConverterString.lower(`userId`),_status)
}
    )
    }
    
 fun `messageEventContentFromHtml`(`body`: kotlin.String, `htmlBody`: kotlin.String): RoomMessageEventContentWithoutRelation {
            return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_html(
        FfiConverterString.lower(`body`),FfiConverterString.lower(`htmlBody`),_status)
}
    )
    }
    
 fun `messageEventContentFromHtmlAsEmote`(`body`: kotlin.String, `htmlBody`: kotlin.String): RoomMessageEventContentWithoutRelation {
            return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_html_as_emote(
        FfiConverterString.lower(`body`),FfiConverterString.lower(`htmlBody`),_status)
}
    )
    }
    
 fun `messageEventContentFromMarkdown`(`md`: kotlin.String): RoomMessageEventContentWithoutRelation {
            return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_markdown(
        FfiConverterString.lower(`md`),_status)
}
    )
    }
    
 fun `messageEventContentFromMarkdownAsEmote`(`md`: kotlin.String): RoomMessageEventContentWithoutRelation {
            return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_markdown_as_emote(
        FfiConverterString.lower(`md`),_status)
}
    )
    }
    

    @Throws(ClientException::class) fun `messageEventContentNew`(`msgtype`: MessageType): RoomMessageEventContentWithoutRelation {
            return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_func_message_event_content_new(
        FfiConverterTypeMessageType.lower(`msgtype`),_status)
}
    )
    }
    

        /**
         * `WidgetSettings` are usually created from a state event.
         * (currently unimplemented)
         *
         * In some cases the client wants to create custom `WidgetSettings`
         * for specific rooms based on other conditions.
         * This function returns a `WidgetSettings` object which can be used
         * to setup a widget using `run_client_widget_api`
         * and to generate the correct url for the widget.
         *
         * # Arguments
         *
         * * `props` - A struct containing the configuration parameters for a element
         * call widget.
         */
    @Throws(ParseException::class) fun `newVirtualElementCallWidget`(`props`: VirtualElementCallWidgetProperties, `config`: VirtualElementCallWidgetConfig): WidgetSettings {
            return FfiConverterTypeWidgetSettings.lift(
    uniffiRustCallWithError(ParseException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_func_new_virtual_element_call_widget(
        FfiConverterTypeVirtualElementCallWidgetProperties.lower(`props`),FfiConverterTypeVirtualElementCallWidgetConfig.lower(`config`),_status)
}
    )
    }
    

        /**
         * Parse a matrix entity from a given URI, be it either
         * a `matrix.to` link or a `matrix:` URI
         */ fun `parseMatrixEntityFrom`(`uri`: kotlin.String): MatrixEntity? {
            return FfiConverterOptionalTypeMatrixEntity.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_func_parse_matrix_entity_from(
        FfiConverterString.lower(`uri`),_status)
}
    )
    }
    

        /**
         * Updates the tracing subscriber with a new file writer based on the provided
         * configuration.
         *
         * This method will throw if `init_platform` hasn't been called, or if it was
         * called with `write_to_files` set to `None`.
         */
    @Throws(ClientException::class) fun `reloadTracingFileWriter`(`configuration`: TracingFileConfiguration)
        = 
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_func_reload_tracing_file_writer(
        FfiConverterTypeTracingFileConfiguration.lower(`configuration`),_status)
}
    
    

        /**
         * Transforms a Room's display name into a valid room alias name.
         */ fun `roomAliasNameFromRoomDisplayName`(`roomName`: kotlin.String): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_func_room_alias_name_from_room_display_name(
        FfiConverterString.lower(`roomName`),_status)
}
    )
    }
    
 fun `sdkGitSha`(): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_func_sdk_git_sha(
        _status)
}
    )
    }
    

        /**
         * Get the suggested power level for the given role.
         *
         * Returns an error if the value of the power level is unsupported.
         */
    @Throws(ClientException::class) fun `suggestedPowerLevelForRole`(`role`: RoomMemberRole): PowerLevel {
            return FfiConverterTypePowerLevel.lift(
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_func_suggested_power_level_for_role(
        FfiConverterTypeRoomMemberRole.lower(`role`),_status)
}
    )
    }
    

        /**
         * Get the suggested role for the given power level.
         *
         * Returns an error if the value of the power level is out of range for numbers
         * accepted in canonical JSON.
         */
    @Throws(ClientException::class) fun `suggestedRoleForPowerLevel`(`powerLevel`: PowerLevel): RoomMemberRole {
            return FfiConverterTypeRoomMemberRole.lift(
    uniffiRustCallWithError(ClientException) { _status ->
    UniffiLib.INSTANCE.uniffi_matrix_sdk_ffi_fn_func_suggested_role_for_power_level(
        FfiConverterTypePowerLevel.lower(`powerLevel`),_status)
}
    )
    }
    


